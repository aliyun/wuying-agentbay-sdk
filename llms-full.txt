# AgentBay SDK Repository



# AgentBay SDK

> The AgentBay SDK provides a comprehensive suite of tools for efficient interaction with AgentBay cloud environments, enabling you to create and manage cloud sessions, execute commands, operate files, and interact with user interfaces.

## 📦 Installation

| Language | Install Command | Documentation |
|----------|----------------|---------------|
| Python | `pip install wuying-agentbay-sdk` | [Python Docs](python/README.md) |
| TypeScript | `npm install wuying-agentbay-sdk` | [TypeScript Docs](typescript/README.md) |
| Golang | `go get github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay` | [Golang Docs](golang/README.md) |

## 🚀 Prerequisites

Before using the SDK, you need to:

1. Register an Alibaba Cloud account: [https://aliyun.com](https://aliyun.com)
2. Get APIKEY credentials: [AgentBay Console](https://agentbay.console.aliyun.com/service-management)
3. Set environment variable:
   - For Linux/MacOS:
```bash
    export AGENTBAY_API_KEY=your_api_key_here
```
   - For Windows:
```cmd
    setx AGENTBAY_API_KEY your_api_key_here
```

## 🚀 Quick Start

### Python
```python
from agentbay import AgentBay

# Create session and execute command
agent_bay = AgentBay()
session_result = agent_bay.create()
session = session_result.session
result = session.command.execute_command("echo 'Hello AgentBay'")
print(result.output)  # Hello AgentBay

# Clean up
agent_bay.delete(session)
```

### TypeScript
```typescript
import { AgentBay } from 'wuying-agentbay-sdk';

// Create session and execute command
const agentBay = new AgentBay();
const sessionResult = await agentBay.create();
const session = sessionResult.session;
const result = await session.command.executeCommand("echo 'Hello AgentBay'");
console.log(result.output);  // Hello AgentBay

// Clean up
await agentBay.delete(session);
```

### Golang
```go
import "github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"

// Create session and execute command
client, err := agentbay.NewAgentBay("", nil)
if err != nil {
    fmt.Printf("Failed to initialize AgentBay client: %v\n", err)
    return
}

sessionResult, err := client.Create(nil)
if err != nil {
    fmt.Printf("Failed to create session: %v\n", err)
    return
}

session := sessionResult.Session
result, err := session.Command.ExecuteCommand("echo 'Hello AgentBay'")
if err != nil {
    fmt.Printf("Failed to execute command: %v\n", err)
    return
}
fmt.Println(result.Output)  // Hello AgentBay

// Clean up
_, err = client.Delete(session, false)
if err != nil {
    fmt.Printf("Failed to delete session: %v\n", err)
    return
}
```

## 📚 Documentation

**[Complete Documentation](docs/README.md)** - Full guides, tutorials, and API references

### 👋 Choose Your Learning Path

**🆕 New Users** - If you're new to AgentBay or cloud development:
- [Quick Start Tutorial](docs/quickstart/README.md) - Get started in 5 minutes
- [Core Concepts](docs/quickstart/basic-concepts.md) - Understand cloud environments and sessions

**🚀 Experienced Users** - Already familiar with browser automation, computer use, mobile testing, or cloud development environments:
- Choose your environment:
  - 🌐 [Browser Automation](docs/guides/browser-use/README.md) - Web scraping, testing, form filling with stealth capabilities
  - 🖥️ [Computer/Windows Automation](docs/guides/computer-use/README.md) - Desktop UI automation and window management
  - 📱 [Mobile Automation](docs/guides/mobile-use/README.md) - Android UI testing and gesture automation
  - 💻 [CodeSpace](docs/guides/codespace/README.md) - Cloud-based code execution environments
- [Feature Guides](docs/guides/README.md) - Complete feature introduction
- API Reference - Core API quick lookup
  - [Python API Reference](python/docs/api/README.md)
  - [TypeScript API Reference](typescript/docs/api/README.md)
  - [Golang API Reference](golang/docs/api/README.md)
- [Cookbook](cookbook/README.md) - Real-world examples and recipes

## 🔧 Core Features

### 🎛️ Session Management
- **Session Creation & Lifecycle** - Create, manage, and delete cloud environments
- **Environment Configuration** - Configure SDK settings, regions, and endpoints  
- **Session Monitoring** - Monitor session status and health validation

### 🛠️ Common Modules
- **Command Execution** - Execute Shell commands in cloud environments
- **File Operations** - Upload, download, and manage cloud files
- **Data Persistence** - Save and retrieve data across sessions
- **Context Management** - Synchronize data and maintain state

### 🎯 Scenario-Based Features
- **Computer Use** - General automation and desktop operations
- **Browser Use** - Web automation, scraping, and browser control  
- **CodeSpace** - Code execution and development environment
- **Mobile Use** - Mobile device simulation and control

## 🆘 Get Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)

## 📞 Contact

Welcome to visit our product website and join our community!

- 🌐 **AgentBay International Website**: [https://www.alibabacloud.com/product/agentbay](https://www.alibabacloud.com/product/agentbay)  
- 🇨🇳 **AgentBay China Website (Chinese)**: [https://www.aliyun.com/product/agentbay](https://www.aliyun.com/product/agentbay)  
- 💬 **Discord Community**: [Join on Discord](https://discord.gg/kW55nTcT)  
- 💼 **DingTalk Group**: [Click to join](https://qr.dingtalk.com/action/joingroup?code=v1,k1,ZlCDtu+p3xq2MqVoIA3nYrvEWA21Gq86N91t9OuythQ=&_dt_no_comment=1&origin=11)

## 📄 License

This project is licensed under the Apache License 2.0 - see the [LICENSE](LICENSE) file for details.



---



# AgentBay SDK Documentation Center

> Complete documentation and development guides for the AgentBay SDK

## 📖 Getting Started

### New to AgentBay
- [Installation Guide](quickstart/installation.md) - SDK installation and environment setup
- [Basic Concepts](quickstart/basic-concepts.md) - Understand cloud environments and sessions
- [First Session](quickstart/first-session.md) - 5-minute quick start with hands-on examples


## 🔧 Feature Guides

- [Feature Guides Overview](guides/README.md) - Complete feature guides introduction

### Common Features (All Environments)
- [Common Features Guide](guides/common-features/README.md) - Features available across all environments

#### Basics
- [Session Management](guides/common-features/basics/session-management.md) - Cloud environment lifecycle management
- [Command Execution](guides/common-features/basics/command-execution.md) - Execute shell commands and scripts
- [File Operations](guides/common-features/basics/file-operations.md) - File upload, download, and management
- [Data Persistence](guides/common-features/basics/data-persistence.md) - Cross-session data storage

#### Advanced
- [Custom Images](guides/common-features/advanced/custom-images.md) - Create tailored environments with specific configurations
- [Session Link Access](guides/common-features/advanced/session-link-access.md) - Session connectivity and URL generation
- [VPC Sessions](guides/common-features/advanced/vpc-sessions.md) - Secure isolated network environments
- [Agent Modules](guides/common-features/advanced/agent-modules.md) - AI-powered task automation
- [OSS Integration](guides/common-features/advanced/oss-integration.md) - Object Storage Service integration

#### Configuration
- [SDK Configuration](guides/common-features/configuration/sdk-configuration.md) - Configuration options and settings

#### Use Cases
- [Use Cases Overview](guides/common-features/use-cases/README.md) - Common use case scenarios and implementations
- [Session Info Use Cases](guides/common-features/use-cases/session-info-use-cases.md) - Session information and connectivity patterns
- [Session Link Use Cases](guides/common-features/use-cases/session-link-use-cases.md) - Connect external tools to cloud sessions

### Environment-Specific Features

#### [Browser Use](guides/browser-use/README.md)
Complete browser automation for web scraping, testing, and form filling.

- [Core Features](guides/browser-use/core-features.md) - Basic browser operations
- [Advanced Features](guides/browser-use/advance-features.md) - Advanced browser capabilities
- [Code Examples](guides/browser-use/code-example.md) - Practical code samples
- [Browser Extensions](guides/browser-use/browser-extensions.md) - Extension management
- [Browser Replay](guides/browser-use/browser-replay.md) - Session replay functionality
- [Integrations](guides/browser-use/integrations.md) - Third-party integrations

**Key Capabilities:**
- [Browser Context](guides/browser-use/core-features/browser-context.md) - Context management
- [Browser Proxies](guides/browser-use/core-features/browser-proxies.md) - Network proxy configuration
- [CAPTCHA Handling](guides/browser-use/core-features/captcha.md) - Automated CAPTCHA solving
- [Extension Support](guides/browser-use/core-features/extension.md) - Browser extension management
- [Stealth Mode](guides/browser-use/core-features/stealth-mode.md) - Anti-detection techniques
- [Call for User](guides/browser-use/core-features/call-for-user.md) - User interaction requests
- [Page Agent](guides/browser-use/advance-features/page-use-agent.md) - AI-driven page operations

#### [Computer Use](guides/computer-use/README.md)
Windows desktop automation for application control and window management.

- [Computer Application Management](guides/computer-use/computer-application-management.md) - Application control and management
- [Computer UI Automation](guides/computer-use/computer-ui-automation.md) - Desktop UI interaction and automation
- [Window Management](guides/computer-use/window-management.md) - Window operations and focus management
- [Browser Capabilities by Image Type](guides/computer-use/browser-capabilities-by-image-type.md) - Understanding browser support across different images

**Key Capabilities:**
- Application Management (start, stop, list applications)
- Window Operations (maximize, minimize, resize, close)
- Focus Management
- Desktop Automation Workflows

#### [Mobile Use](guides/mobile-use/README.md)
Mobile UI automation for app testing and gesture-based interactions.

- [Mobile Application Management](guides/mobile-use/mobile-application-management.md) - Mobile app control and management
- [Mobile UI Automation](guides/mobile-use/mobile-ui-automation.md) - Mobile UI interaction and automation
- [ADB Connection](guides/mobile-use/adb-connection.md) - ADB connection and debugging capabilities
- [Mobile Session Configuration](guides/mobile-use/mobile-session-configuration.md) - Advanced mobile session configuration options

**Key Capabilities:**
- UI Element Detection
- Click Operations and Text Input
- Key Events and Swipe Gestures
- Screenshot Capture
- Mobile Application Management
- ADB Connection and Debugging

#### [CodeSpace](guides/codespace/README.md)
Development environment for code execution and scripting.

- [Code Execution](guides/codespace/code-execution.md) - Python and JavaScript code execution

**Key Capabilities:**
- Python and JavaScript Code Execution
- Shell Command Execution
- File System Operations
- Development Tools Integration
- Package Management (pip, npm, etc.)

#### Agent Module
An AI-powered Agent to complete tasks descibed in natural language

- [Agent Guide](guides/common-features/advanced/agent-modules.md) - Agent task execution guide

**Key Capabilities:**
- Office Automation: Word/Excel/PowerPoint automation
- File Operations: Create/Delete/Move/Copy files and folders
- Infomation Gathering: Gather information from the Internet
- Text Edition: Using notepad to edit text file

## 📚 API Reference

- [Python SDK](../python/README.md) - Python version documentation
- [TypeScript SDK](../typescript/README.md) - TypeScript version documentation
- [Golang SDK](../golang/README.md) - Golang version documentation

## 🚀 Learning Paths

Choose the appropriate learning path based on your experience level:

### 🆕 Complete Beginners
Start from the basics and build your knowledge step by step:
1. [Basic Concepts](quickstart/basic-concepts.md) - Understand core concepts
2. [Installation Guide](quickstart/installation.md) - Environment setup
3. [First Session](quickstart/first-session.md) - Hands-on practice
4. [Feature Guides](guides/README.md) - Explore specific features as needed

### 🚀 Experienced Developers
Already familiar with browser automation, computer use, or mobile testing? Start here:

**Quick Start (5 minutes):**
1. [Installation](quickstart/installation.md) - Set up your preferred SDK (Python/TypeScript/Golang)
2. Choose your environment based on your use case:
   - 🌐 [Browser Automation](guides/browser-use/README.md) - Web scraping, testing, form filling with stealth capabilities
   - 🖥️ [Computer/Windows Automation](guides/computer-use/README.md) - Desktop UI automation and window management
   - 📱 [Mobile Automation](guides/mobile-use/README.md) - Android UI testing and gesture automation
   - 💻 [CodeSpace](guides/codespace/README.md) - Cloud-based code execution environments

**What makes AgentBay different:**
- [Session Link](guides/common-features/advanced/session-link-access.md) - Direct URL access to services running in cloud sessions
- [Agent Modules](guides/common-features/advanced/agent-modules.md) - AI-powered automation capabilities
- [VPC Sessions](guides/common-features/advanced/vpc-sessions.md) - Secure isolated network environments

**Need more details?** See [Advanced Features](guides/common-features/advanced/README.md) or language-specific API docs: [Python](../python/README.md) | [TypeScript](../typescript/README.md) | [Golang](../golang/README.md)

## 📞 Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues) - Report bugs or request features

---

💡 **Tip**: We recommend starting with the [Quick Start Tutorial](quickstart/README.md), then exploring specific feature guides as needed.




# Feature Guides

Welcome to the AgentBay SDK Feature Guides. This documentation provides comprehensive guides for using AgentBay SDK features across different environments and scenarios.

## Navigation

### Common Features

Features available across all environments:

**Basics**
- [Session Management](common-features/basics/session-management.md) - Create, connect, and manage cloud sessions
- [Command Execution](common-features/basics/command-execution.md) - Execute shell commands and scripts
- [File Operations](common-features/basics/file-operations.md) - Upload, download, and manipulate files
- [Data Persistence](common-features/basics/data-persistence.md) - Persistent data storage and synchronization

**Configuration**
- [SDK Configuration](common-features/configuration/sdk-configuration.md) - SDK settings and environment variables

**Advanced**
- [Custom Images](common-features/advanced/custom-images.md) - Create tailored environments with specific configurations
- [Session Link Access](common-features/advanced/session-link-access.md) - Session connectivity and URL generation
- [VPC Sessions](common-features/advanced/vpc-sessions.md) - Virtual private cloud session configuration
- [Agent Modules](common-features/advanced/agent-modules.md) - AI-driven automation capabilities
- [OSS Integration](common-features/advanced/oss-integration.md) - Object Storage Service integration

### Environment-Specific Features

**[Browser Use](browser-use/README.md)**
- [Core Features](browser-use/core-features.md) - Basic browser automation features
  - [Stealth Mode](browser-use/core-features/stealth-mode.md) - Avoid detection
  - [Browser Context](browser-use/core-features/browser-context.md) - Isolated browser contexts
  - [Browser Proxies](browser-use/core-features/browser-proxies.md) - Proxy configuration
  - [CAPTCHA Handling](browser-use/core-features/captcha.md) - CAPTCHA solving strategies
  - [Extensions](browser-use/core-features/extension.md) - Browser extension support
  - [Call for User](browser-use/core-features/call-for-user.md) - User interaction handling
- [Advanced Features](browser-use/advance-features.md) - Advanced browser capabilities
  - [Page Agent](browser-use/advance-features/page-use-agent.md) - AI-powered page automation
- [Browser Extensions](browser-use/browser-extensions.md) - Extension development
- [Browser Replay](browser-use/browser-replay.md) - Session recording and replay
- [Code Examples](browser-use/code-example.md) - Browser automation code examples
- [Integrations](browser-use/integrations.md) - Third-party tool integrations

**[Computer Use](computer-use/README.md)**
- [Computer UI Automation](computer-use/computer-ui-automation.md) - Desktop UI interaction
- [Window Management](computer-use/window-management.md) - Window control and manipulation
- [Computer Application Management](computer-use/computer-application-management.md) - Application lifecycle management

**[Mobile Use](mobile-use/README.md)**
- [Mobile UI Automation](mobile-use/mobile-ui-automation.md) - Mobile UI interaction
- [Mobile Application Management](mobile-use/mobile-application-management.md) - App lifecycle management
- [ADB Connection](mobile-use/adb-connection.md) - Android Debug Bridge connectivity

**[CodeSpace](codespace/README.md)**
- [Code Execution](codespace/code-execution.md) - Running code in cloud environments

## Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Main Documentation](../README.md)




# AgentBay AIBrowser Guide

Welcome to the AgentBay AIBrowser Guides! This provides complete functionality introduction and best practices for experienced developers.

## 🎯 Quick Navigation

- [Example](code-example.md) - Index for examples demonstrating core & advance features
- [Core Features](core-features.md) - Essential browser features and typical workflows
- [Advance Features](advance-features.md) - Advanced configuration and capabilities
- [Integrations](integrations.md) - Seamlessly weave with community tools and frameworks, extending your automation reach

## 🚀 What is AgentBay AIBrowser?

Agentbay AIBrowser is a managed platform for running headless/non-headless browsers at scale. It provides infrastructure to create and manage sessions, initialize browser instances, and allocate the underlying hardware resources on demand. It is designed for webpage automation scenarios such as filling out forms, simulating user actions, and orchestrating complex multi-step tasks across modern, dynamic websites.

The Agentbay AIBrowser API offers simple primitives to control browsers, practical utilities to create/manage sessions, and advanced AI capabilities to execute tasks described in natural language.

### Key Features

- Automation framework compatibility: Highly compatible with Playwright and Puppeteer via CDP
- Secure and scalable infrastructure: Managed sessions, isolation, and elastic resource allocation
- Observability: Session Replay, Session Inspector, and Live Mode for real-time debugging
- Advanced capabilities: Context management, IP proxy, and stealth/fingerprinting options
- AI-powered PageUseAgent: Execute natural-language tasks for complex web workflows
- Rich APIs: Clean primitives for sessions, browser lifecycle, and agent operations

### Quick Start (Python)

Below is a minimal, runnable example showing how to initialize the browser via the AgentBay Python SDK and drive it using Playwright over CDP. It follows the same flow as the reference example in `python/docs/examples/browser/visit_aliyun.py`.

Prerequisites:
- Set your API key: `export AGENTBAY_API_KEY=your_api_key`
- Install dependencies: `pip install wuying-agentbay-sdk playwright`
- Install Playwright browsers: `python -m playwright install chromium`

```python
import os
import asyncio
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams
from agentbay.browser.browser import BrowserOption
from playwright.async_api import async_playwright

async def main():
    api_key = os.getenv("AGENTBAY_API_KEY")
    if not api_key:
        raise RuntimeError("AGENTBAY_API_KEY environment variable not set")

    agent_bay = AgentBay(api_key=api_key)

    # Create a session (use an image with browser preinstalled)
    params = CreateSessionParams(image_id="browser_latest")
    session_result = agent_bay.create(params)
    if not session_result.success:
        raise RuntimeError(f"Failed to create session: {session_result.error_message}")

    session = session_result.session

    # Initialize browser (supports stealth, proxy, fingerprint, etc. via BrowserOption)
    ok = await session.browser.initialize_async(BrowserOption())
    if not ok:
        raise RuntimeError("Browser initialization failed")

    endpoint_url = session.browser.get_endpoint_url()

    # Connect Playwright over CDP and automate
    async with async_playwright() as p:
        browser = await p.chromium.connect_over_cdp(endpoint_url)
        context = browser.contexts[0]
        page = await context.new_page()
        await page.goto("https://www.aliyun.com")
        print("Title:", await page.title())
        await browser.close()

    session.delete()

if __name__ == "__main__":
    asyncio.run(main())
```

### Quick Start (Golang)

Below is a minimal, runnable example showing how to initialize the browser via the AgentBay Golang SDK and drive it using Playwright over CDP.

Prerequisites:
- Set your API key: `export AGENTBAY_API_KEY=your_api_key`
- Install Golang SDK: `go get github.com/aliyun/wuying-agentbay-sdk/golang`
- Install Playwright for Go: `go get github.com/playwright-community/playwright-go`
- Install Playwright browsers: `go run github.com/playwright-community/playwright-go/cmd/playwright@latest install chromium`

```go
package main

import (
	"fmt"
	"log"
	"os"

	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay/browser"
	"github.com/playwright-community/playwright-go"
)

func main() {
	apiKey := os.Getenv("AGENTBAY_API_KEY")
	if apiKey == "" {
		log.Fatal("AGENTBAY_API_KEY environment variable not set")
	}

	// Authenticate with API key
	agentBay := agentbay.NewAgentBay(apiKey)

	// Create a session (use an image with browser preinstalled)
	params := &agentbay.CreateSessionParams{
		ImageId: "browser_latest",
	}
	sessionResult, err := agentBay.Create(params)
	if err != nil {
		log.Fatalf("Failed to create session: %v", err)
	}
	if !sessionResult.Success {
		log.Fatalf("Failed to create session: %s", sessionResult.ErrorMessage)
	}

	session := sessionResult.Session
	defer session.Delete()

	// Initialize browser (supports stealth, proxy, fingerprint, etc. via BrowserOption)
	ok, err := session.Browser.Initialize(browser.NewBrowserOption())
	if err != nil || !ok {
		log.Fatalf("Browser initialization failed: %v", err)
	}

	endpointURL, err := session.Browser.GetEndpointURL()
	if err != nil {
		log.Fatalf("Failed to get endpoint URL: %v", err)
	}

	// Connect Playwright over CDP and automate
	pw, err := playwright.Run()
	if err != nil {
		log.Fatalf("Failed to start Playwright: %v", err)
	}
	defer pw.Stop()

	browser, err := pw.Chromium.ConnectOverCDP(endpointURL)
	if err != nil {
		log.Fatalf("Failed to connect over CDP: %v", err)
	}
	defer browser.Close()

	contexts := browser.Contexts()
	if len(contexts) == 0 {
		log.Fatal("No browser contexts available")
	}
	context := contexts[0]

	page, err := context.NewPage()
	if err != nil {
		log.Fatalf("Failed to create new page: %v", err)
	}

	_, err = page.Goto("https://www.aliyun.com")
	if err != nil {
		log.Fatalf("Failed to navigate: %v", err)
	}

	title, err := page.Title()
	if err != nil {
		log.Fatalf("Failed to get title: %v", err)
	}
	fmt.Println("Title:", title)
}
```

First, the script authenticates by building an `AgentBay` client with your API key, establishing a trusted channel to the platform. 

Then it provisions a fresh execution environment by creating a session with a browser-enabled image, ensuring the necessary runtime is available. 

After that, the session’s browser is initialized with `BrowserOption()`, bringing up a remote browser instance ready for automation. 

Next, it retrieves the CDP endpoint URL via `get_endpoint_url()` and connects to it using Playwright’s `connect_over_cdp`, bridging your local code to the remote browser. 

Now, with a live connection established, the code opens a new page, navigates to a website, and can freely inspect or manipulate the DOM just like a local browser. 

Finally, when all work is complete, the session is explicitly deleted to release the allocated resources.

Key Browser APIs:
- `Browser.initialize(option: BrowserOption) -> bool` / `initialize_async(...)`: Start the browser instance for a session
- `Browser.get_endpoint_url() -> str`: Return CDP WebSocket endpoint; use with Playwright `connect_over_cdp`
- `Browser.is_initialized() -> bool`: Check if the browser is ready

## Basic Configurations

Sometimes the web needs a different mask and a different stage. By shaping the browser's identity and canvas, you can coax sites to reveal the experience meant for a specific device class or audience. Here we'll set a custom user agent and a precise viewport, then watch the page respond.

```python
import os
import asyncio
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams
from agentbay.browser.browser import BrowserOption, BrowserViewport
from playwright.async_api import async_playwright

CUSTOM_UA = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36"

async def main():
    agent_bay = AgentBay(api_key=os.environ["AGENTBAY_API_KEY"])  # first, authenticate

    params = CreateSessionParams(image_id="browser_latest")       # then, provision a browser-ready session
    result = agent_bay.create(params)
    if not result.success:
        raise RuntimeError(result.error_message)

    session = result.session

    # after that, define how the browser should look and feel
    option = BrowserOption(
        user_agent=CUSTOM_UA,                    # present ourselves with a custom identity
        viewport=BrowserViewport(width=1366, height=768),  # and stand on a stage sized like a common laptop
    )

    ok = await session.browser.initialize_async(option)
    if not ok:
        raise RuntimeError("Browser initialization failed")

    endpoint_url = session.browser.get_endpoint_url()      # now, discover the CDP doorway

    async with async_playwright() as p:
        browser = await p.chromium.connect_over_cdp(endpoint_url)  # step through and take control
        context = browser.contexts[0]
        page = await context.new_page()

        await page.goto("https://www.whatismybrowser.com/detect/what-is-my-user-agent")
        # verify our new voice and our new stage
        ua = await page.evaluate("navigator.userAgent")
        w = await page.evaluate("window.innerWidth")
        h = await page.evaluate("window.innerHeight")
        print("Effective UA:", ua)
        print("Viewport:", w, "x", h)

        await browser.close()

    session.delete()  # finally, bow out and free the stage

if __name__ == "__main__":
    asyncio.run(main())
```

**Golang:**

```go
package main

import (
	"fmt"
	"log"
	"os"

	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay/browser"
	"github.com/playwright-community/playwright-go"
)

const CUSTOM_UA = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36"

func main() {
	// First, authenticate
	agentBay := agentbay.NewAgentBay(os.Getenv("AGENTBAY_API_KEY"))

	// Then, provision a browser-ready session
	params := &agentbay.CreateSessionParams{
		ImageId: "browser_latest",
	}
	result, err := agentBay.Create(params)
	if err != nil || !result.Success {
		log.Fatalf("Failed to create session: %v", err)
	}
	session := result.Session
	defer session.Delete()

	// After that, define how the browser should look and feel
	option := browser.NewBrowserOption()
	option.UserAgent = &CUSTOM_UA                     // present ourselves with a custom identity
	option.Viewport = &browser.BrowserViewport{       // and stand on a stage sized like a common laptop
		Width:  1366,
		Height: 768,
	}

	ok, err := session.Browser.Initialize(option)
	if err != nil || !ok {
		log.Fatalf("Browser initialization failed: %v", err)
	}

	// Now, discover the CDP doorway
	endpointURL, err := session.Browser.GetEndpointURL()
	if err != nil {
		log.Fatalf("Failed to get endpoint URL: %v", err)
	}

	// Step through and take control
	pw, err := playwright.Run()
	if err != nil {
		log.Fatalf("Failed to start Playwright: %v", err)
	}
	defer pw.Stop()

	browserInstance, err := pw.Chromium.ConnectOverCDP(endpointURL)
	if err != nil {
		log.Fatalf("Failed to connect over CDP: %v", err)
	}
	defer browserInstance.Close()

	context := browserInstance.Contexts()[0]
	page, err := context.NewPage()
	if err != nil {
		log.Fatalf("Failed to create page: %v", err)
	}

	_, err = page.Goto("https://www.whatismybrowser.com/detect/what-is-my-user-agent")
	if err != nil {
		log.Fatalf("Failed to navigate: %v", err)
	}

	// Verify our new voice and our new stage
	ua, err := page.Evaluate("navigator.userAgent")
	if err != nil {
		log.Fatalf("Failed to get user agent: %v", err)
	}
	w, err := page.Evaluate("window.innerWidth")
	if err != nil {
		log.Fatalf("Failed to get window width: %v", err)
	}
	h, err := page.Evaluate("window.innerHeight")
	if err != nil {
		log.Fatalf("Failed to get window height: %v", err)
	}

	fmt.Printf("Effective UA: %v\n", ua)
	fmt.Printf("Viewport: %v x %v\n", w, h)
}
```

First we authenticate and create a session that knows how to host a browser. Then, instead of accepting the default identity, we dress the browser in a chosen user agent and set a viewport that mirrors a familiar laptop screen. After that, we breathe life into the browser with `initialize_async`, request the CDP endpoint, and cross the bridge with Playwright. Now the page loads under our chosen disguise and dimensions; a quick glance at `navigator.userAgent` and the window size confirms the transformation. And when the scene is over, we close the curtain by deleting the session, returning the resources so another performance can begin.

### Browser Type Selection

> **Note:** The `browser_type` / `browserType` option is only available for **computer use images**. For standard browser images, Chromium is used by default.

By default, the browser initializes with Chromium, but when using computer use images, you can choose to use Chrome instead. This is useful when you need specific Chrome features or want to match a particular browser environment. Simply set the `browser_type` parameter in `BrowserOption`:

**Python:**
```python
from agentbay.browser.browser import BrowserOption
from agentbay.session_params import CreateSessionParams

# Create session with computer use image
params = CreateSessionParams(image_id="browser_latest")
result = agent_bay.create(params)
session = result.session

# Use Chrome instead of Chromium
option = BrowserOption(browser_type="chrome")
await session.browser.initialize_async(option)

# Or explicitly use Chromium (default)
option = BrowserOption(browser_type="chromium")
await session.browser.initialize_async(option)
```

**TypeScript:**
```typescript
import { CreateSessionParams } from '@wuying-org/agentbay-sdk';

// Create session with computer use image
const params = new CreateSessionParams({ imageId: 'browser_latest' });
const result = await agentBay.create(params);
const session = result.session;

// Use Chrome instead of Chromium (simple approach)
await session.browser.initializeAsync({ browserType: 'chrome' });

// Or explicitly use Chromium
await session.browser.initializeAsync({ browserType: 'chromium' });

// Or use default (undefined - let browser image decide)
await session.browser.initializeAsync({});
```

**Golang:**
```go
import (
	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay/browser"
)

// Create session with computer use image
params := &agentbay.CreateSessionParams{
	ImageId: "browser_latest",
}
result, err := agentBay.Create(params)
if err != nil {
	// handle error
}
session := result.Session

// Use Chrome instead of Chromium
option := browser.NewBrowserOption()
chromeType := "chrome"
option.BrowserType = &chromeType

success, err := session.Browser.Initialize(option)
if err != nil || !success {
	// handle error
}

// Or explicitly use Chromium
chromiumType := "chromium"
option2 := browser.NewBrowserOption()
option2.BrowserType = &chromiumType

success, err = session.Browser.Initialize(option2)

// Or leave as default (nil, browser decides)
option3 := browser.NewBrowserOption()
// option3.BrowserType is nil by default

success, err = session.Browser.Initialize(option3)
```

The `browser_type` (Python), `browserType` (TypeScript), or `BrowserType` (Golang) option accepts:
- `"chromium"`: Uses the open-source Chromium browser
- `"chrome"`: Uses Google Chrome browser (only available in computer use images)
- `None`/`undefined`/`nil` (default): Lets the browser image decide which browser to use

If you want to explore more configurable capabilities, see Core Features: [core-features.md](core-features.md).

## Utilizing PageUseAgent

PageUseAgent lets you speak to the browser in natural language and have it carry out intent-driven actions. Instead of meticulously crafting selectors and sequences, you describe the goal; the agent interprets it, maps it to DOM operations, and executes the steps reliably—with optional timeouts, iframe awareness, and variable injection for dynamic prompts.

Below we’ll search for a book on Google. First we bring a browser to life and open Google, then we ask the agent to perform the task: type the query and open the first result.

```python
import os
import asyncio
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams
from agentbay.browser.browser import BrowserOption
from agentbay.browser.browser_agent import ActOptions
from playwright.async_api import async_playwright

BOOK_QUERY = "The Pragmatic Programmer"

async def main():
    agent_bay = AgentBay(api_key=os.environ["AGENTBAY_API_KEY"])  # authenticate

    params = CreateSessionParams(image_id="browser_latest")       # provision session with browser image
    result = agent_bay.create(params)
    if not result.success:
        raise RuntimeError(result.error_message)
    session = result.session

    # initialize the remote browser
    if not await session.browser.initialize_async(BrowserOption()):
        raise RuntimeError("Browser initialization failed")

    endpoint_url = session.browser.get_endpoint_url()

    async with async_playwright() as p:
        browser = await p.chromium.connect_over_cdp(endpoint_url)
        context = browser.contexts[0]
        page = await context.new_page()

        # step onto the stage
        await page.goto("https://www.google.com")

        # ask the agent to act: type the book name into the search box
        act_result = await session.browser.agent.act_async(ActOptions(
            action=f"Type '{BOOK_QUERY}' into the search box and submit",
        ), page)
        print("act_result:", act_result.success, act_result.message)

        # let the agent open the first result
        open_first = await session.browser.agent.act_async(ActOptions(
            action="Click the first result in the search results",
        ), page)
        print("open_first:", open_first.success, open_first.message)

        # pause briefly to observe
        await page.wait_for_timeout(5000)
        await browser.close()

    session.delete()

if __name__ == "__main__":
    asyncio.run(main())
```

First we create and initialize a browser session as before; then, rather than hand-writing selectors, we simply tell the agent what to do—type a query and proceed to the first result. After that, the agent translates our intent into concrete interactions on the page. Now the browser flows from search box to results like a guided hand. Finally, we close the browser and release the session.

About `PageUseAgent.act`:
- Can interpolate dynamic values using `variables` for reusable prompts
- Operates on the active Playwright page by resolving its `context_id` and `page_id` under the hood
- Returns a structured `ActResult` with `success`, `message`, useful for logging and recovery flows

If you want to explore full capability of PageUseAgent, or other more advance features, see Advance Features: [advance-features.md](advance-features.md).

### Limitations

PageUseAgent does not include a long-horizon planner and won’t orchestrate multi-step schedules by itself. It relies on your invoker (or a higher-level agent) to break a project into steps and call `act` or other PageUseAgent method for each one. Its strength is in precise, atomic web operations—clicking, filling, scrolling, etc.—executed quickly and consistently. This narrow focus is deliberate: it prioritizes throughput and accuracy of each step while leaving complex task planning and branching logic to external controllers.










# PageUseAgent Guide 

An AI-powered, natural-language web agent that performs precise, reliable page operations via AgentBay’s managed browser. It exposes simple SDK methods to navigate, observe, act, extract.

- Works with natural language instructions
- Supports structured extraction via Pydantic schemas
- Uses MCP tools under the hood (no local browser needed)
- Optional Playwright CDP connection for advanced scenarios

## Table of Contents

- [PageUseAgent Guide](#pageuseagent-guide)
  - [Table of Contents](#table-of-contents)
  - [Quick Start](#quick-start)
    - [Prerequisites](#prerequisites)
    - [Minimal Example](#minimal-example)
  - [Architecture Overview](#architecture-overview)
  - [Core APIs](#core-apis)
    - [Navigation](#navigation)
    - [Screenshot](#screenshot)
    - [Observe](#observe)
    - [Act](#act)
    - [Extract](#extract)
    - [Close Session](#close-session)
  - [End-to-End Examples](#end-to-end-examples)
    - [1) Recipe Site (Search + Extract)](#1-recipe-site-search--extract)
    - [2) Apple Purchase Flow (Sequence of Acts)](#2-apple-purchase-flow-sequence-of-acts)
    - [3) Amazon Demo (Observe → Act → Assert)](#3-amazon-demo-observe--act--assert)
  - [Error Handling and Debug](#error-handling-and-debug)
  - [Best Practices](#best-practices)
  - [FAQ](#faq)

---

## Quick Start

### Prerequisites

- Python 3.10+
- Install: `pip install wuying-agentbay-sdk`
- Set environment variable `AGENTBAY_API_KEY`

### Minimal Example

```python
import os
import asyncio
from pydantic import BaseModel, Field
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams
from agentbay.browser.browser import BrowserOption
from agentbay.browser.browser_agent import BrowserAgent, ActOptions, ExtractOptions

class Product(BaseModel):
    name: str = Field(..., description="Product name")
    price: str | None = Field(None, description="Price text")
    link: str = Field(..., description="Relative product link like /products/abc")

class ProductList(BaseModel):
    products: list[Product]

async def main():
    agent_bay = AgentBay(api_key=os.getenv("AGENTBAY_API_KEY"))

    # Create a browser session
    params = CreateSessionParams(image_id="browser_latest")  # your image id
    session_result = agent_bay.create(params)
    if not session_result.success:
        print(f"Create session failed: {session_result.error_message}")
        return
    session = session_result.session

    # Initialize managed browser
    ok = await session.browser.initialize_async(BrowserOption())
    if not ok:
        print("Browser initialization failed")
        return

    agent: BrowserAgent = session.browser.agent

    # Navigate
    print(await agent.navigate_async("https://example.com"))

    # Act (natural language)
    await agent.act_async(action_input=ActOptions(action="go to products or shop page"))

    # Extract structured data
    ok, data = await agent.extract_async(
        options=ExtractOptions(
            instruction="Extract all products with name, optional price, and relative link",
            schema=ProductList,
            use_text_extract=True
        )
    )
    if ok:
        print(f"Extracted {len(data.products)} products")
    else:
        print("Extraction failed")

    # Clean up
    await agent.close_async()
    session.delete()

if __name__ == "__main__":
    asyncio.run(main())
```

Notes:
- `page` is optional; `None` uses the current managed page.
- `image_id` depends on your backend catalog (e.g., `browser_latest`).

---

## Architecture Overview

- Your code calls `BrowserAgent` (SDK).
- SDK invokes MCP tools within the managed browser image:
  - `page_use_navigate`
  - `page_use_observe`
  - `page_use_act`
  - `page_use_extract`
  - `page_use_screenshot`
  - `page_use_close_session`
- No local browser needed. Optionally, you can connect via Playwright CDP to the managed browser for custom checks.

---

## Core APIs

### Navigation

```python
# Sync
def navigate(self, url: str) -> str

# Async
async def navigate_async(self, url: str) -> str
```

- Description: Navigates the managed page to the given URL.
- Returns: Result message string.

Example:
```python
await agent.navigate_async("https://example.com")
```

---

### Screenshot

```python
# Sync
def screenshot(self, page=None, full_page=True, quality=80, clip=None, timeout=None) -> str

# Async
async def screenshot_async(self, page=None, full_page=True, quality=80, clip=None, timeout=None) -> str
```

- Returns: A base64-encoded PNG.
  - By default, the MCP tool wraps it as a data URL like `data:image/png;base64,<...>`.
  - If you call lower-level internals (e.g., CDP or event bus) you may receive raw base64 without the `data:image/...` prefix.
- `page` is optional; the managed page is used by default.

Parameters:
- full_page (bool): Capture the full scrollable page (default True).
- quality (int): 0–100, for JPEG format only (default 80).
- clip (dict | None): Clipping region with keys {x, y, width, height}. If provided, `full_page` is ignored.
- timeout (int | None): Operation timeout in ms.

Example (robust decode for both formats):
```python
data = await agent.screenshot_async()
if data.startswith("data:image/"):
    header, encoded = data.split(",", 1)
    png_bytes = base64.b64decode(encoded)
else:
    png_bytes = base64.b64decode(data)
```

---

### Observe

```python
# Options
class ObserveOptions:
    def __init__(self, instruction: str, iframes: bool | None = None, dom_settle_timeout_ms: int | None = None)

# Result
class ObserveResult:
    def __init__(self, selector: str, description: str, method: str, arguments: dict)

# APIs
def observe(self, page, options: ObserveOptions) -> tuple[bool, list[ObserveResult]]
async def observe_async(self, page, options: ObserveOptions) -> tuple[bool, list[ObserveResult]]
```

- Description: Finds elements or actionable targets based on natural language.
- Returns: `(success, [ObserveResult])`

Example:
```python
ok, items = await agent.observe_async(
    options=ObserveOptions(
        instruction="find the Add to Cart button",
    )
)
```

---

### Act

```python
# Options
class ActOptions:
    def __init__(self, action: str, timeoutMS: int | None = None, iframes: bool | None = None,
                 dom_settle_timeout_ms: int | None = None, variables: dict[str, str] | None = None)

# Result
class ActResult:
    def __init__(self, success: bool, message: str, action: str)

# APIs
def act(self, action_input: Union[ObserveResult, ActOptions], page) -> ActResult
async def act_async(self, action_input: Union[ObserveResult, ActOptions], page) -> ActResult
```

- Description: Performs an action with NL instruction or using an `ObserveResult`.
- Returns: `ActResult(success, message, action)`

Examples:
```python
# Natural language
await agent.act_async(action_input=ActOptions(action="type 'ipad' in the search bar and press enter"))

# Act on observed element
ok, items = await agent.observe_async(options=ObserveOptions(instruction="find the sign in button"))
if ok and items:
    await agent.act_async(action_input=items[0])
```

---

### Extract

```python
# Generic Options
class ExtractOptions(Generic[T]):
    def __init__(self, instruction: str, schema: Type[T], use_text_extract: bool | None = None,
                 selector: str | None = None, iframe: bool | None = None,
                 dom_settle_timeout_ms: int | None = None, use_vision: bool | None = None)

# APIs
def extract(self, options: ExtractOptions[T], page) -> tuple[bool, T]
async def extract_async(self, options: ExtractOptions[T], page) -> tuple[bool, T]
```

- Description: Extracts structured data as a Pydantic model instance.
- Returns: `(success, model_instance)`
- Options:
  - use_text_extract (bool): Prefer text-based parsing when true (useful for text-heavy pages).
  - use_vision (bool): Attach a viewport screenshot to help the model interpret visually-indicated states (optional).
  - selector, iframe, dom_settle_timeout_ms: Narrow scope or tune stability.

Example:
```python
from pydantic import BaseModel

class Item(BaseModel):
    name: str
    price: str | None
    link: str

class ItemList(BaseModel):
    products: list[Item]

ok, result = await agent.extract_async(
    options=ExtractOptions(
        instruction="extract all products with name, price and link",
        schema=ItemList,
        use_text_extract=True,
        use_vision=True
    )
)
```

---

### Close Session

```python
async def close_async(self) -> bool
```

- Gracefully closes the remote browser agent session.

---

## End-to-End Examples

### 1) Recipe Site (Search + Extract)

```python
from pydantic import BaseModel, Field
from agentbay.browser.browser_agent import ActOptions, ExtractOptions

class RecipeDetails(BaseModel):
    title: str = Field(..., description="Recipe title")
    total_ratings: int | None

await agent.navigate_async("https://www.allrecipes.com/")
await agent.act_async(action_input=ActOptions(action='type "chocolate chip cookies" in the search bar'))
await agent.act_async(action_input=ActOptions(action="press enter"))

ok, data = await agent.extract_async(
    options=ExtractOptions(
        instruction="extract the title and the total number of ratings from the first recipe",
        schema=RecipeDetails,
        use_text_extract=True,
    )
)
```

### 2) Apple Purchase Flow (Sequence of Acts)

```python
actions = [
    "click on the buy button",
    "select the Pro Max model",
    "select the natural titanium color",
    "select the 256GB storage option",
    "click on the 'select a smartphone' trade-in option",
    "select the iPhone 13 mini model from the dropdown",
    "select the iPhone 13 mini is in good condition",
]

for a in actions:
    await agent.act_async(action_input=ActOptions(action=a))
```

### 3) Amazon Demo (Observe → Act → Assert)

```python
from agentbay.browser.browser_agent import ObserveOptions

ok, obs1 = await agent.observe_async(
    options=ObserveOptions(instruction="Find and click the 'Add to Cart' button")
)
if ok and obs1:
    await agent.act_async(action_input=obs1[0])

ok, obs2 = await agent.observe_async(
    options=ObserveOptions(instruction="Find and click the 'Proceed to checkout' button")
)
if ok and obs2:
    await agent.act_async(action_input=obs2[0])
```

---

## Error Handling and Debug

- Exceptions surfaced by the SDK:
  - `BrowserError`: SDK-side or tool invocation failures.
  - `AgentBayError`: Service-related errors (wrapped to `BrowserError` by default).

- Result types:
  - `ActResult`: `{ success: bool, message: str, action: str }`
  - `observe` returns `(success: bool, results: list[ObserveResult])`
  - `extract` returns `(success: bool, data: T)`

- MCP validation hints:
  - If you see Pydantic validation errors (e.g., dropdown indices must be >= 1), ensure your generated action JSON conforms to the tool schema.
  - Avoid passing extra fields not defined in the schema.

---

## Best Practices

- Write concise, unambiguous natural-language actions.
- For structured data, always define strict Pydantic schemas.
- Use `use_text_extract=True` for text-heavy pages; use DOM-based for structured layouts.
- Consider `use_vision=True` for visually-driven pages to improve robustness.
- Chain `Observe -> Act` when direct acting is ambiguous.
- Consider small waits between dependent steps on dynamic pages.

---

## FAQ

- Do I need Playwright locally?
  - The agent runs in a managed browser session. Local Playwright is optional for your custom checks via CDP.

- How do I pass variables into actions?
  - Use `ActOptions.variables` (dict) and ensure your backend/tooling supports placeholders.

- How do screenshots return?
  - By default, as a data URL `data:image/png;base64,<...>`. If you use lower-level internals, you may get raw base64 without the header.

- Observe vs Extract?
  - `observe` finds actionable elements; `extract` returns structured data based on your schema.
## 📚 Related Guides

- [Browser Use Overview](../README.md) - Complete browser automation features
- [Session Management](../../common-features/basics/session-management.md) - Session lifecycle and configuration
- [Code Examples](../code-example.md) - PageUseAgent example code

## 🆘 Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Documentation Home](../../README.md)




# AIBrowser Advance Features

## PageUseAgent

- [PageUseagent](advance-features/page-use-agent.md) - An AI-powered, natural-language describing task supported web agent for precise, reliable page operations 
## 📚 Related Guides

- [PageUseAgent Guide](advance-features/page-use-agent.md) - AI-powered web automation
- [Browser Use Overview](README.md) - Complete browser automation features
- [Core Features](core-features.md) - Browser core capabilities
- [Code Examples](code-example.md) - PageUseAgent example code

## 🆘 Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Documentation Home](../README.md)




# Browser Extension Management Guide

This guide covers how to use browser extensions with the AgentBay SDK for automated testing and browser automation workflows.

## Overview

The AgentBay SDK provides comprehensive browser extension management capabilities, allowing you to:

- Upload and manage browser extensions in the cloud
- Automatically synchronize extensions to browser sessions
- Test extension functionality in controlled environments
- Develop and iterate on extensions with cloud infrastructure

## Prerequisites

- AgentBay Python SDK installed (`pip install wuying-agentbay-sdk`)
- Valid AgentBay API key
- Browser extension packaged as ZIP file
- Basic understanding of browser automation concepts

## Quick Start

### 1. Basic Extension Upload and Usage

```python
from agentbay import AgentBay
from agentbay.extension import ExtensionsService
from agentbay.session_params import CreateSessionParams, BrowserContext

# Initialize AgentBay and Extensions Service
agent_bay = AgentBay(api_key="your_api_key")
extensions_service = ExtensionsService(agent_bay)

# Upload your extension
extension = extensions_service.create("/path/to/your-extension.zip")
print(f"Extension uploaded: {extension.name} (ID: {extension.id})")

# Create browser session with extension
ext_option = extensions_service.create_extension_option([extension.id])

session_params = CreateSessionParams(
    labels={"purpose": "extension_testing"},
    browser_context=BrowserContext(
        context_id="extension_test_session",
        extension_option=ext_option
    )
)

# Create session - extension will be automatically synchronized
session_result = agent_bay.create(session_params)
session = session_result.session

# Extensions are now available at /tmp/extensions/ in the session
print("Extension session created successfully!")

# Clean up when done
extensions_service.cleanup()
```

### 2. Working with Multiple Extensions

```python
# Upload multiple extensions
extension_paths = [
    "/path/to/extension1.zip",
    "/path/to/extension2.zip",
    "/path/to/extension3.zip"
]

extension_ids = []
for path in extension_paths:
    ext = extensions_service.create(path)
    extension_ids.append(ext.id)
    print(f"✅ Uploaded: {ext.name}")

# Create session with all extensions
ext_option = extensions_service.create_extension_option(extension_ids)

session_params = CreateSessionParams(
    browser_context=BrowserContext(
        context_id="multi_extension_session",
        extension_option=ext_option
    )
)

session = agent_bay.create(session_params).session
```

## Core Concepts

### Extension Context Management

The SDK automatically manages extension storage contexts:

- **Auto-creation**: If no context is specified, a unique context is created automatically
- **Context reuse**: Specify a context name to reuse existing extension storage
- **Automatic cleanup**: Contexts created by the service can be automatically cleaned up

```python
# Auto-generated context (recommended for simple use cases)
extensions_service = ExtensionsService(agent_bay)

# Named context (recommended for persistent extension management)
extensions_service = ExtensionsService(agent_bay, "my_project_extensions")

# Context will be created if it doesn't exist
```

### Extension Synchronization

Extensions are automatically synchronized to browser sessions:

- **Automatic sync**: No manual intervention required
- **File location**: Extensions available at `/tmp/extensions/{extension_id}/` in sessions
- **Session isolation**: Each session gets its own copy of extensions

## Common Workflows

### Extension Development and Testing

```python
class ExtensionDevelopmentWorkflow:
    def __init__(self, api_key: str):
        self.agent_bay = AgentBay(api_key=api_key)
        self.extensions_service = ExtensionsService(self.agent_bay, "dev_extensions")
        self.extension_id = None
    def upload_extension(self, extension_path: str) -> str:
        """Upload extension for development testing."""
        extension = self.extensions_service.create(extension_path)
        self.extension_id = extension.id
        print(f"✅ Extension uploaded: {extension.name}")
        return extension.id

    def create_test_session(self) -> 'Session':
        """Create a browser session for testing."""
        ext_option = self.extensions_service.create_extension_option([self.extension_id])

        session_params = CreateSessionParams(
            labels={"purpose": "extension_development"},
            browser_context=BrowserContext(
                context_id="dev_session",
                extension_option=ext_option
            )
        )

        return self.agent_bay.create(session_params).session

    def update_and_test(self, new_extension_path: str):
        """Update extension and create new test session."""
        # Update existing extension
        updated_ext = self.extensions_service.update(self.extension_id, new_extension_path)
        print(f"✅ Extension updated: {updated_ext.name}")

        # Create new test session with updated extension
        return self.create_test_session()

    def cleanup(self):
        """Clean up development resources."""
        if self.extension_id:
            self.extensions_service.delete(self.extension_id)
        self.extensions_service.cleanup()

# Usage
workflow = ExtensionDevelopmentWorkflow(api_key="your_api_key")
try:
    # Development cycle
    workflow.upload_extension("/path/to/extension-v1.zip")
    session1 = workflow.create_test_session()
    # Test extension functionality...

    # Update and test again
    session2 = workflow.update_and_test("/path/to/extension-v2.zip")
    # Test updated functionality...

finally:
    workflow.cleanup()
```

### Automated Extension Testing

```python
def run_extension_tests(extension_paths: List[str]) -> bool:
    """Run automated tests on multiple extensions."""

    agent_bay = AgentBay()
    extensions_service = ExtensionsService(agent_bay)

    try:
        # Upload all test extensions
        extension_ids = []
        for path in extension_paths:
            ext = extensions_service.create(path)
            extension_ids.append(ext.id)
            print(f"📦 Uploaded test extension: {ext.name}")

        # Create test session
        ext_option = extensions_service.create_extension_option(extension_ids)

        session_params = CreateSessionParams(
            labels={"test_type": "automated_extension_testing"},
            browser_context=BrowserContext(
                context_id="auto_test_session",
                extension_option=ext_option
            )
        )

        session = agent_bay.create(session_params).session

        # Wait for extension synchronization
        print("⏳ Waiting for extension synchronization...")

        # Run your extension tests here
        # Extensions are available at /tmp/extensions/ in the session
        test_results = run_test_suite(session)

        return test_results.all_passed

    except Exception as e:
        print(f"❌ Test failed: {e}")
        return False
    finally:
        extensions_service.cleanup()

# Usage
test_extensions = [
    "/path/to/test-extension-1.zip",
    "/path/to/test-extension-2.zip"
]

success = run_extension_tests(test_extensions)
print(f"Test result: {'✅ PASSED' if success else '❌ FAILED'}")
```

## Best Practices

### 1. Context Management

✅ **Do:**

- Use descriptive context names for persistent projects
- Let the service auto-generate contexts for simple use cases
- Always call `cleanup()` in finally blocks

❌ **Don't:**

- Hardcode context IDs in your application code
- Forget to clean up auto-created contexts
- Mix extensions from different projects in the same context

### 2. Extension File Management

✅ **Do:**

- Use ZIP format for all extension packages
- Validate file existence before upload
- Include proper manifest.json in extensions
- Handle upload errors gracefully

❌ **Don't:**

- Upload uncompressed extension directories
- Skip file validation steps
- Ignore upload error responses

### 3. Session Management

✅ **Do:**

- Use meaningful labels for sessions
- Wait for extension synchronization before testing
- Create one ExtensionOption per session

❌ **Don't:**

- Start testing immediately after session creation
- Reuse ExtensionOption across multiple sessions
- Forget to specify browser_context when using extensions

### 4. Error Handling

```python
from agentbay.exceptions import AgentBayError

def robust_extension_workflow():
    extensions_service = None
    try:
        agent_bay = AgentBay()
        extensions_service = ExtensionsService(agent_bay, "production_extensions")
        # Validate extension file
        extension_path = "/path/to/production-extension.zip"
        if not os.path.exists(extension_path):
            raise FileNotFoundError(f"Extension not found: {extension_path}")

        # Upload with error handling
        extension = extensions_service.create(extension_path)
        print(f"✅ Extension uploaded: {extension.id}")

        # Create session with validation
        ext_option = extensions_service.create_extension_option([extension.id])
        if not ext_option.validate():
            raise ValueError("Invalid extension configuration")
        session_params = CreateSessionParams(
            browser_context=BrowserContext(
                context_id="production_session",
                extension_option=ext_option
            )
        )

        session = agent_bay.create(session_params).session
        return session

    except FileNotFoundError as e:
        print(f"❌ File error: {e}")
        return None
    except AgentBayError as e:
        print(f"❌ AgentBay error: {e}")
        return None
    except Exception as e:
        print(f"❌ Unexpected error: {e}")
        return None
    finally:
        if extensions_service:
            extensions_service.cleanup()
```

## Troubleshooting

### Common Issues

**Extension not found in session:**

- Check that extension was uploaded successfully
- Verify session was created with proper ExtensionOption
- Wait for synchronization to complete before accessing files

**Upload failures:**

- Ensure file is in ZIP format
- Check file permissions and accessibility
- Verify API key and network connectivity

**Context errors:**

- Use unique context names to avoid conflicts
- Don't mix extensions from different sources
- Clean up contexts when no longer needed

### Debugging Tips

```python
# Enable verbose logging
import logging
logging.basicConfig(level=logging.DEBUG)

# Check extension list
extensions = extensions_service.list()
print(f"Available extensions: {[ext.name for ext in extensions]}")

# Validate extension option
ext_option = extensions_service.create_extension_option([extension.id])
print(f"Extension option valid: {ext_option.validate()}")
print(f"Extension option: {ext_option}")

# Check session creation result
session_result = agent_bay.create(session_params)
if not session_result.success:
    print(f"Session creation failed: {session_result.error_message}")
```

## Integration with Browser Automation

Extensions work seamlessly with browser automation tools:

```python
from playwright.sync_api import sync_playwright

# Create session with extensions
session = create_extension_session()

# Get browser endpoint
endpoint_url = session.browser.get_endpoint_url()

# Connect with Playwright
with sync_playwright() as p:
    browser = p.chromium.connect_over_cdp(endpoint_url)
    context = browser.contexts[0]
    page = await context.new_page()

    # Extensions are already loaded and available
    page.goto("https://example.com")

    # Your extension should be active here
    # Test extension functionality...

    browser.close()
```

## 📚 Related Guides

- [Extension Management](core-features/extension.md) - Detailed extension management guide
- [Browser Context](core-features/browser-context.md) - Persistent browser state management
- [Browser Use Overview](README.md) - Complete browser automation features
- [Session Management](../common-features/basics/session-management.md) - Session lifecycle and configuration

## 🆘 Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Documentation Home](../README.md)




# Browser Replay Guide

This guide covers how to use AgentBay's built-in browser replay feature to capture browser interactions and replay them for debugging, documentation, or compliance purposes.

## Overview

AgentBay provides automatic browser replay capabilities for browser sessions, powered by the **rrweb** (record and replay the web) framework. This allows you to:

- 🎥 **Record all browser interactions** automatically with high fidelity
- 📊 **Monitor user interactions** for compliance and training
- 🐛 **Debug complex workflows** by reviewing detailed replays
- 🔍 **Analyze user behavior** with frame-by-frame precision

### Why rrweb?

rrweb is a modern, open-source solution that offers several advantages over traditional screen recording:

- **Precise DOM capture** - Records actual DOM changes, not just visual pixels
- **Efficient storage** - Only captures changes, resulting in smaller file sizes
- **Cross-platform compatibility** - Works consistently across different browsers and devices
- **Interactive replay** - Allows pausing, seeking, and step-by-step analysis
- **Event-based recording** - Captures incremental changes rather than full page snapshots

**Note:** rrweb focuses on DOM and user interaction recording. AgentBay enhances this with additional console and network monitoring capabilities.

## Quick Start

### 1. Enable Browser Replay

To enable browser replay, set `enable_browser_replay=True` when creating a session:

```python
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams

# Create session with browser replay enabled
params = CreateSessionParams(
    image_id="browser_latest",
    enable_browser_replay=True,  # 🎬 Enable browser replay
)

result = agent_bay.create(params)
session = result.session
```

### 2. Perform Browser Operations

Once browser replay is enabled, all browser interactions will be automatically captured:

```python
from agentbay.browser import BrowserOption
from playwright.sync_api import sync_playwright

# Initialize browser
browser = session.browser
browser.initialize(BrowserOption())
endpoint_url = browser.get_endpoint_url()

# All operations will be recorded
with sync_playwright() as p:
    playwright_browser = p.chromium.connect_over_cdp(endpoint_url)
    # Create a new page with default context
    default_context = playwright_browser.contexts[0]
    page = default_context.new_page()

    # These actions will be recorded
    page.goto("https://example.com")
    page.fill("input[name='search']", "AgentBay")
    page.click("button[type='submit']")

    page.close()
```

### 3. Replay Files Storage

Browser replay files are automatically generated and stored by the system. These files can be accessed through the [AgentBay CONSOLE](https://agentbay.console.aliyun.com/session-log) website.

## Browser Replay Details

### What Gets Captured

The browser replay captures information using rrweb's advanced recording capabilities, enhanced with additional monitoring:

  - ✅ **DOM mutations** - Element changes, additions, removals, and CSS modifications
  - ✅ **Console output** - Logs, errors, warnings, and debug messages
  - ✅ **Network activity** - HTTP requests, API calls, and WebSocket connections


## Use Cases

### 1. Automated Testing

Record test execution for debugging failed tests:

```python
def run_test_with_replay():
    # Create session with browser replay
    params = CreateSessionParams(
        image_id="browser_latest",
        enable_browser_replay=True,
        labels={"test_type": "ui_automation", "replay": "enabled"}
    )

    session = agent_bay.create(params).session

    try:
        # Run your test - all actions will be recorded
        run_ui_test(session)
        print("Test completed - replay files generated for review")
    except Exception as e:
        # Test failed - replay files can help debug
        print(f"Test failed: {e}")
        print("Browser replay files are available for debugging")
    finally:
        agent_bay.delete(session)
```

### 2. User Journey Documentation

Record user workflows for documentation:

```python
def document_user_journey():
    params = CreateSessionParams(
        image_id="browser_latest",
        enable_browser_replay=True,
        labels={"purpose": "documentation", "workflow": "user_onboarding"}
    )

    session = agent_bay.create(params).session

    # Perform the user journey steps
    simulate_user_onboarding(session)

    print("User journey recorded - replay files generated for documentation")

    agent_bay.delete(session)
```

### 3. Compliance and Auditing

Record sessions for compliance purposes:

```python
def compliance_session():
    params = CreateSessionParams(
        image_id="browser_latest",
        enable_browser_replay=True,
        labels={
            "compliance": "SOX",
            "auditor": "external",
            "session_type": "compliance_check"
        }
    )

    session = agent_bay.create(params).session

    # Perform compliance-sensitive operations
    perform_financial_operations(session)

    print("Compliance operations recorded for audit trail")

    agent_bay.delete(session)
```

## Best Practices

### Performance Considerations

1. **Session Duration**: Longer sessions create larger recording files
2. **Resolution**: Higher resolution = larger files but better quality
3. **Activity Level**: More interactions = more data to record

### Security Considerations

1. **Sensitive Data**: Be aware that browser replay captures all visible content
2. **Session Access**: Control who can create sessions with replay enabled
3. **Label Management**: Use proper labels for categorizing and tracking replay sessions

## Troubleshooting

### Common Issues

**Browser replay not working:**
```python
# Verify that replay is enabled
if hasattr(session, 'enableBrowserReplay'):
    print(f"Browser replay enabled: {session.enableBrowserReplay}")
else:
    print("Browser replay not enabled - check session parameters")
```

**Session creation with replay fails:**
```python
# Check session parameters
params = CreateSessionParams(
    image_id="browser_latest",  # Must use browser image
    enable_browser_replay=True,         # Enable replay
    labels={"replay": "enabled"}
)
```

## Advanced Features

### Session Context and Metadata

Add context to your browser replay sessions using session labels:

```python
params = CreateSessionParams(
    image_id="browser_latest",
    enable_browser_replay=True,
    labels={
        "replay_purpose": "bug_reproduction",
        "bug_id": "ISSUE-1234",
        "user_id": "test_user_001",
        "test_environment": "staging",
        "browser_version": "chrome_latest"
    }
)
```

This metadata helps with session organization and tracking but does not affect the replay functionality itself.

## Example: Complete Browser Replay Workflow

Here's a complete example that demonstrates the full browser replay workflow:

```python
#!/usr/bin/env python3
"""Complete browser replay workflow example"""

import os
import time
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams
from agentbay.browser import BrowserOption
from playwright.sync_api import sync_playwright

def complete_replay_workflow():
    # Initialize
    agent_bay = AgentBay(api_key=os.getenv("AGENTBAY_API_KEY"))

    # 1. Create session with browser replay
    params = CreateSessionParams(
        image_id="browser_latest",
        enable_browser_replay=True,
        labels={"example": "complete_workflow", "replay": "enabled"}
    )

    session = agent_bay.create(params).session
    print(f"✅ Session created: {session.session_id}")
    print(f"📹 Browser replay enabled: {session.enableBrowserReplay}")

    try:
        # 2. Perform browser operations
        browser = session.browser
        browser.initialize(BrowserOption())

        with sync_playwright() as p:
            playwright_browser = p.chromium.connect_over_cdp(browser.get_endpoint_url())
            # Create a new page with default context
            default_context = playwright_browser.contexts[0]
            page = default_context.new_page()

            # All interactions will be captured
            page.goto("https://example.com")
            page.click("a[href='#']")  # Example interaction
            time.sleep(2)

            page.close()
            playwright_browser.close()

        print("✅ Browser operations completed - replay files generated")

    finally:
        # 3. Cleanup
        agent_bay.delete(session)
        print("✅ Session cleaned up")

if __name__ == "__main__":
    complete_replay_workflow()
```
## 📚 Related Guides

- [Browser Use Overview](README.md) - Complete browser automation features
- [Session Management](../common-features/basics/session-management.md) - Session lifecycle and configuration

## 🆘 Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Documentation Home](../README.md)




# Code Example

## Basic Use for AIBrowser

### Basic automation

- [Simple visit](../../../python/docs/examples/browser-use/browser/visit_aliyun.py) - A minimal example showing how to initialize the browser with basic AIBrowser API call

- [Viewport and UserAgent (Python)](../../../python/docs/examples/browser-use/browser/browser_viewport.py) - A python example showing how to initialize the browser with custom viewport and user-agent settings
- [Viewport and UserAgent (TypeScript)](../../../typescript/docs/examples/browser-use/browser/browser-viewport.ts) - A typescript example showing how to initialize the browser with custom viewport and user-agent settings

## Core Features

### Context

- [Cookie Persistence (Python)](../../../python/docs/examples/browser-use/browser/browser_context_cookie_persistence.py) - Demonstrate how to persist cookies across multiple browser sessions using Browser Context
- [Cookie Persistence (TypeScript)](../../../typescript/docs/examples/browser-use/browser/browser-context-cookie-persistence.ts) - TypeScript version of cookie persistence example

### Extension

- [Basic Extension Usage (Python)](../../../python/docs/examples/browser-use/extension/basic_extension_usage.py) - Basic extension upload and browser session creation with extensions
- [Basic Extension Usage (TypeScript)](../../../typescript/docs/examples/browser-use/extension-example/extension-example.ts) - Comprehensive extension management in TypeScript

### Upload/Download

### Stealth Mode
- [Stealth with fingerprint (Python)](../../../python/docs/examples/browser-use/browser/browser_stealth.py) - A python example showing how to use browser stealth mode with fingerprint to avoid detection by anti-bot services
- [Stealth with fingerprint (TypeScript)](../../../typescript/docs/examples/browser-use/browser/browser-stealth.ts) - A typescript example showing how to use browser stealth mode with fingerprint to avoid detection by anti-bot services

### IPProxy
- [Browser Proxy (Python)](../../../python/docs/examples/browser-use/browser/browser-proxies.py) - A python example showing how to configure custom and Wuying proxy servers for IP rotation

- [Browser Proxy (TypeScript)](../../../typescript/docs/examples/browser-use/browser/browser-proxies.ts) - A typescript example showing how to configure custom and Wuying proxy servers for IP rotation

### Captcha Resolving
- [CAPTCHA Resolution (Python)](../../../python/docs/examples/browser-use/browser/captcha_tongcheng.py) - A python example showing how to use AIBrowser to automatically solve slider-type CAPTCHAs
- [CAPTCHA Resolution (TypeScript)](../../../typescript/docs/examples/browser-use/browser/captcha_tongcheng.ts) - A typescript example showing how to use AIBrowser to automatically solve slider-type CAPTCHAs

### Call For User
- [Call For User (Python)](../../../python/docs/examples/browser-use/browser/call_for_user_jd.py) - A python example showing how to handle wuying-call-for-user messages that require human intervention during browser automation
- [Call For User (TypeScript)](../../../typescript/docs/examples/browser-use/browser/call_for_user_jd.ts) - A typescript example showing how to handle wuying-call-for-user messages that require human intervention during browser automation

## Advanced Features

### PageUseAgent

- [Aliyun search & help](../../../python/docs/examples/browser-use/browser/search_agentbay_doc_by_agent.py) - Search on aliyun.com and open Help docs using PageUse Agent
- [Admin add product](../../../python/docs/examples/browser-use/browser/admin_add_product.py) - Fill admin form fields via variables and submit
- [2048 GAME](../../../python/docs/examples/browser-use/browser/game_2048.py) - Extract 2048 grid and play using a heuristic/minimax strategy
- [Sudoku GAME](../../../python/docs/examples/browser-use/browser/game_sudoku.py) - Extract a 9x9 Sudoku board, solve locally, and fill results on page
- [Expense invoices upload](../../../python/docs/examples/browser-use/browser/expense_upload_invoices.py) - Login, upload multiple PDFs to expense form, and submit
- [Alimeeting availability](../../../python/docs/examples/browser-use/browser/alimeeting_availability.py) - Find available meeting rooms for a time window
- [Shop inspector](../../../python/docs/examples/browser-use/browser/shop_inspector.py) - Batch crawl sites, extract product name/price/link and save to JSON
- [GV quick buy & seating](../../../python/docs/examples/browser-use/browser/gv_quick_buy_seat.py) - Quick Buy flow on gv.com.sg and select a single seat

## 📚 Related Guides

- [Browser Use Overview](README.md) - Complete browser automation features
- [Core Features](core-features.md) - Browser core capabilities
- [Advanced Features](advance-features.md) - PageUseAgent and advanced capabilities

## 🆘 Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Documentation Home](../README.md)




# Browser Command-Line Arguments Configuration Guide

---

## Overview

Browser Command-Line Arguments is a core feature of the AgentBay SDK that enables developers to customize browser launch parameters and control browser behavior. This functionality allows you to pass custom Chrome/Chromium command-line arguments to fine-tune browser settings, disable specific features, or enable experimental functionality for your automation needs.

## Key Features

### 1. Custom Command-Line Arguments
Configure Chrome/Chromium with specific command-line arguments.

### 2. Default Navigation URL
Set a default URL that the browser navigates to upon initialization.

## Configuration Of BrowserOption

### Command-Line Arguments (`cmdArgs`)
An array of Chrome/Chromium command-line arguments to customize browser behavior.

**Common Examples:**
- `--disable-features=PrivacySandboxSettings4` - Disable privacy sandbox
- `--disable-extensions-http-throttling` - Disable HTTP request throttling for extensions
- `--disable-background-timer-throttling` - Disable background timer throttling to prevent performance issues
- `--password-store=basic` - Use basic password storage instead of system keychain

### Default Navigate URL (`defaultNavigateUrl`)
The URL that the browser automatically navigates to after initialization. For Browser Initialize operations, it's **highly recommended** to use Chrome internal pages (e.g., `chrome://version/`, `chrome://settings/`) or extension pages instead of internet URLs. Navigating to internet pages during initialization may cause timeout of browser launch.


## Go Implementation

```go
package main

import (
	"fmt"
	"log"
	"os"
	"time"

	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay/browser"
)

func main() {
	// Get API key from environment variable
	apiKey := os.Getenv("AGENTBAY_API_KEY")
	if apiKey == "" {
		log.Fatal("AGENTBAY_API_KEY environment variable is required")
	}

	// Initialize AgentBay client
	fmt.Println("Initializing AgentBay client...")
	agentBay, err := agentbay.NewAgentBay(apiKey)
	if err != nil {
		log.Fatalf("Error initializing AgentBay client: %v", err)
	}

	// Create session parameters
	fmt.Println("Creating a new session...")
	params := agentbay.NewCreateSessionParams().WithImageId("linux_latest")

	// Create a new session
	sessionResult, err := agentBay.Create(params)
	if err != nil {
		log.Fatalf("Error creating session: %v", err)
	}

	session := sessionResult.Session
	fmt.Printf("Session created with ID: %s\n", session.SessionID)

	// Defer session cleanup
	defer func() {
		fmt.Println("Cleaning up session...")
		if _, err := session.Delete(); err != nil {
			log.Printf("Warning: Error deleting session: %v", err)
		} else {
			fmt.Println("Session deleted successfully")
		}
	}()

	// Create browser option with custom command arguments and default navigate URL
	browserOption := browser.NewBrowserOption()
	browserOption.CmdArgs = []string{"--disable-features=PrivacySandboxSettings4"}
	defaultUrl := "chrome://version/"
	browserOption.DefaultNavigateUrl = &defaultUrl

	fmt.Println("Browser configuration:")
	fmt.Printf("- Command arguments: %v\n", browserOption.CmdArgs)
	if browserOption.DefaultNavigateUrl != nil {
		fmt.Printf("- Default navigate URL: %s\n", *browserOption.DefaultNavigateUrl)
	}

	// Initialize browser
	fmt.Println("Initializing browser...")
	success, err := session.Browser.Initialize(browserOption)
	if err != nil {
		log.Fatalf("Failed to initialize browser: %v", err)
	}

	if success {
		fmt.Println("Browser initialized successfully")
	} else {
		log.Fatal("Browser initialization failed")
	}

	// Wait for some time to allow user interaction
	fmt.Println("Waiting for 20 seconds...")
	time.Sleep(20 * time.Second)

	// Destroy browser
	fmt.Println("Destroying browser...")
	err = session.Browser.Destroy()
	if err != nil {
		log.Fatalf("Failed to destroy browser: %v", err)
	}
	fmt.Println("Browser destroyed successfully")

	fmt.Println("\n=== Browser Command Arguments Example Completed ===")
}
```

## Python Implementation

```python
import os
import asyncio

from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams
from agentbay.browser.browser import BrowserOption
from playwright.async_api import async_playwright

async def main():
    # Get API key from environment variable
    api_key = os.getenv("AGENTBAY_API_KEY")
    if not api_key:
        print("Error: AGENTBAY_API_KEY environment variable not set")
        return

    # Initialize AgentBay client
    print("Initializing AgentBay client...")
    agent_bay = AgentBay(api_key=api_key)

    # Create a session
    print("Creating a new session...")
    params = CreateSessionParams(
        image_id="linux_latest"
    )
    session_result = agent_bay.create(params)

    if session_result.success:
        session = session_result.session
        print(f"Session created with ID: {session.session_id}")

        # Create browser option with custom command arguments and default navigate URL
        browser_option = BrowserOption(
            cmd_args=["--disable-features=PrivacySandboxSettings4"],
            default_navigate_url="chrome://version/",
        )

        print("Browser configuration:")
        print("- Command arguments:", browser_option.cmd_args)
        print("- Default navigate URL:", browser_option.default_navigate_url)

        if await session.browser.initialize_async(browser_option):
            print("Browser initialized successfully")
            
            # Get browser endpoint URL
            endpoint_url = session.browser.get_endpoint_url()
            print(f"endpoint_url = {endpoint_url}")

            # Use Playwright to connect and validate
            async with async_playwright() as p:
                browser = await p.chromium.connect_over_cdp(endpoint_url)
                context = browser.contexts[0]
                page = context.pages[0]

                try:
                    # Check if browser navigated to default URL
                    print("\n--- Check Default Navigation ---")
                    await asyncio.sleep(2)  # Wait for navigation
                    current_url = page.url
                    print(f"Current URL: {current_url}")
                    
                    if "chrome://version/" in current_url:
                        print("✓ Browser successfully navigated to default URL")
                    else:
                        print("✗ Browser did not navigate to default URL")

                    # Test command arguments effect by checking Chrome version page
                    if "chrome://version/" in current_url:
                        print("\n--- Check Chrome Version Info ---")
                        version_info = await page.evaluate("""
                            () => {
                                const versionElement = document.querySelector('#version');
                                const commandLineElement = document.querySelector('#command_line');
                                return {
                                    version: versionElement ? versionElement.textContent : 'Not found',
                                    commandLine: commandLineElement ? commandLineElement.textContent : 'Not found'
                                };
                            }
                        """)
                        
                        print(f"Chrome Version: {version_info['version']}")
                        print(f"Command Line: {version_info['commandLine']}")
                        
                        if "--disable-features=PrivacySandboxSettings4" in version_info['commandLine']:
                            print("✓ Custom command argument found in browser")
                        else:
                            print("✗ Custom command argument not found in browser")

                    await asyncio.sleep(3)
                finally:
                    await browser.close()
                    session.browser.destroy()
        else:
            print("Failed to initialize browser")

        # Clean up session
        agent_bay.delete(session)
    else:
        print("Failed to create session", session_result.error_message)

if __name__ == "__main__":
    asyncio.run(main())
```

## TypeScript Implementation

```typescript
import { AgentBay, CreateSessionParams } from 'wuying-agentbay-sdk';
import { BrowserOption } from 'wuying-agentbay-sdk';
import { chromium } from 'playwright';

async function main(): Promise<void> {
    // Get API key from environment variable
    const apiKey = process.env.AGENTBAY_API_KEY;
    if (!apiKey) {
        console.log('Error: AGENTBAY_API_KEY environment variable not set');
        return;
    }

    try {
        // Initialize AgentBay client
        console.log('Initializing AgentBay client...');
        const agentBay = new AgentBay({ apiKey });

        // Create a session
        console.log('Creating a new session...');
        const params: CreateSessionParams = {
            imageId: 'linux_latest',
        };
        const sessionResult = await agentBay.create(params);

        if (!sessionResult.success) {
            console.log('Failed to create session');
            return;
        }

        const session = sessionResult.session;
        console.log(`Session created with ID: ${session.sessionId}`);

        // Create browser option with custom command arguments and default navigate URL
        const browserOption: BrowserOption = {
            cmdArgs: ['--disable-features=PrivacySandboxSettings4'],
            defaultNavigateUrl: 'chrome://version/',
        };

        console.log('Browser configuration:');
        console.log('- Command arguments:', browserOption.cmdArgs);
        console.log('- Default navigate URL:', browserOption.defaultNavigateUrl);

        const initialized = await session.browser.initializeAsync(browserOption);
        if (initialized) {
            const endpointUrl = await session.browser.getEndpointUrl();
            console.log('endpoint_url =', endpointUrl);

            const browser = await chromium.connectOverCDP(endpointUrl);
            const context = browser.contexts()[0];
            const page = context.pages()[0];

            try {
                // Check if browser navigated to default URL
                console.log('\n--- Check Default Navigation ---');
                await page.waitForTimeout(2000); // Wait for navigation
                const currentUrl = page.url();
                console.log('Current URL:', currentUrl);
                
                if (currentUrl.includes('chrome://version/')) {
                    console.log('✓ Browser successfully navigated to default URL');
                } else {
                    console.log('✗ Browser did not navigate to default URL');
                }

                // Test command arguments effect by checking Chrome version page
                if (currentUrl.includes('chrome://version/')) {
                    console.log('\n--- Check Chrome Version Info ---');
                    const versionInfo = await page.evaluate(() => {
                        const versionElement = document.querySelector('#version');
                        const commandLineElement = document.querySelector('#command_line');
                        return {
                            version: versionElement ? versionElement.textContent : 'Not found',
                            commandLine: commandLineElement ? commandLineElement.textContent : 'Not found'
                        };
                    });
                    
                    console.log('Chrome Version:', versionInfo.version);
                    console.log('Command Line:', versionInfo.commandLine);
                    
                    if (versionInfo.commandLine.includes('--disable-features=PrivacySandboxSettings4')) {
                        console.log('✓ Custom command argument found in browser');
                    } else {
                        console.log('✗ Custom command argument not found in browser');
                    }
                }

                await page.waitForTimeout(3000);
            } finally {
                await browser.close();
            }
            await session.browser.destroy();
        }

        // Clean up session
        await agentBay.delete(session);
    } catch (error) {
        console.error('Error:', error);
    }
}

main().catch(console.error);
```


## Limitations

- **Chrome/Chromium Only**: Command arguments are specific to Chrome/Chromium browsers
- **Platform Differences**: Some arguments may behave differently across operating systems
- **Version Compatibility**: Certain arguments may not be available in all Chrome versions
- **Security Restrictions**: Some arguments may be restricted in certain environments

## 📚 Related Guides

- [Browser Proxy Configuration](browser-proxies.md) - Configure proxy settings for browser sessions
- [Browser Context](browser-context.md) - Browser context management for cookies and sessions
- [Stealth Mode](stealth-mode.md) - Anti-detection techniques for web automation
- [Browser Use Overview](../README.md) - Complete browser automation features
- [Session Management](../../common-features/basics/session-management.md) - Session lifecycle and configuration

## 🆘 Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Documentation Home](../../README.md)




# Browser Context Guide

Browser Context is a core feature of the AgentBay SDK that enables persistent browser state management across multiple sessions. It allows you to maintain cookies, cache, local storage, and other browser data between sessions, significantly reducing anti-bot friction and speeding up web page navigation.

## Overview

A Browser Context represents a persistent browser environment that stores browser state such as:
- Cookies
- Cache
- Local storage
- Session storage
- Browser preferences
- Installed extensions (when used with Extension Management)

## Key Benefits

1. **Reduced Anti-Bot Friction**: By maintaining browser state, websites recognize your sessions as returning users rather than new visitors
2. **Faster Page Loads**: Cached resources and cookies reduce page load times
3. **Session Continuity**: Continue where you left off across multiple sessions
4. **Consistent User Experience**: Maintain user preferences and settings

## Python Implementation

### Basic Usage

```python
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams, BrowserContext

# Initialize AgentBay client
agent_bay = AgentBay(api_key="your_api_key")

# Create or get a persistent context
context_result = agent_bay.context.get("my-browser-context", create=True)
context = context_result.context

# Create browser session with context
browser_context = BrowserContext(
    context_id=context.id,
    auto_upload=True
)

session_params = CreateSessionParams(
    image_id="browser-image-id",
    browser_context=browser_context
)

session_result = agent_bay.create(session_params)
session = session_result.session
```

### Cookie Persistence Example

```python
import time
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams, BrowserContext
from agentbay.browser.browser import BrowserOption
from playwright.sync_api import sync_playwright

# Initialize AgentBay
agent_bay = AgentBay(api_key="your_api_key")

# Create persistent context
context_result = agent_bay.context.get("cookie-demo-context", create=True)
context = context_result.context

# First session - set cookies
browser_context = BrowserContext(
    context_id=context.id,
    auto_upload=True
)

params = CreateSessionParams(
    image_id="browser-image-id",
    browser_context=browser_context
)

session1 = agent_bay.create(params).session

# Set cookies in first session
session1.browser.initialize(BrowserOption())
endpoint_url = session1.browser.get_endpoint_url()

with sync_playwright() as p:
    browser = p.chromium.connect_over_cdp(endpoint_url)
    context_p = browser.contexts[0] if browser.contexts else browser.new_context()
    page = context_p.new_page()
    
    # Navigate and set cookies
    page.goto("https://example.com")
    context_p.add_cookies([
        {
            "name": "session_cookie",
            "value": "session_value",
            "domain": "example.com",
            "path": "/",
        }
    ])
    
    browser.close()

# Delete first session with context sync
agent_bay.delete(session1, sync_context=True)

# Second session - verify cookies persist
session2 = agent_bay.create(params).session

# Check cookies in second session
session2.browser.initialize(BrowserOption())
endpoint_url2 = session2.browser.get_endpoint_url()

with sync_playwright() as p:
    browser = p.chromium.connect_over_cdp(endpoint_url2)
    context_p = browser.contexts[0] if browser.contexts else browser.new_context()
    
    # Verify cookies persist
    cookies = context_p.cookies()
    print(f"Persisted cookies: {cookies}")
    
    browser.close()
```

## TypeScript Implementation

### Basic Usage

```typescript
import { AgentBay, CreateSessionParams, BrowserContext } from 'wuying-agentbay-sdk';

// Initialize AgentBay client
const agentBay = new AgentBay({ apiKey: "your_api_key" });

// Create or get a persistent context
const contextResult = await agentBay.context.get("my-browser-context", true);
const context = contextResult.context;

// Create browser session with context
const browserContext: BrowserContext = {
    contextId: context.id,
    autoUpload: true
};

const params = new CreateSessionParams()
    .withImageId("browser-image-id")
    .withBrowserContext(browserContext);

const sessionResult = await agentBay.create(params);
const session = sessionResult.session;
```

### Cookie Persistence Example

```typescript
import { AgentBay, CreateSessionParams, BrowserContext, BrowserOption } from 'wuying-agentbay-sdk';
import { chromium } from 'playwright';

// Initialize AgentBay
const agentBay = new AgentBay({ apiKey: "your_api_key" });

// Create persistent context
const contextResult = await agentBay.context.get("cookie-demo-context", true);
const context = contextResult.context;

// First session - set cookies
const browserContext: BrowserContext = {
    contextId: context.id,
    autoUpload: true
};

const params = new CreateSessionParams()
    .withImageId("browser-image-id")
    .withBrowserContext(browserContext);

const session1 = (await agentBay.create(params)).session;

// Set cookies in first session
await session1.browser.initializeAsync(new BrowserOption());
const endpointUrl = session1.browser.getEndpointUrl();

const browser = await chromium.connectOverCDP(endpointUrl);
const contextP = browser.contexts()[0] || await browser.newContext();
const page = await contextP.newPage();

// Navigate and set cookies
await page.goto("https://example.com");
await contextP.addCookies([
    {
        name: "session_cookie",
        value: "session_value",
        domain: "example.com",
        path: "/",
    }
]);

await browser.close();

// Delete first session with context sync
await agentBay.delete(session1, true);

// Second session - verify cookies persist
const session2 = (await agentBay.create(params)).session;

// Check cookies in second session
await session2.browser.initializeAsync(new BrowserOption());
const endpointUrl2 = session2.browser.getEndpointUrl();

const browser2 = await chromium.connectOverCDP(endpointUrl2);
const contextP2 = browser2.contexts()[0] || await browser2.newContext();

// Verify cookies persist
const cookies = await contextP2.cookies();
console.log(`Persisted cookies: ${JSON.stringify(cookies)}`);

await browser2.close();
```

## Best Practices

1. **Use Descriptive Context Names**: Name your contexts based on their purpose (e.g., "ecommerce-scraping", "social-media-automation")
2. **Enable Auto Upload**: Set `auto_upload=True` to automatically synchronize browser data when sessions end
3. **Clean Up Resources**: Delete sessions when done to free up cloud resources
4. **Handle Errors Gracefully**: Implement proper error handling for context operations
5. **Reuse Contexts**: Reuse the same context across multiple sessions for continuity

## Advanced Features

### Context Synchronization Policies

You can customize how browser data is synchronized:

```python
from agentbay.context_sync import SyncPolicy

# Create custom sync policy
policy = SyncPolicy(
    upload=True,
    extract=True,
    white_list=["/cookies.json", "/storage/"],
    black_list=["/cache/large_files/"]
)

# Use with context sync
context_sync = ContextSync.new(
    context_id=context.id,
    path="/browser-data",
    policy=policy
)
```

### Multiple Contexts

You can use multiple contexts for different purposes:

```python
# Create separate contexts for different websites
ecommerce_context = agent_bay.context.get("ecommerce-site", create=True).context
social_context = agent_bay.context.get("social-media", create=True).context

# Use different contexts for different sessions
ecommerce_session_params = CreateSessionParams(
    browser_context=BrowserContext(ecommerce_context.id, True)
)

social_session_params = CreateSessionParams(
    browser_context=BrowserContext(social_context.id, True)
)
```

## Error Handling

Common errors and how to handle them:

```python
try:
    context_result = agent_bay.context.get("my-context", create=True)
    if not context_result.success:
        print(f"Failed to create context: {context_result.error_message}")
        
    session_result = agent_bay.create(session_params)
    if not session_result.success:
        print(f"Failed to create session: {session_result.error_message}")
        
except Exception as e:
    print(f"An error occurred: {e}")
```

## 📚 Related Guides

- [Extension Management](extension.md) - Browser extension integration
- [Data Persistence](../../common-features/basics/data-persistence.md) - Broader context management
- [Session Management](../../common-features/basics/session-management.md) - Session lifecycle and configuration
- [Browser Use Overview](../README.md) - Complete browser automation features

## 🆘 Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Documentation Home](../../README.md)



# Browser Proxy Configuration Guide

---

## Overview

Browser Proxy is a core feature of the AgentBay SDK that enables developers to route browser traffic through proxy servers. This functionality is essential for scenarios requiring IP rotation, geographical distribution, or network anonymization. The AgentBay SDK supports both custom proxy servers and integrated Wuying Proxy Service.

## Key Features

### 1. Custom Proxy Support
Configure your own proxy servers with full control over routing and authentication:
- **Protocol Support**: HTTP, HTTPS, and SOCKS proxies
- **Authentication**: Optional username and password authentication
- **Flexible Configuration**: Support for various proxy server configurations

### 2. Wuying Proxy Service
Leverage Alibaba Cloud's integrated proxy service with advanced management features:
- **Restricted Strategy**: Uses fixed proxy nodes for consistent IP addresses
- **Polling Strategy**: Rotates through a pool of proxy nodes for IP diversity
- **Managed Infrastructure**: No need to maintain your own proxy servers

## Proxy Types and Strategies

### Custom Proxy
Suitable for users who have their own proxy infrastructure or specific proxy requirements.

**Configuration Options:**
- `type`: Set to `"custom"`
- `server`: Proxy server address (required)
- `username`: Authentication username (optional)
- `password`: Authentication password (optional)

### Wuying Proxy
Provided by the Wuying Proxy Service integrated in AgentBay SDK

**Restricted Strategy:**
- Uses fixed proxy nodes
- Provides stable IP addresses
- The IP remains stable for the lifetime of the session.

**Polling Strategy:**
- Rotates through a pool of proxy nodes
- Provides IP diversity for each request
- Suitable for scenarios requiring frequent IP changes
- Configurable pool size via `pollsize` parameter

## Python Implementation

### Basic Usage

```python
import os
import asyncio
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams
from agentbay.browser.browser import BrowserOption, BrowserProxy
from playwright.async_api import async_playwright

async def proxy_example():
    # Initialize AgentBay client
    api_key = os.getenv("AGENTBAY_API_KEY")
    agent_bay = AgentBay(api_key=api_key)

    # Create session
    params = CreateSessionParams(image_id="browser_latest")
    session_result = agent_bay.create(params)

    if session_result.success:
        session = session_result.session
        print(f"Session created successfully, Session ID: {session.session_id}")

        # Example 1: Custom Proxy Configuration
        # browser_proxy = BrowserProxy(
        #     proxy_type="custom",
        #     server="http://127.0.0.1:9090",
        #     username="username",
        #     password="password"
        # )

        # Example 2: Wuying Proxy - Polling Strategy
        browser_proxy = BrowserProxy(
            proxy_type="wuying",
            strategy="polling",
            pollsize=2
        )

        # Example 3: Wuying Proxy - Restricted Strategy
        # browser_proxy = BrowserProxy(
        #     proxy_type="wuying",
        #     strategy="restricted"
        # )

        # Create browser options with proxy configuration
        browser_option = BrowserOption(
            proxies=[browser_proxy]
        )

        # Initialize browser instance
        if await session.browser.initialize_async(browser_option):
            endpoint_url = session.browser.get_endpoint_url()
            print(f"Browser CDP endpoint: {endpoint_url}")

            # Use Playwright to connect to remote browser instance
            async with async_playwright() as p:
                browser = await p.chromium.connect_over_cdp(endpoint_url)
                context = browser.contexts[0]
                page = await context.new_page()

                # Verify proxy IP
                print("\n--- Starting proxy public IP check ---")
                await page.goto("https://httpbin.org/ip")

                try:
                    response = await page.evaluate("() => JSON.parse(document.body.textContent)")
                    public_ip = response.get("origin", "").strip()
                    print(f"Proxy public IP: {public_ip}")
                except Exception as e:
                    print(f"Failed to get proxy public IP: {e}")

                print("--- Proxy IP check completed ---\n")
                await page.wait_for_timeout(3000)
                await browser.close()

        # Clean up session
        agent_bay.delete(session)

if __name__ == "__main__":
    asyncio.run(proxy_example())
```

## TypeScript Implementation

### Basic Usage

```typescript
import { AgentBay, CreateSessionParams } from 'wuying-agentbay-sdk';
import { BrowserOption, BrowserProxy } from 'wuying-agentbay-sdk';
import { chromium } from 'playwright';

interface IpResponse {
    origin: string;
}

async function proxyExample(): Promise<void> {
    // Initialize AgentBay client
    const apiKey = process.env.AGENTBAY_API_KEY;
    if (!apiKey) {
        console.log('Error: AGENTBAY_API_KEY environment variable not set');
        return;
    }

    try {
        const agentBay = new AgentBay({ apiKey });

        // Create a session
        const params: CreateSessionParams = {
            imageId: 'browser_latest',
        };
        const sessionResult = await agentBay.create(params);

        if (!sessionResult.success) {
            console.log('Failed to create session');
            return;
        }

        const session = sessionResult.session;
        console.log(`Session created with ID: ${session.sessionId}`);

        // Example 1: Custom Proxy Configuration
        // const browserProxy: BrowserProxy = {
        //     type: 'custom',
        //     server: 'http://127.0.0.1:9090',
        //     username: 'username',
        //     password: 'password',
        //     toMap: function() {
        //         return {
        //             type: this.type,
        //             server: this.server,
        //             username: this.username,
        //             password: this.password
        //         };
        //     }
        // };

        // Example 2: Wuying Proxy - Polling Strategy
        const browserProxy: BrowserProxy = {
            type: 'wuying',
            strategy: 'polling',
            pollsize: 2,
            toMap: function() {
                return {
                    type: this.type,
                    strategy: this.strategy,
                    pollsize: this.pollsize
                };
            }
        };

        // Example 3: Wuying Proxy - Restricted Strategy
        // const browserProxy: BrowserProxy = {
        //     type: 'wuying',
        //     strategy: 'restricted',
        //     toMap: function() {
        //         return {
        //             type: this.type,
        //             strategy: this.strategy
        //         };
        //     }
        // };

        // Create browser option with proxy configuration
        const browserOption: BrowserOption = {
            proxies: [browserProxy]
        };

        const initialized = await session.browser.initializeAsync(browserOption);
        if (initialized) {
            const endpointUrl = session.browser.getEndpointUrl();
            console.log('endpoint_url =', endpointUrl);

            const browser = await chromium.connectOverCDP(endpointUrl);
            const context = browser.contexts()[0];
            const page = await context.newPage();

            try {
                // Verify proxy IP
                console.log('\n--- Check proxy public IP start ---');
                await page.goto('https://httpbin.org/ip');

                const response = await page.evaluate((): IpResponse => {
                    return JSON.parse(document.body.textContent || '{}');
                });
                const publicIp = response.origin || '';
                console.log('proxy public IP:', publicIp);
                console.log('--- Check proxy public IP end ---');

                await page.waitForTimeout(3000);
            } finally {
                await browser.close();
            }
        }

        // Clean up session
        await agentBay.delete(session);
    } catch (error) {
        console.error('Error:', error);
    }
}

proxyExample().catch(console.error);
```

## Best Practices

### 1. Proxy Selection Strategy

**Custom Proxy Usage:**
- Use when you have existing proxy infrastructure
- Ideal for specific geographic requirements
- Provides full control over proxy configuration

```python
# ✅ Correct - Custom proxy with authentication
custom_proxy = BrowserProxy(
    proxy_type="custom",
    server="http://proxy.example.com:8080",
    username="your_username",
    password="your_password"
)
```

**Wuying Proxy Usage:**
- Use for managed proxy infrastructure
- Choose strategy based on your use case:
  - **Restricted**: For consistent IP requirements
  - **Polling**: For IP rotation needs

```python
# ✅ Correct - Wuying proxy with appropriate strategy
wuying_proxy = BrowserProxy(
    proxy_type="wuying",
    strategy="polling",
    pollsize=3  # Adjust based on your needs
)
```

### 2. Error Handling and Monitoring

```python
async def robust_proxy_usage():
    try:
        # Initialize browser with proxy
        if await session.browser.initialize_async(browser_option):
            endpoint_url = session.browser.get_endpoint_url()
            
            async with async_playwright() as p:
                browser = await p.chromium.connect_over_cdp(endpoint_url)
                context = browser.contexts[0]
                page = await context.new_page()
                
                # Verify proxy is working
                await page.goto("https://httpbin.org/ip", timeout=30000)
                
                # Check if proxy is applied
                response = await page.evaluate("() => JSON.parse(document.body.textContent)")
                proxy_ip = response.get("origin", "").strip()
                
                if not proxy_ip:
                    raise Exception("Failed to detect proxy IP")
                    
                print(f"Successfully using proxy IP: {proxy_ip}")
                
                await browser.close()
        else:
            print("Browser initialization failed - check proxy configuration")
            
    except Exception as e:
        print(f"Proxy configuration error: {e}")
        # Implement fallback logic or retry mechanism
```

## Limitations
- **Single Proxy Support**: Although BrowserOption accepts an array in proxies, only the first proxy is currently applied per session.
- **Global Proxy Scope**: The proxy applies globally, meaning all browser requests will be routed through the proxy

## 📚 Related Guides

- [Browser Context](browser-context.md) - Browser context management for cookies and sessions
- [Stealth Mode](stealth-mode.md) - Anti-detection techniques for web automation
- [Browser Use Overview](../README.md) - Complete browser automation features
- [Session Management](../../common-features/basics/session-management.md) - Session lifecycle and configuration

## 🆘 Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Documentation Home](../../README.md)




# Call For User

The Call For User feature handles scenarios where browser automation encounters situations that require human intervention. This includes authentication challenges, complex verification processes, or security measures that cannot be automatically resolved by the system.

> **Use Cases:** This feature is triggered when the browser encounters user information requests, authentication challenges, or other scenarios that require manual human interaction to proceed.

## When Call For User is Triggered

The system automatically triggers a "wuying-call-for-user" message when it encounters:

- **Authentication challenges** that cannot be automatically resolved
- **Complex verification processes** that need user input
- **Security measures** that require manual verification
- **User information requests** that need human intervention
- **Situations** where automated solutions are insufficient

## Event Monitoring

Monitor Call For User events through console messages to implement custom handling logic:

```python
def handle_console(msg):
    print(f"🔍 Received console message: {msg.text}")
    # Parse JSON message
    try:
        message_data = json.loads(msg.text)
        message_type = message_data.get('type', '')
    except (json.JSONDecodeError, AttributeError):
        # If not JSON, treat as plain text
        message_type = msg.text

    if message_type == "wuying-call-for-user":
        # Open browser for user interaction
        import webbrowser
        webbrowser.open(info.resource_url)
        # Wait for user to complete interaction
        time.sleep(20)

page.on("console", handle_console)
```

## Handling User Intervention

When a Call For User event is triggered, the recommended flow is:

1. **Parse the console message** to identify the message type
2. **Open the session resource URL** in a browser for user interaction
3. **Allow the user to interact** with the browser to complete the required action
4. **Wait for completion** (typically 20-30 seconds)
5. **Continue with automation** flow

## Configuration

The Call For User feature works automatically with any browser session. No special configuration is required:

```python
params = CreateSessionParams(
    image_id="browser_latest",  # Specify the image ID
)
session_result = agent_bay.create(params)

if session_result.success:
    session = session_result.session
    print(f"Session created with ID: {session.session_id}")

    # Get session info to access resource URL
    result = session.info()
    info = result.data
    print(f"session resource url is {info.resource_url}")

    # Call For User is automatically enabled
    if await session.browser.initialize_async(BrowserOption()):
        print("Browser initialized successfully")
```

## Usage Tips

- **Monitor console events** to detect when user intervention is needed
- **Implement proper waiting** mechanisms (20-30 seconds) for user interaction
- **Handle URL escaping** for special characters in resource URLs
- **Provide clear feedback** to users about what action is required
- **Plan for user interaction time** in your automation workflows


## 📚 Related Guides

- [CAPTCHA Resolution](captcha.md) - Automatic CAPTCHA handling
- [Session Management](../../common-features/basics/session-management.md) - Session lifecycle and configuration
- [Browser Use Overview](../README.md) - Complete browser automation features

## 🆘 Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Documentation Home](../../README.md)




# CAPTCHA Resolution

CAPTCHA challenges are common obstacles in web automation that can disrupt your workflow. AIBrowser includes an intelligent CAPTCHA resolution system that automatically handles these verification challenges, ensuring your automation tasks proceed smoothly.

> **Version Information:** CAPTCHA resolution is available starting from version 0.7.0. Currently, the system only supports automatic resolution of slider-type CAPTCHAs. Support for text-based CAPTCHAs will be added in future releases.

## Automatic CAPTCHA Resolution

The system works by:
- Detecting CAPTCHA challenges as they appear on web pages
- Processing the challenge using advanced recognition algorithms
- Completing the verification process transparently
- Resolution typically completes within 30 seconds for most CAPTCHA types
- Feature is opt-in and disabled by default for performance optimization

## Event Monitoring

Track CAPTCHA resolution progress through console events. This allows you to implement custom logic while the system handles the verification:

```python
def handle_console(msg):
    if msg.text == "wuying-captcha-solving-started":
        print("CAPTCHA solving started")
    elif msg.text == "wuying-captcha-solving-finished":
        print("CAPTCHA solving finished")

page.on("console", handle_console)
```

## Configuration

Enable CAPTCHA resolution by setting the appropriate flag during browser initialization:

```python
params = CreateSessionParams(
    image_id="browser_latest",  # Specify the image ID
)
session_result = agent_bay.create(params)

session = session_result.session
browser_option = BrowserOption(
    solve_captchas=True,
)
await session.browser.initialize_async(browser_option)
```

## Usage Tips

- Plan for up to 30 seconds processing time per CAPTCHA
- Implement event listeners to track resolution status
- Disable the feature if manual CAPTCHA handling is preferred for your use case

## 📚 Related Guides

- [Stealth Mode](stealth-mode.md) - Anti-detection techniques for web automation
- [Call For User](call-for-user.md) - Human intervention for unsolvable challenges
- [Browser Use Overview](../README.md) - Complete browser automation features
- [Session Management](../../common-features/basics/session-management.md) - Session lifecycle and configuration

## 🆘 Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Documentation Home](../../README.md)




# Browser Extension Management

Browser Extension Management is a core feature of the AgentBay SDK that enables you to upload, manage, and synchronize browser extensions with your browser sessions. This is particularly useful for automated testing of browser extensions, web scraping with custom extensions, and browser automation workflows.

## Overview

The Extension Management feature allows you to:
- Upload browser extensions to the cloud
- Manage multiple extensions in a context
- Automatically synchronize extensions to browser sessions
- Test extension functionality in controlled environments
- Update and maintain extensions across sessions

## Key Concepts

### ExtensionsService

The `ExtensionsService` is the main class for managing browser extensions. It handles:
- Extension storage in cloud contexts
- Extension upload and management
- Extension synchronization to sessions
- Automatic cleanup of resources

### ExtensionOption

The `ExtensionOption` encapsulates extension configuration for browser sessions, including:
- Context ID where extensions are stored
- List of extension IDs to synchronize
- Automatic generation of context sync configurations

### Extension Synchronization

Extensions are automatically synchronized to browser sessions at:
- Path: `/tmp/extensions/{extension_id}/` in each session
- Each extension gets its own directory with all extension files
- Session isolation ensures each session has its own copy

## Python Implementation

### Basic Extension Usage

```python
from agentbay import AgentBay
from agentbay.extension import ExtensionsService
from agentbay.session_params import CreateSessionParams, BrowserContext

# Initialize AgentBay and Extensions Service
agent_bay = AgentBay(api_key="your_api_key")
extensions_service = ExtensionsService(agent_bay)

# Upload your extension
extension = extensions_service.create("/path/to/your-extension.zip")
print(f"Extension uploaded: {extension.name} (ID: {extension.id})")

# Create extension option for browser integration
ext_option = extensions_service.create_extension_option([extension.id])

# Create browser session with extension
session_params = CreateSessionParams(
    labels={"purpose": "extension_testing"},
    browser_context=BrowserContext(
        context_id="extension_test_session",
        extension_option=ext_option
    )
)

# Create session - extension will be automatically synchronized
session_result = agent_bay.create(session_params)
session = session_result.session

# Extensions are now available at /tmp/extensions/ in the session
print("Extension session created successfully!")

# Clean up when done
extensions_service.cleanup()
```

### Working with Multiple Extensions

```python
# Upload multiple extensions
extension_paths = [
    "/path/to/extension1.zip",
    "/path/to/extension2.zip",
    "/path/to/extension3.zip"
]

extension_ids = []
for path in extension_paths:
    ext = extensions_service.create(path)
    extension_ids.append(ext.id)
    print(f"Uploaded: {ext.name}")

# Create session with all extensions
ext_option = extensions_service.create_extension_option(extension_ids)

session_params = CreateSessionParams(
    browser_context=BrowserContext(
        context_id="multi_extension_session",
        extension_option=ext_option
    )
)

session = agent_bay.create(session_params).session

# Extensions are available at /tmp/extensions/{extension_id}/
```

### Extension Development Workflow

```python
class ExtensionDevelopmentWorkflow:
    def __init__(self, api_key: str):
        self.agent_bay = AgentBay(api_key=api_key)
        self.extensions_service = ExtensionsService(self.agent_bay, "dev_extensions")
        self.extension_id = None
    
    def upload_extension(self, extension_path: str) -> str:
        """Upload extension for development testing."""
        extension = self.extensions_service.create(extension_path)
        self.extension_id = extension.id
        print(f"Extension uploaded: {extension.name}")
        return extension.id
    
    def create_test_session(self):
        """Create a browser session for testing."""
        ext_option = self.extensions_service.create_extension_option([self.extension_id])
        
        session_params = CreateSessionParams(
            labels={"purpose": "extension_development"},
            browser_context=BrowserContext(
                context_id="dev_session",
                extension_option=ext_option
            )
        )
        
        return self.agent_bay.create(session_params).session
    
    def update_and_test(self, new_extension_path: str):
        """Update extension and create new test session."""
        # Update existing extension
        updated_ext = self.extensions_service.update(self.extension_id, new_extension_path)
        print(f"Extension updated: {updated_ext.name}")
        
        # Create new test session with updated extension
        return self.create_test_session()
    
    def cleanup(self):
        """Clean up development resources."""
        if self.extension_id:
            self.extensions_service.delete(self.extension_id)
        self.extensions_service.cleanup()

# Usage
workflow = ExtensionDevelopmentWorkflow(api_key="your_api_key")
try:
    # Development cycle
    workflow.upload_extension("/path/to/extension-v1.zip")
    session1 = workflow.create_test_session()
    # Test extension functionality...
    
    # Update and test again
    session2 = workflow.update_and_test("/path/to/extension-v2.zip")
    # Test updated functionality...
    
finally:
    workflow.cleanup()
```

## TypeScript Implementation

### Basic Extension Usage

```typescript
import { AgentBay, ExtensionsService, CreateSessionParams, BrowserContext } from 'wuying-agentbay-sdk';

// Initialize AgentBay and Extensions Service
const agentBay = new AgentBay({ apiKey: "your_api_key" });
const extensionsService = new ExtensionsService(agentBay);

// Upload your extension
const extension = await extensionsService.create("/path/to/your-extension.zip");
console.log(`Extension uploaded: ${extension.name} (ID: ${extension.id})`);

// Create extension option for browser integration
const extOption = extensionsService.createExtensionOption([extension.id]);

// Create browser session with extension
const sessionParams = new CreateSessionParams()
    .withLabels({ purpose: "extension_testing" })
    .withBrowserContext(new BrowserContext(
        "extension_test_session",
        true,
        extOption
    ));

// Create session - extension will be automatically synchronized
const sessionResult = await agentBay.create(sessionParams);
const session = sessionResult.session;

// Extensions are now available at /tmp/extensions/ in the session
console.log("Extension session created successfully!");

// Clean up when done
await extensionsService.cleanup();
```

### Working with Multiple Extensions

```typescript
// Upload multiple extensions
const extensionPaths = [
    "/path/to/extension1.zip",
    "/path/to/extension2.zip",
    "/path/to/extension3.zip"
];

const extensionIds: string[] = [];
for (const path of extensionPaths) {
    const ext = await extensionsService.create(path);
    extensionIds.push(ext.id);
    console.log(`Uploaded: ${ext.name}`);
}

// Create session with all extensions
const extOption = extensionsService.createExtensionOption(extensionIds);

const sessionParams = new CreateSessionParams()
    .withBrowserContext(new BrowserContext(
        "multi_extension_session",
        true,
        extOption
    ));

const session = (await agentBay.create(sessionParams)).session;

// Extensions are available at /tmp/extensions/{extension_id}/
```

## Extension Context Management

The SDK automatically manages extension storage contexts:

### Auto-Generated Contexts

```python
# Auto-generated context (recommended for simple use cases)
extensions_service = ExtensionsService(agent_bay)
# Context name will be automatically generated as "extensions-{timestamp}"
```

### Named Contexts

```python
# Named context (recommended for persistent extension management)
extensions_service = ExtensionsService(agent_bay, "my_project_extensions")
# Context will be created if it doesn't exist
```

## Best Practices

1. **Use Named Contexts**: For persistent extension management, use named contexts instead of auto-generated ones
2. **Clean Up Resources**: Always call `cleanup()` to remove auto-created contexts
3. **Validate Extensions**: Ensure your extensions are properly packaged as ZIP files with manifest.json
4. **Handle Errors**: Implement proper error handling for extension operations
5. **Version Control**: Keep track of extension versions for consistent testing

## Extension Requirements

### File Format
- Extensions must be packaged as ZIP files (.zip)
- Standard browser extension structure with manifest.json
- Manifest V2 or V3 format supported

### File Structure
```
your-extension.zip
├── manifest.json
├── background.js
├── content.js
├── popup.html
├── icons/
│   ├── 16.png
│   ├── 48.png
│   └── 128.png
└── ...
```

### Size Limits
- Check AgentBay documentation for current size limits
- Large extensions may affect session startup time

## Error Handling

Common errors and how to handle them:

```python
try:
    extension = extensions_service.create("/path/to/extension.zip")
except FileNotFoundError:
    print("Extension file not found")
except ValueError as e:
    print(f"Invalid extension format: {e}")
except Exception as e:
    print(f"Failed to upload extension: {e}")
finally:
    extensions_service.cleanup()
```

## Advanced Features

### Extension Updates

```python
# Update an existing extension
updated_extension = extensions_service.update(
    extension_id="ext_1234567890",
    new_local_path="/path/to/updated-extension.zip"
)
```

### Listing Extensions

```python
# List all extensions in the current context
extensions = extensions_service.list()
for ext in extensions:
    print(f"Extension: {ext.name} (ID: {ext.id})")
```

### Deleting Extensions

```python
# Delete a specific extension
success = extensions_service.delete("ext_1234567890")
if success:
    print("Extension deleted successfully")
```

## Integration with Browser Context

Extensions integrate seamlessly with Browser Context for persistent browser environments:

```python
# Create both browser context and extension service
browser_context_result = agent_bay.context.get("persistent-browser", create=True)
browser_context = browser_context_result.context

extensions_service = ExtensionsService(agent_bay, "project-extensions")
extension = extensions_service.create("/path/to/extension.zip")
ext_option = extensions_service.create_extension_option([extension.id])

# Use both in session
session_params = CreateSessionParams(
    browser_context=BrowserContext(
        context_id=browser_context.id,  # Persistent browser state
        auto_upload=True,
        extension_option=ext_option     # Extension integration
    )
)

session = agent_bay.create(session_params).session
# Session has both persistent browser state AND extensions
```

## 📚 Related Guides

- [Browser Context](browser-context.md) - Persistent browser state management
- [Session Management](../../common-features/basics/session-management.md) - Session lifecycle and configuration
- [Browser Use Overview](../README.md) - Complete browser automation features

## 🆘 Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Documentation Home](../../README.md)



# Browser Stealth Mode Guide

**💡 Note: Stealth Mode is designed for legitimate automation scenarios such as testing, research, and authorized data collection. When implementing these features, consider following web standards and best practices to ensure sustainable and respectful interactions with target websites.**

---


## Overview

Stealth Mode is an core feature of the AgentBay SDK, designed to help developers create browser sessions that are harder to detect by anti-bot systems. By simulating various, realistic user browser fingerprints and human-like behavior patterns, Stealth Mode helps your automated tasks behave more like regular browsing rather than script browsing.


## Key Features

### Browser Fingerprint Randomized
Stealth Mode supports to randomize browser fingerprints and can be configured when initializing a browser via AgentBay AIBrowser API. The `BrowserFingerprint` options include:
- **Devices**: Specify desktop or mobile device
- **Operating Systems**: Specify operating systems like windows, macos, linux, ios, android
- **Locales**: Customize browser language and locale settings (e.g. zh-CN, en-US, fr-FR)

When the `use_stealth` and `BrowserFingerprint` option are both set, AgentBay AIBrowser will rotate the browser fingerprints releated to these options.


## Python Implementation

### Basic Usage

```python
import os
import asyncio
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams
from agentbay.browser.browser import BrowserOption, BrowserFingerprint
from playwright.async_api import async_playwright

async def stealth_example():
    # Initialize AgentBay client
    api_key = os.getenv("AGENTBAY_API_KEY")
    agent_bay = AgentBay(api_key=api_key)
    
    # Create session
    params = CreateSessionParams(image_id="browser_latest")
    session_result = agent_bay.create(params)
    
    if session_result.success:
        session = session_result.session
        
        # Configure browser fingerprint
        browser_fingerprint = BrowserFingerprint(
            devices=["desktop"],
            operating_systems=["windows"],
            locales=["zh-CN", "zh", "en-US"]
        )
        
        # Enable stealth mode
        browser_option = BrowserOption(
            use_stealth=True,
            fingerprint=browser_fingerprint
        )
        
        # Initialize browser
        if await session.browser.initialize_async(browser_option):
            endpoint_url = session.browser.get_endpoint_url()
            
            # Connect using Playwright
            async with async_playwright() as p:
                browser = await p.chromium.connect_over_cdp(endpoint_url)
                context = browser.contexts[0]
                page = await context.new_page()
                
                # Verify user agent
                await page.goto("https://httpbin.org/user-agent")
                response = await page.evaluate("() => JSON.parse(document.body.textContent)")
                print(f"User Agent: {response.get('user-agent')}")
                
                # Check navigator properties
                nav_info = await page.evaluate("""
                    () => ({
                        platform: navigator.platform,
                        language: navigator.language,
                        languages: navigator.languages,
                        webdriver: navigator.webdriver
                    })
                """)
                
                print(f"Platform: {nav_info.get('platform')}")
                print(f"Language: {nav_info.get('language')}")
                print(f"WebDriver: {nav_info.get('webdriver')}")
                
                await browser.close()
        
        # Clean up session
        agent_bay.delete(session)

if __name__ == "__main__":
    asyncio.run(stealth_example())
```


## TypeScript Implementation

### Basic Usage

```typescript
import { AgentBay, CreateSessionParams } from 'wuying-agentbay-sdk';
import { BrowserOption, BrowserFingerprint } from 'wuying-agentbay-sdk';
import { chromium } from 'playwright';

async function stealthExample(): Promise<void> {
    // Initialize AgentBay client
    const apiKey = process.env.AGENTBAY_API_KEY;
    const agentBay = new AgentBay({ apiKey });
    
    // Create session
    const params: CreateSessionParams = {
        imageId: "browser_latest"
    };
    const sessionResult = await agentBay.create(params);
    
    if (sessionResult.success && sessionResult.session) {
        const session = sessionResult.session;
        
        // Configure browser fingerprint
        const browserFingerprint: BrowserFingerprint = {
            devices: ["desktop"],
            operatingSystems: ["windows"],
            locales: ["zh-CN", "zh", "en-US"]
        };
        
        // Enable stealth mode
        const browserOption: BrowserOption = {
            useStealth: true,
            fingerprint: browserFingerprint
        };
        
        // Initialize browser
        const initialized = await session.browser.initializeAsync(browserOption);
        if (initialized) {
            const endpointUrl = await session.browser.getEndpointUrl();
            
            // Connect using Playwright
            const browser = await chromium.connectOverCDP(endpointUrl);
            const context = browser.contexts()[0];
            const page = await context.newPage();
            
            // Verify user agent
            await page.goto("https://httpbin.org/user-agent");
            const response = await page.evaluate(() => JSON.parse(document.body.textContent));
            console.log(`User Agent: ${response["user-agent"]}`);
            
            // Check navigator properties
            const navInfo = await page.evaluate(() => ({
                platform: navigator.platform,
                language: navigator.language,
                languages: navigator.languages,
                webdriver: (navigator as any).webdriver
            }));
            
            console.log(`Platform: ${navInfo.platform}`);
            console.log(`Language: ${navInfo.language}`);
            console.log(`WebDriver: ${navInfo.webdriver}`);
            
            await browser.close();
        }
        
        // Clean up session
        await agentBay.delete(session);
    }
}

stealthExample().catch(console.error);
```

## Best Practices

### 1. Browser Context Usage

**💡 Note**: Always use the pre-created browser context provided by AgentBay SDK instead of creating new contexts.

```python
# ✅ Correct - Use the existing context
browser = await p.chromium.connect_over_cdp(endpoint_url)
context = browser.contexts[0]  # Use the default context
page = await context.new_page()
```

```python
# ❌ Incorrect - Creating new context will break stealth features
browser = await p.chromium.connect_over_cdp(endpoint_url)
context = await browser.new_context()
page = await context.new_page()
```

**Why this matters:**
- The AgentBay SDK pre-configures `contexts[0]` with stealth mode settings
- Creating a new context with `new_context()` bypasses these configurations
- This results in reduced anti-bot detection effectiveness and browser fingerprinting may not work properly

### 2. Fingerprint Configuration Strategy

#### User Agent vs Fingerprint Priority
Do not configure `user_agent` and `fingerprint` options simultaneously, as they conflict with each other.
When `user_agent` and `fingerprint` are both specified:
- the fingerprint randomization feature will be disabled
- the browser will use the custom user-agent string

```python
# ✅ Correct - Use fingerprint for automatic rotation
browser_option = BrowserOption(
    use_stealth=True,
    fingerprint=BrowserFingerprint(
        devices=["desktop"],
        operating_systems=["windows"]
    )
    # No user_agent specified - fingerprint rotation will work
)
```

```python
# ❌ Incorrect - user_agent overrides fingerprint rotation
browser_option = BrowserOption(
    use_stealth=True,
    user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64)",
    fingerprint=BrowserFingerprint(
        devices=["desktop"],
        operating_systems=["windows"]
    )  # The fingerprint settings will be ignored
)
```


#### Device Type Selection
- **Desktop Scenario**: Use `["desktop"]` with `["windows", "macos", "linux"]`
- **Mobile Scenario**: Use `["mobile"]` with `["android", "ios"]`
- **Avoid Conflicts**: Don't mix desktop devices with mobile operating systems

```python
# ✅ Correct configuration
desktop_fingerprint = BrowserFingerprint(
    devices=["desktop"],
    operating_systems=["windows", "macos"]
)

# ❌ Incorrect configuration (device and OS mismatch)
wrong_fingerprint = BrowserFingerprint(
    devices=["desktop"],
    operating_systems=["android", "ios"]  # Mobile OS should not pair with desktop devices
)
```

## 📚 Related Guides

- [Browser Proxies](browser-proxies.md) - IP rotation and proxy configuration
- [CAPTCHA Resolution](captcha.md) - Automatic CAPTCHA handling
- [Browser Context](browser-context.md) - Cookie and session management
- [Browser Use Overview](../README.md) - Complete browser automation features

## 🆘 Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Documentation Home](../../README.md)



# AIBrowser Core Features

## Context

- [BrowserContext](core-features/browser-context.md) - Create new or reuse existing browser contexts to speed up web page navigation and reduce anti-bot friction

## Extension

- [Extension Management](core-features/extension.md) - Upload, manage, and synchronize browser extensions with your browser sessions for automated testing and web scraping

## Stealth Mode

- [StealthMode](core-features/stealth-mode.md) - Using stealth-mode to make the browser harder to detect by the anti-bot system

## IPProxy
- [Browser Proxy](core-features/browser-proxies.md) - Configure proxy servers to route browser traffic for IP rotation and geographical distribution

## Captcha Resolving

- [CAPTCHA Resolution](core-features/captcha.md) - Automatically resolve slider-type CAPTCHA challenges to ensure uninterrupted automation workflows

## Call For User

- [Call For User](core-features/call-for-user.md) - Handle scenarios that require human intervention when the browser encounters user information requests or unsolvable problems
## 📚 Related Guides

- [Browser Use Overview](README.md) - Complete browser automation features
- [Advanced Features](advance-features.md) - PageUseAgent and advanced capabilities
- [Code Examples](code-example.md) - Code examples for browser automation

## 🆘 Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Documentation Home](../README.md)




# Integration with community framework/tools/services

## OpenAI CUA

## Crawl4ai
## 📚 Related Guides

- [Browser Use Overview](README.md) - Complete browser automation features
- [Session Management](../common-features/basics/session-management.md) - Session lifecycle and configuration

## 🆘 Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Documentation Home](../README.md)




# CodeSpace Guide

CodeSpace is AgentBay's development environment for code execution and scripting.

## Documentation

- [Code Execution](code-execution.md) - Run code in cloud environments

## Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Main Documentation](../../README.md)




# Code Execution Guide (CodeSpace)

This guide covers code execution capabilities in AgentBay SDK's CodeSpace environment. CodeSpace provides a dedicated development environment optimized for running code in Python and JavaScript.

## 📋 Table of Contents

- [Overview](#overview)
- [CodeSpace Environment](#codespace-environment)
- [Python Code Execution](#python-code-execution)
- [JavaScript Code Execution](#javascript-code-execution)
- [Code Execution with File I/O](#code-execution-with-file-io)
- [Best Practices](#best-practices)

<a id="overview"></a>
## 🎯 Overview

CodeSpace is AgentBay's development-focused environment that provides:

- **Multi-language Support** - Run Python and JavaScript/Node.js code
- **Isolated Execution** - Secure, containerized code execution
- **Development Tools** - Pre-installed interpreters and development utilities
- **File Operations** - Read and write files for script execution

<a id="codespace-environment"></a>
## 🔧 CodeSpace Environment

### Creating a CodeSpace Session

To use code execution features, create a session with the `code_latest` image:

```python
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams

agent_bay = AgentBay(api_key="your-api-key")

session_params = CreateSessionParams(image_id="code_latest")
result = agent_bay.create(session_params)

if result.success:
    session = result.session
    print(f"CodeSpace session created: {session.session_id}")
else:
    print(f"Failed to create session: {result.error_message}")
```

**Important:** The `run_code()` method requires `image_id="code_latest"` when creating the session.

<a id="python-code-execution"></a>
## 🐍 Python Code Execution

### Basic Python Execution

```python
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams

agent_bay = AgentBay(api_key="your-api-key")

session_params = CreateSessionParams(image_id="code_latest")
result = agent_bay.create(session_params)

if result.success:
    session = result.session
    
    code = """
import os
import sys
print(f"Python version: {sys.version}")
print(f"Current directory: {os.getcwd()}")
print("Hello from AgentBay!")
"""
    
    result = session.code.run_code(code, "python")
    if result.success:
        print("Output:", result.result)
        # Output: Python version: 3.11.2 (main, Apr 28 2025, 14:11:48) [GCC 12.2.0]
        #         Current directory: /workspace
        #         Hello from AgentBay!
    else:
        print("Execution failed:", result.error_message)
    
    agent_bay.delete(session)
```

### Python with Calculations

```python
session_params = CreateSessionParams(image_id="code_latest")
result = agent_bay.create(session_params)

if result.success:
    session = result.session
    
    code = """
import math

# Calculate factorial
def factorial(n):
    return math.factorial(n)

# Fibonacci sequence
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

print(f"Factorial of 10: {factorial(10)}")
print(f"Fibonacci of 10: {fibonacci(10)}")

# List comprehension
squares = [x**2 for x in range(1, 11)]
print(f"Squares: {squares}")
"""
    
    result = session.code.run_code(code, "python")
    if result.success:
        print("Output:", result.result)
        # Output: Factorial of 10: 3628800
        #         Fibonacci of 10: 55
        #         Squares: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
    
    agent_bay.delete(session)
```

<a id="javascript-code-execution"></a>
## 🟨 JavaScript Code Execution

### Node.js Code Execution

```python
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams

agent_bay = AgentBay(api_key="your-api-key")

session_params = CreateSessionParams(image_id="code_latest")
result = agent_bay.create(session_params)

if result.success:
    session = result.session
    
    js_code = """
const fs = require('fs');
const path = require('path');

console.log('Node.js version:', process.version);
console.log('Current directory:', process.cwd());

// Create a simple file
fs.writeFileSync('/tmp/hello.txt', 'Hello from Node.js!');
console.log('File created successfully');
"""
    
    result = session.code.run_code(js_code, "javascript")
    if result.success:
        print("Output:", result.result)
        # Output: Node.js version: v18.20.5
        #         Current directory: /workspace
        #         File created successfully
    else:
        print("Execution failed:", result.error_message)
    
    agent_bay.delete(session)
```

### JavaScript with Data Processing

```python
session_params = CreateSessionParams(image_id="code_latest")
result = agent_bay.create(session_params)

if result.success:
    session = result.session
    
    js_code = """
// Array operations
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

const sum = numbers.reduce((a, b) => a + b, 0);
const avg = sum / numbers.length;
const squares = numbers.map(x => x * x);

console.log('Numbers:', numbers);
console.log('Sum:', sum);
console.log('Average:', avg);
console.log('Squares:', squares);

// Object manipulation
const data = {
    name: 'AgentBay',
    version: '1.0',
    features: ['Python', 'JavaScript', 'File I/O']
};

console.log('\\nData:', JSON.stringify(data, null, 2));
"""
    
    result = session.code.run_code(js_code, "javascript")
    if result.success:
        print("Output:", result.result)
        # Output: Numbers: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        #         Sum: 55
        #         Average: 5.5
        #         Squares: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
        #         
        #         Data: {
        #           "name": "AgentBay",
        #           "version": "1.0",
        #           "features": [
        #             "Python",
        #             "JavaScript",
        #             "File I/O"
        #           ]
        #         }
    
    agent_bay.delete(session)
```

<a id="code-execution-with-file-io"></a>
## 📁 Code Execution with File I/O

### Writing and Executing Scripts

```python
from agentbay import AgentBay

agent_bay = AgentBay(api_key="your-api-key")
result = agent_bay.create()

if result.success:
    session = result.session
    
    script_content = """
import json
import sys

data = {
    'message': 'Hello from uploaded script',
    'args': sys.argv[1:] if len(sys.argv) > 1 else []
}

with open('/tmp/output.json', 'w') as f:
    json.dump(data, f, indent=2)

print(json.dumps(data, indent=2))
"""
    
    write_result = session.file_system.write_file("/tmp/script.py", script_content)
    if write_result.success:
        print("Script uploaded successfully")
        
        exec_result = session.command.execute_command("python3 /tmp/script.py arg1 arg2")
        if exec_result.success:
            print("Script output:", exec_result.output)
            # Script output: {
            #   "message": "Hello from uploaded script",
            #   "args": [
            #     "arg1",
            #     "arg2"
            #   ]
            # }
            
            output_result = session.file_system.read_file("/tmp/output.json")
            if output_result.success:
                print("Output file content:", output_result.content)
                # Output file content: {
                #   "message": "Hello from uploaded script",
                #   "args": [
                #     "arg1",
                #     "arg2"
                #   ]
                # }
        else:
            print("Execution failed:", exec_result.error_message)
    else:
        print("Failed to write script:", write_result.error_message)
    
    agent_bay.delete(session)
```

### Multi-file Projects

```python
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams

agent_bay = AgentBay(api_key="your-api-key")

session_params = CreateSessionParams(image_id="code_latest")
result = agent_bay.create(session_params)

if result.success:
    session = result.session
    
    session.file_system.create_directory("/workspace/myproject")
    
    main_py = """
from utils import greet

if __name__ == "__main__":
    print(greet("AgentBay"))
"""
    
    utils_py = """
def greet(name):
    return f"Hello, {name}!"
"""
    
    session.file_system.write_file("/workspace/myproject/main.py", main_py)
    session.file_system.write_file("/workspace/myproject/utils.py", utils_py)
    
    result = session.command.execute_command("cd /workspace/myproject && python3 main.py")
    if result.success:
        print("Project output:", result.output)
        # Project output: Hello, AgentBay!
    else:
        print("Execution failed:", result.error_message)
    
    agent_bay.delete(session)
```

<a id="best-practices"></a>
## 💡 Best Practices

### 1. Use Timeout for Long-Running Code

The default timeout for `run_code()` is 60 seconds. **Note: Due to gateway limitations, each request cannot exceed 60 seconds.**

```python
# Default timeout is 60 seconds
result = session.code.run_code(code, "python")

# You can specify a custom timeout (max 60 seconds)
result = session.code.run_code(code, "python", timeout_s=60)
```

### 2. Use Standard Library Only

CodeSpace comes with Python and Node.js standard libraries pre-installed. For best performance and reliability, use only built-in modules:

**Python**: `os`, `sys`, `json`, `math`, `datetime`, `re`, etc.  
**JavaScript**: `fs`, `path`, `os`, `crypto`, etc.

## 📚 Related Documentation

- [File Operations](../common-features/basics/file-operations.md) - File handling and management
- [Session Management](../common-features/basics/session-management.md) - Session lifecycle and configuration
- [Command Execution](../common-features/basics/command-execution.md) - Shell command execution

## 🆘 Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Documentation Home](../README.md)

Happy coding with AgentBay CodeSpace! 🚀




# Common Features

Common features are core capabilities available across all AgentBay environments (Browser Use, Computer Use, Mobile Use, and CodeSpace).

## Basics

Essential features for working with AgentBay SDK:

- [Session Management](basics/session-management.md) - Create and manage cloud sessions
- [Command Execution](basics/command-execution.md) - Execute shell commands
- [File Operations](basics/file-operations.md) - Upload, download, and manipulate files
- [Data Persistence](basics/data-persistence.md) - Persistent data storage across sessions

## Configuration

SDK configuration and settings:

- [SDK Configuration](configuration/sdk-configuration.md) - API keys, gateway regions, endpoints, and timeouts
- [Logging](configuration/logging.md) - Configure log levels, output, and sensitive data protection

## Advanced

Advanced capabilities for complex use cases:

- [Custom Images](advanced/custom-images.md) - Create tailored environments with specific configurations
- [Session Link Access](advanced/session-link-access.md) - Session connectivity and URL generation
- [VPC Sessions](advanced/vpc-sessions.md) - Isolated network environments
- [Agent Modules](advanced/agent-modules.md) - AI-powered task execution
- [OSS Integration](advanced/oss-integration.md) - Object Storage Service integration

## Use Cases

Practical examples and implementation patterns:

- [Use Cases](use-cases/README.md) - Real-world scenarios and code examples for common tasks

## Environment-Specific Guides

- [Browser Use](../browser-use/README.md) - Web automation
- [Computer Use](../computer-use/README.md) - Desktop automation
- [Mobile Use](../mobile-use/README.md) - Mobile device automation
- [CodeSpace](../codespace/README.md) - Development environment

## Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Main Documentation](../../README.md)




# Advanced Features

Advanced capabilities for complex use cases.

## Documentation

- [Custom Images](custom-images.md) - Create tailored environments with specific configurations
- [Session Link Access](session-link-access.md) - Session connectivity and URL generation
- [VPC Sessions](vpc-sessions.md) - Isolated network environments
- [Agent Modules](agent-modules.md) - AI-powered task execution
- [OSS Integration](oss-integration.md) - Object Storage Service integration

## Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Main Documentation](../../../README.md)




# Agent Modules

## 🤖 Agent Module Overview

Agent modules are specialized AI task execution units
runnning in Agentbay windows environment to execute tasks decribed in natural language. 
The task to be executed can be as simple as "Create a word document, input some words and save the document.", in which only one application is involved, or as complex as "Find out the current weather in New York City by Google/Baidu, and write the weather report to a word document, send the word document to a specific email address", in which multiple applications are involved.

The agent is capable of understanding user instructions, planning task execution steps, operating various applications, and managing files and folders on the computer.

## System Image Support

Agent Module functionality is currently only available on specific system images:

| System Image | Agent Module Support | Available APIs |
|-------------|---------------------|----------------|
| `windows_latest` | ✅ Supported | `execute_task`, `get_task_status`, `terminate_task` |
| `linux_latest` | ❌ Not Supported | - |
| `browser_latest` | ❌ Not Supported | - |
| `code_latest` | ❌ Not Supported | - |
| `mobile_latest` | ❌ Not Supported | - |

**Important:** When using Agent Module features, you must create sessions with `image_id="windows_latest"` to ensure the required MCP tools are available.

## Creating Agent Sessions

```python
from agentbay import AgentBay, CreateSessionParams

agent_bay = AgentBay()

# Create a session for Agent module usage
agent_params = CreateSessionParams(
    image_id="windows_latest",
    labels={"project": "ai-agent"}
)

result = agent_bay.create(agent_params)
if result.success:
    agent_session = result.session
    print(f"Session created with ID: {agent_session.session_id}")
else:
    print(f"Session creation failed: {result.error_message}")
```

## Agent Capabilities
- Office Automation: Word/Excel/PowerPoint automation
- File Operations:Create/Delete/Move/Copy files and folders
- Infomation Processing: 
    - Gather information from webpages
    - Extract information from a web page
    - Fill forms in a web page
- Text Edition: Using notepad to edit(Read/Write/Edit) text file

### Task Execution
```python
# Execute a task using natural language
task_description = "Calculate the square root of 144"
execution_result = agent_session.agent.execute_task(task_description, max_try_times=5)

if execution_result.success:
    print("Task completed successfully!")
    print(f"Task ID: {execution_result.task_id}")
    print(f"Task status: {execution_result.task_status}")
else:
    print(f"Task failed: {execution_result.error_message}")
```

## 📚 Related Resources

- [Session Management Guide](../basics/session-management.md)
- [Data Persistence Guide](../basics/data-persistence.md)
- [VPC Sessions Guide](vpc-sessions.md)

## 🆘 Getting Help

If you encounter issues with Agent modules:

1. Check the [Documentation](../../README.md) for detailed information
2. Search [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues) for similar problems
3. Contact support with detailed error information and reproduction steps
4. Please refer to the [Agent Task Excution Example](../../../../python/docs/examples/common-features/advanced/agent_module/main.py) to see how to use the Agent.
5. Please refer to the [Agent API Definition](../../../../python/docs/api/common-features/advanced/agent.md) for more details.




# Custom Images

Custom images allow you to create tailored environments with specific operating systems, pre-installed software, and configurations that match your business requirements.

## Overview

### What are Custom Images?

Custom images are user-defined environment templates that extend or customize AgentBay's system images or existing custom images. They are ideal for scenarios where:

1. **Production Deployments**: Lock environment versions for production stability to avoid breaking changes from automatic updates
2. **Specialized Software**: Pre-install specific tools, libraries, or applications not included in system images
3. **Team Standardization**: Create standardized environments to ensure all team members use identical development setups
4. **Compliance Requirements**: Configure custom system settings with specific security configurations or compliance-approved software versions
5. **Performance Optimization**: Pre-installing dependencies reduces session startup time

### System Images vs Custom Images

AgentBay provides official **system images** for different use cases:

| Image Type | Use Case | Example |
|------------|----------|---------|
| `linux_latest` | Computer Use | General computing, server tasks |
| `windows_latest` | Computer Use | Windows applications, .NET development |
| `browser_latest` | Browser Use | Web automation, scraping |
| `code_latest` | CodeSpace | Development environments |
| `mobile_latest` | Mobile Use | Android automation |

**Key differences:**

- **System Images**: Maintained by AgentBay, automatically updated to latest versions
- **Custom Images**: Created and maintained by you, version-controlled and stable

### Image ID

The **Image ID** is a unique identifier for each image (both system and custom images). It serves as:

- A credential for SDK and MCP (Model Context Protocol) API calls
- A reference to specify which environment to use when creating sessions

**Example usage:**
```python
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams

agent_bay = AgentBay()

# Use custom image by Image ID
params = CreateSessionParams(image_id="your_custom_image_id")
session = agent_bay.create(params).session

# Your automation tasks here...

agent_bay.delete(session)
```

## Creating Custom Images

There are two primary methods to create custom images:

### 1. AgentBay Console (UI-Based)

The [AgentBay Console](https://agentbay.console.aliyun.com/) provides a user-friendly interface for creating and managing custom images through visual workflows.

**Key features:**
- Interactive image builder with step-by-step guidance
- Visual selection of base images and configurations
- Real-time preview of image specifications
- Easy management of existing custom images

**Supported image types:**
- Computer Use images (Windows/Linux)
- Mobile Use images (Android)

**Note:** Browser Use images are currently not supported for customization.

**To get started:**
Visit the [AgentBay Console](https://agentbay.console.aliyun.com/) and navigate to the Custom Images section to explore the UI-based creation workflow.

### 2. AgentBay CLI (Command-Line)

The AgentBay CLI provides a programmatic approach to create custom images using Dockerfile-based definitions.

**Key features:**
- Dockerfile-based image definitions
- Command-line automation for CI/CD integration
- Version control for image configurations
- Scriptable and repeatable image builds

**Supported image types:**
- CodeSpace images

**Note:** Computer Use and Mobile Use images should use the AgentBay Console for customization.

**To get started:**
Visit the [AgentBay CLI GitHub repository](https://github.com/aliyun/agentbay-cli) for detailed installation instructions.

**Basic workflow:**
```bash
# 1. Log in to AgentBay
agentbay login

# 2. List available user images
agentbay image list

# 3. Create a custom image
agentbay image create myapp --dockerfile ./Dockerfile --imageId code_latest

# 4. Activate the image
agentbay image activate imgc-xxxxx...xxx

# 5. Deactivate when done
agentbay image deactivate imgc-xxxxx...xxx
```

## Production Environment Best Practices

### Version Stability

**⚠️ Important for Production:**

The `xxxx_latest` system images are automatically updated to newer versions, which may introduce:
- API incompatibilities with older SDK versions
- Unexpected behavior changes
- Breaking changes in pre-installed software

**Recommendation:**
- **Always use custom images with fixed versions in production environments**
- Pin specific versions of dependencies in your custom image definitions
- Test custom images thoroughly before deploying to production
- Maintain separate custom images for development, staging, and production

### Example Production Setup

```python
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams

agent_bay = AgentBay()

# Development: Use latest for new features
dev_params = CreateSessionParams(image_id="browser_latest")

# Production: Use version-locked custom image
prod_params = CreateSessionParams(image_id="my_browser_prod_v1.2.0")

# Create production session with stable environment
session = agent_bay.create(prod_params).session
```

## Availability

**Important Notice**: The Custom Images feature is an exclusive premium feature for paid subscription users (Pro/Ultra). For more details about pricing and subscription plans, please visit the [AgentBay Billing Instructions](https://help.aliyun.com/zh/agentbay/product-overview/agentbay-billing-instructions).

## Next Steps

- Explore the [AgentBay Console](https://agentbay.console.aliyun.com/) to create your first custom image
- Check out the [AgentBay CLI](https://github.com/aliyun/agentbay-cli) for automated image creation
- Review [Session Management](../basics/session-management.md) to learn how to use custom images in your workflows
- See [SDK Configuration](../configuration/sdk-configuration.md) for environment-specific settings





# OSS Integration

Object Storage Service (OSS) integration enables file upload and download operations between AgentBay sessions and Alibaba Cloud OSS buckets.

## Overview

The OSS module provides:
- **Authenticated Operations**: Upload/download files using OSS credentials
- **Anonymous Operations**: Upload/download files using presigned URLs
- **Session-scoped**: All OSS operations are executed within a cloud session environment

## Prerequisites

Before using OSS operations, you need:
1. An active AgentBay session (preferably `code_latest` image)
2. Alibaba Cloud OSS credentials (Access Key ID and Secret)
3. An OSS bucket (for authenticated operations)

## Basic Workflow

### 1. Initialize OSS Environment

Before performing any OSS operations, you must initialize the OSS environment with your credentials:

```python
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams

agent_bay = AgentBay(api_key="your-agentbay-api-key")

params = CreateSessionParams(image_id="code_latest")
result = agent_bay.create(params)
session = result.session

init_result = session.oss.env_init(
    access_key_id="your-oss-access-key-id",
    access_key_secret="your-oss-access-key-secret",
    securityToken="optional-security-token",  # Optional: for temporary credentials
    endpoint="https://oss-cn-hangzhou.aliyuncs.com",  # Optional: defaults to OSS endpoint
    region="cn-hangzhou"  # Optional: defaults to OSS region
)

if init_result.success:
    print(f"OSS environment initialized successfully")
    print(f"Request ID: {init_result.request_id}")
else:
    print(f"Failed to initialize OSS: {init_result.error_message}")
```

**Parameters:**
- `access_key_id` (required): Your Alibaba Cloud Access Key ID
- `access_key_secret` (required): Your Alibaba Cloud Access Key Secret
- `securityToken` (optional): Security token for temporary credentials (STS)
- `endpoint` (optional): OSS service endpoint (e.g., `https://oss-cn-hangzhou.aliyuncs.com`)
- `region` (optional): OSS region (e.g., `cn-hangzhou`)

**Returns:**
- `OSSClientResult` with fields:
  - `success` (bool): Whether initialization succeeded
  - `request_id` (str): Unique request identifier
  - `client_config` (dict): OSS client configuration details
  - `error_message` (str): Error description if failed

### 2. Upload Files to OSS

After initialization, upload files from the session to your OSS bucket:

```python
upload_result = session.oss.upload(
    bucket="my-bucket-name",
    object="data/report.pdf",  # Object key in OSS
    path="/home/guest/report.pdf"  # Local path in session
)

if upload_result.success:
    print(f"File uploaded successfully: {upload_result.content}")
    print(f"Request ID: {upload_result.request_id}")
else:
    print(f"Upload failed: {upload_result.error_message}")
```

**Parameters:**
- `bucket` (str): OSS bucket name
- `object` (str): Object key/path in OSS (e.g., `folder/file.txt`)
- `path` (str): Local file path in the session to upload

**Returns:**
- `OSSUploadResult` with fields:
  - `success` (bool): Whether upload succeeded
  - `request_id` (str): Unique request identifier
  - `content` (str): Upload result message
  - `error_message` (str): Error description if failed

### 3. Download Files from OSS

Download files from your OSS bucket to the session:

```python
download_result = session.oss.download(
    bucket="my-bucket-name",
    object="data/report.pdf",  # Object key in OSS
    path="/home/guest/downloaded_report.pdf"  # Local path to save
)

if download_result.success:
    print(f"File downloaded successfully: {download_result.content}")
    print(f"Request ID: {download_result.request_id}")
    
    file_info = session.file_system.get_file_info("/home/guest/downloaded_report.pdf")
    if file_info.success:
        print(f"Downloaded file size: {file_info.size} bytes")
else:
    print(f"Download failed: {download_result.error_message}")
```

**Parameters:**
- `bucket` (str): OSS bucket name
- `object` (str): Object key/path in OSS
- `path` (str): Local file path in the session to save the downloaded file

**Returns:**
- `OSSDownloadResult` with fields:
  - `success` (bool): Whether download succeeded
  - `request_id` (str): Unique request identifier
  - `content` (str): Download result message
  - `error_message` (str): Error description if failed

## Anonymous Operations

Anonymous operations allow uploading/downloading files using presigned URLs or public URLs without requiring OSS credential initialization (`env_init()`).

### Upload Anonymously

Upload a file to a presigned upload URL:

```python
upload_result = session.oss.upload_anonymous(
    url="https://example.com/upload/file.txt",  # Presigned upload URL
    path="/home/guest/file.txt"  # Local file to upload
)

if upload_result.success:
    print(f"Anonymous upload successful: {upload_result.content}")
else:
    print(f"Anonymous upload failed: {upload_result.error_message}")
```

**Parameters:**
- `url` (str): HTTP/HTTPS URL to upload the file to (e.g., presigned OSS upload URL)
- `path` (str): Local file path in the session

**Returns:** Same as `upload()` - `OSSUploadResult`

### Download Anonymously

Download a file from a public URL or presigned download URL:

```python
download_result = session.oss.download_anonymous(
    url="https://example.com/files/document.pdf",  # Public or presigned URL
    path="/home/guest/document.pdf"  # Local path to save
)

if download_result.success:
    print(f"Anonymous download successful: {download_result.content}")
else:
    print(f"Anonymous download failed: {download_result.error_message}")
```

**Parameters:**
- `url` (str): HTTP/HTTPS URL to download the file from
- `path` (str): Local file path in the session to save the downloaded file

**Returns:** Same as `download()` - `OSSDownloadResult`

## Complete Example

Here's a complete workflow demonstrating OSS integration:

```python
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams

agent_bay = AgentBay(api_key="your-agentbay-api-key")

params = CreateSessionParams(image_id="code_latest")
result = agent_bay.create(params)

if not result.success:
    print(f"Failed to create session: {result.error_message}")
    exit(1)

session = result.session

try:
    init_result = session.oss.env_init(
        access_key_id="your-oss-access-key-id",
        access_key_secret="your-oss-access-key-secret",
        endpoint="https://oss-cn-hangzhou.aliyuncs.com",
        region="cn-hangzhou"
    )
    
    if not init_result.success:
        print(f"Failed to initialize OSS: {init_result.error_message}")
        exit(1)
    
    print("✓ OSS environment initialized")
    
    session.file_system.write_file(
        path="/home/guest/data.txt",
        content="Hello from AgentBay!",
        mode="overwrite"
    )
    print("✓ Created local file")
    
    upload_result = session.oss.upload(
        bucket="my-bucket",
        object="agentbay/data.txt",
        path="/home/guest/data.txt"
    )
    
    if upload_result.success:
        print(f"✓ File uploaded to OSS: {upload_result.content}")
    else:
        print(f"✗ Upload failed: {upload_result.error_message}")
    
    download_result = session.oss.download(
        bucket="my-bucket",
        object="agentbay/data.txt",
        path="/home/guest/downloaded_data.txt"
    )
    
    if download_result.success:
        print(f"✓ File downloaded from OSS: {download_result.content}")
        
        content_result = session.file_system.read_file("/home/guest/downloaded_data.txt")
        if content_result.success:
            print(f"✓ File content: {content_result.content}")
    else:
        print(f"✗ Download failed: {download_result.error_message}")

finally:
    agent_bay.delete(session)
    print("✓ Session deleted")
```

## Error Handling

All OSS operations return result objects with `success` field and `error_message` field. Always check these fields:

```python
result = session.oss.upload(bucket="my-bucket", object="file.txt", path="/tmp/file.txt")

if result.success:
    print(f"Success: {result.content}")
else:
    print(f"Error: {result.error_message}")
```

**Common Error Scenarios:**

1. **Authentication Errors**
   ```
   Error: The OSS Access Key Id you provided does not exist in our records.
   ```
   - Solution: Verify your Access Key ID and Secret

2. **Upload/Download Failures**
   - Check error_message field in result object for specific error details
   - Verify bucket name, object key, and file paths
   - Ensure OSS credentials have appropriate permissions
   - For authenticated operations, verify `env_init()` was called successfully

## Use Cases

### 1. Data Backup

Upload session data to OSS for long-term storage:

```python
import time

session.file_system.create_directory("/home/guest/backup")

json_data = '{"key": "value"}'
session.file_system.write_file("/home/guest/backup/data.json", json_data, "overwrite")

timestamp = int(time.time())
upload_result = session.oss.upload(
    bucket="backup-bucket",
    object=f"backups/{timestamp}/data.json",
    path="/home/guest/backup/data.json"
)
```

### 2. Data Processing

Download data from OSS, process it, and upload results:

```python
session.oss.download(
    bucket="input-bucket",
    object="raw/data.csv",
    path="/home/guest/input.csv"
)

result = session.code.run_code(
    language="python",
    code="""
with open('/home/guest/input.csv', 'r') as f:
    lines = f.readlines()
    
processed_lines = [line.upper() for line in lines]

with open('/home/guest/output.csv', 'w') as f:
    f.writelines(processed_lines)
"""
)

session.oss.upload(
    bucket="output-bucket",
    object="processed/data.csv",
    path="/home/guest/output.csv"
)
```

### 3. File Distribution

Use anonymous download to access public files:

```python
download_result = session.oss.download_anonymous(
    url="https://public-bucket.oss-cn-hangzhou.aliyuncs.com/dataset.zip",
    path="/home/guest/dataset.zip"
)

session.command.execute_command("unzip /home/guest/dataset.zip -d /home/guest/data/")
```

## Best Practices

1. **Always Initialize First**: Call `env_init()` before any other OSS operations
2. **Handle Errors**: Check `success` field and handle `error_message` appropriately
3. **Use Absolute Paths**: Use absolute paths for file operations (e.g., `/home/guest/file.txt`)
4. **Secure Credentials**: Never hardcode credentials; use environment variables
5. **Clean Up**: Delete sessions after completing OSS operations to avoid charges
6. **Request IDs**: Log `request_id` from results for debugging and support

## Security Considerations

- **Credential Management**: Store OSS credentials securely (environment variables, secrets manager)
- **Temporary Credentials**: Use STS temporary credentials with `securityToken` when possible
- **Bucket Permissions**: Grant minimal required permissions to OSS Access Keys
- **Network Security**: Use HTTPS endpoints for OSS operations
- **Session Cleanup**: Always delete sessions containing sensitive data

## Limitations

1. **Session Requirement**: OSS operations require an active session
2. **Initialization Required**: `env_init()` must be called before upload/download operations
3. **Path Restrictions**: File paths must be within the session filesystem
4. **Image Compatibility**: Works best with `code_latest` image

## Related Documentation

- [Session Management](../basics/session-management.md)
- [File Operations](../basics/file-operations.md)
- [Data Persistence](../basics/data-persistence.md)
- [Command Execution](../basics/command-execution.md)




# Session Link Access

This guide shows you how to use `get_link()` to connect to your AgentBay cloud sessions.

> **⚠️ Important Notice**: The Session Link feature is an exclusive premium feature for paid subscription users (Pro/Ultra). For more details about pricing and subscription plans, please visit the [AgentBay Billing Instructions](https://help.aliyun.com/zh/agentbay/product-overview/agentbay-billing-instructions).

## 📋 Table of Contents

- [🎯 What is a Session Link?](#what-is-a-session-link)
- [🚀 Use Cases and Examples](#use-cases-and-examples)
- [📖 API Reference](#api-reference)
- [📖 Advanced Topics](#advanced-topics)

---

<a id="what-is-a-session-link"></a>
## 🎯 What is a Session Link?

### Simple Explanation

When you create an AgentBay session, you're starting a virtual computer in the cloud. If you need to **directly connect** external tools (like Playwright, your local browser, or WebSocket clients) to services running inside the session, you'll need a **Session Link**.

Think of it this way:
- 🏠 **Session** = A house in the cloud running services
- 🔗 **Session Link** = The direct address to access those services
- 💻 **Your local tools** = Need this address to connect to services inside

Session Link provides the **direct network access URL** to services in your cloud session.

### What Can `get_link()` Do?

The `get_link()` method returns a URL that enables **direct connections** to services in your session:

1. ✅ **Control a cloud browser** with Playwright/Puppeteer (browser automation via CDP)
2. ✅ **Access web applications** running in your session (like dev servers on custom ports)
3. ✅ **Connect to custom services** in the cloud (like WebSocket servers, databases)

---

<a id="use-cases-and-examples"></a>
## 🚀 Use Cases and Examples

For practical examples and step-by-step guides, see the **[Session Link Use Cases](../use-cases/session-link-use-cases.md)** document, which covers:

1. **Browser Automation** - Control cloud browsers with Playwright/Puppeteer
2. **Access Web Applications** - Access web services running in cloud sessions
3. **Connect to Custom Services** - Connect to custom ports and services

The use cases document includes:
- Complete working code examples
- Quick selection guide to choose the right approach
- Common mistakes and how to avoid them

---

<a id="api-reference"></a>
## 📖 API Reference

### Method Signature

```python
def get_link(
    protocol_type: Optional[str] = None,
    port: Optional[int] = None
) -> Result[str]
```

### Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `protocol_type` | `str` | No | Protocol type: `"https"` or `"wss"`. If not specified, defaults to WSS for browser CDP endpoint |
| `port` | `int` | No | Port number in range [30100, 30199] for custom services |

### Return Value

Returns a `Result[str]` object containing:
- `success`: Boolean indicating if the operation succeeded
- `data`: The session link URL (wss:// or https://)
- `error_message`: Error description if `success` is False
- `request_id`: Unique identifier for the API request


### Usage Patterns

The `get_link()` method supports three main usage patterns:

| Pattern | Call Syntax | Returns | Use Case |
|---------|-------------|---------|----------|
| Browser CDP | `get_link()` | `wss://...` | Browser automation with Playwright/Puppeteer |
| HTTPS Service | `get_link("https", port)` | `https://...` | Access web applications via HTTPS |
| WebSocket Service | `get_link(port=port)` | `wss://...` | Connect to custom WebSocket services |

> **📘 For detailed examples and complete code**, see the [Session Link Use Cases Guide](../use-cases/session-link-use-cases.md).

### Quick Reference

**Browser Automation**:
```python
# MUST initialize browser first!
await session.browser.initialize_async(BrowserOption())
await asyncio.sleep(10)  # Wait for browser startup

link = session.get_link()  # Returns CDP endpoint
```

**Web Application Access**:
```python
link = session.get_link(protocol_type="https", port=30150)
# Returns: https://gateway.../request_ai/.../path/
```

**Custom Service Connection**:
```python
link = session.get_link(port=30180)
# Returns: wss://gateway.../websocket_ai/...
```

### Parameter Constraints

- **Port Range**: Must be in [30100, 30199]
- **Protocol Types**: Only `"https"` and `"wss"` are supported
- **Browser CDP**: Requires Browser Use image (e.g., `browser_latest`)
- **Protocol + Port**: If `protocol_type` is specified, `port` must also be provided

### Common Errors

| Error | Cause | Solution |
|-------|-------|----------|
| "port is not valid" | `protocol_type` specified without `port` | Always provide `port` when using `protocol_type` |
| "Port must be in [30100, 30199]" | Port outside valid range | Use a port in the valid range |
| "http not supported" | Using `protocol_type="http"` | Use `"https"` instead |
| "only BrowserUse image support cdp" | Non-browser image with no parameters | Use `browser_latest` image or specify port |

---

<a id="advanced-topics"></a>
## 📖 Advanced Topics

### Asynchronous Operations

For async applications, use `get_link_async()`:

```python
import asyncio
import os
from agentbay import AgentBay

async def get_multiple_links():
    api_key = os.environ.get("AGENTBAY_API_KEY")
    agent_bay = AgentBay(api_key=api_key)
    session = agent_bay.create().session
    
    try:
        # Get multiple links in parallel
        tasks = [
            session.get_link_async(),  # Default WebSocket
            session.get_link_async(protocol_type="https", port=30199),  # HTTPS
            session.get_link_async(port=30150)  # WebSocket with port
        ]
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        for i, result in enumerate(results):
            if isinstance(result, Exception):
                print(f"Link {i+1} failed: {result}")
            elif result.success:
                print(f"Link {i+1}: {result.data}")
    finally:
        agent_bay.delete(session)

if __name__ == "__main__":
    asyncio.run(get_multiple_links())
```

### Best Practices

#### 1. Parameter Validation

```python
def safe_get_link(session, protocol_type=None, port=None):
    """Safely get session link with validation"""
    if protocol_type is not None and port is None:
        raise ValueError("protocol_type requires port parameter")
    
    if port is not None and not (30100 <= port <= 30199):
        raise ValueError(f"Port {port} outside valid range [30100, 30199]")
    
    return session.get_link(protocol_type=protocol_type, port=port)
```

#### 2. Error Handling

```python
def robust_get_link(session, protocol_type=None, port=None):
    """Get link with comprehensive error handling"""
    try:
        result = session.get_link(protocol_type=protocol_type, port=port)
        
        if result.success:
            print(f"Link: {result.data}")
            print(f"Request ID: {result.request_id}")
            return result.data
        else:
            print(f"API error: {result.error_message}")
            return None
    
    except Exception as e:
        print(f"Exception: {e}")
        return None
```

#### 3. Link Caching

```python
class SessionLinkManager:
    """Cache links to avoid repeated API calls"""
    
    def __init__(self, session):
        self.session = session
        self.cache = {}
    
    def get_cached_link(self, protocol_type=None, port=None):
        key = f"{protocol_type}:{port}"
        
        if key not in self.cache:
            result = self.session.get_link(
                protocol_type=protocol_type, 
                port=port
            )
            if result.success:
                self.cache[key] = result.data
        
        return self.cache.get(key)
```

### Troubleshooting

#### Link Not Accessible

If the link is generated successfully but you cannot access it:

```python
# Check 1: Verify the service is running on the specified port
result = session.command.execute_command("netstat -tuln | grep 30150")
if result.success:
    print(f"Port status: {result.output}")
else:
    print("Service may not be running on the specified port")

# Check 2: Verify the session is still active
info_result = session.info()
if info_result.success:
    print(f"Session ID: {info_result.data.session_id}")
    print(f"Session status: Active")
else:
    print(f"Session may have been terminated: {info_result.error_message}")
```

#### Connection Timeouts

If connections to the link time out:

```python
# Check 1: Verify network connectivity to the gateway domain
# Extract domain from link for testing
link_result = session.get_link(protocol_type="https", port=30150)
if link_result.success:
    import urllib.parse
    parsed = urllib.parse.urlparse(link_result.data)
    print(f"Gateway domain: {parsed.netloc}")
    # Test connectivity: ping or curl the domain

# Check 2: Confirm the session hasn't been terminated
info_result = session.info()
if not info_result.success:
    print("Session may have been terminated")
    print("Create a new session and try again")

# Check 3: Review VPC and subnet configurations (for VPC sessions)
# If using VPC mode, ensure:
# - Security groups allow traffic on the specified port
# - Network ACLs permit inbound/outbound connections
# - Route tables are correctly configured
```

### Debugging Helper Function

When troubleshooting link issues, use this comprehensive debugging function.

**Note**: This is a helper function example, not a built-in SDK method. Copy the complete function code below into your script to use it.

#### How to Use

1. **Copy the entire function definition** from the code block below
2. **Paste it into your Python script** before calling it
3. **Call the function** with your session object: `debug_session_links(session)`

#### Function Code

```python
def debug_session_links(session):
    """Debug session link generation and accessibility."""
    print(f"Debugging session: {session.session_id}")
    print("=" * 70)
    
    # Step 1: Get session info
    print("\n[Step 1] Checking session status...")
    info_result = session.info()
    if info_result.success:
        info = info_result.data
        print(f"✅ Session ID: {info.session_id}")
        print(f"✅ Resource Type: {info.resource_type}")
        print(f"✅ Resource ID: {info.resource_id}")
        print(f"✅ Resource URL: {info.resource_url[:100]}...")
    else:
        print(f"❌ Failed to get session info: {info_result.error_message}")
        return
    
    # Step 2: Test different link types
    print("\n[Step 2] Testing different link configurations...")
    test_cases = [
        ("Default WebSocket", None, None),
        ("WebSocket with port 30150", None, 30150),
        ("HTTPS on port 30199", "https", 30199),
        ("WebSocket Secure on port 30199", "wss", 30199),
    ]
    
    for name, protocol, port in test_cases:
        try:
            if protocol is None and port is None:
                result = session.get_link()
            elif protocol is None:
                result = session.get_link(port=port)
            else:
                result = session.get_link(protocol_type=protocol, port=port)
            
            if result.success:
                url_preview = result.data[:80] + "..." if len(result.data) > 80 else result.data
                print(f"✅ {name}: {url_preview}")
            else:
                print(f"❌ {name}: {result.error_message}")
        
        except Exception as e:
            print(f"❌ {name}: Exception - {e}")
    
    print("\n" + "=" * 70)
    print("Debugging complete!")
```

#### Usage Example

After copying the function definition above, you can use it like this:

```python
import os
from agentbay import AgentBay

# (Paste the debug_session_links function definition here)

# Now use the function
api_key = os.environ.get("AGENTBAY_API_KEY")
agent_bay = AgentBay(api_key=api_key)
session = agent_bay.create().session

# Call the debugging function
debug_session_links(session)

# Cleanup
agent_bay.delete(session)
```

**Expected Output**:
```
Debugging session: session-abc123
======================================================================

[Step 1] Checking session status...
✅ Session ID: session-abc123
✅ Resource Type: container
✅ Resource ID: res-abc123
✅ Resource URL: wss://gateway.../websocket_ai/...

[Step 2] Testing different link configurations...
❌ Default WebSocket: no port specified, cdp default, but only BrowserUse image support cdp
✅ WebSocket with port 30150: wss://gateway.../websocket_ai/...
✅ HTTPS on port 30199: https://gateway.../request_ai/.../path/
✅ WebSocket Secure on port 30199: wss://gateway.../websocket_ai/...

======================================================================
Debugging complete!
```

### Link Format Details

#### WebSocket Secure (wss://)

```
wss://gw-cn-hangzhou-ai-linux.wuyinggw.com:8008/websocket_ai/{token}
 │    │                                        │     │              │
 │    └─ Gateway domain                        │     └─ Endpoint    └─ Auth token
 │                                             └─ Gateway port
 └─ Protocol (WebSocket Secure)
```

**Use**: Chrome DevTools Protocol (CDP) endpoint for browser automation, or WebSocket services with custom ports

#### HTTPS

```
https://gw-cn-hangzhou-ai-linux.wuyinggw.com:8008/request_ai/{token}/path/
 │     │                                        │     │           │        │
 │     └─ Gateway domain                        │     └─ Endpoint └─ Token └─ Path suffix
 │                                             └─ Gateway port
 └─ Protocol (HTTPS)
```

**Use**: HTTP/HTTPS access to web applications and services running in the session

---

## Related Resources

- [Session Management Guide](../basics/session-management.md)
- [Advanced Features Guide](README.md)

## Getting Help

If you encounter issues:

1. Check this documentation for solutions
2. Search [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
3. Contact support with detailed error information

Remember: Session Link Access is your gateway to cloud session connectivity! 🔗




# VPC Sessions

## Overview

VPC (Virtual Private Cloud) sessions provide a secure communication mechanism where the SDK directly connects to cloud environments within the same VPC after session creation. This ensures that all business data bypasses AgentBay's control plane services, delivering enhanced security for customers.

### Key Security Benefits

- **Direct Communication**: After session creation, the SDK establishes direct connections to cloud environments within the same VPC
- **Data Privacy**: All business data and operations are transmitted directly between SDK and cloud environment, without passing through AgentBay control services
- **Network Isolation**: Complete network isolation through VPC boundaries ensures secure execution of sensitive workloads
- **Compliance Ready**: Meets enterprise security requirements for data sovereignty and regulatory compliance

## How It Works

1. **Session Creation**: When creating a session with `is_vpc=True`, AgentBay provisions a cloud environment within your VPC
2. **Direct Communication**: All operations (file operations, command execution, browser automation, etc.) communicate directly with the VPC environment
3. **Control Plane Bypass**: Business data never traverses AgentBay's control plane, ensuring maximum data privacy

## Creating VPC Sessions

```python
from agentbay import AgentBay, CreateSessionParams

agent_bay = AgentBay(api_key=api_key)

# Create VPC session
vpc_params = CreateSessionParams(is_vpc=True)

result = agent_bay.create(vpc_params)
if result.success:
    vpc_session = result.session
    print(f"VPC session created successfully: {vpc_session.session_id}")
else:
    print(f"VPC session creation failed: {result.error_message}")
agent_bay.delete(vpc_session)
```

## VPC Session Configuration

VPC sessions are created by setting the `is_vpc` parameter to `True` in the `CreateSessionParams`. The actual VPC configuration (VPC ID, subnet ID, security groups, etc.) is managed by the AgentBay platform and does not need to be specified in the SDK.

## Related Resources

- [Session Management Guide](../basics/session-management.md)
- [SDK Configuration](../configuration/sdk-configuration.md)

## 📚 Related Guides

- [Session Management](../basics/session-management.md) - Session lifecycle and configuration
- [Session Link Access](session-link-access.md) - Session connectivity and URL generation
- [Data Persistence](../basics/data-persistence.md) - Persistent data storage

## 🆘 Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Documentation Home](../../README.md)




# Basic Features

Fundamental capabilities for working with AgentBay SDK.

## Documentation

- [Session Management](session-management.md) - Create and manage cloud sessions
- [Command Execution](command-execution.md) - Execute shell commands and scripts
- [File Operations](file-operations.md) - Upload, download, and manipulate files
- [Data Persistence](data-persistence.md) - Persistent data storage across sessions

## Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Main Documentation](../../../README.md)




# Command Execution Guide

This guide covers command execution capabilities in AgentBay SDK. The command module allows you to execute shell commands and system operations in cloud sessions.

## 📋 Table of Contents

- [Overview](#overview)
- [Basic Command Execution](#basic-command-execution)
- [Command with Timeout](#command-with-timeout)
- [Working with Command Output](#working-with-command-output)
- [Advanced Patterns](#advanced-patterns)

<a id="overview"></a>
## 🎯 Overview

The `session.command` module provides programmatic access to execute shell commands in cloud sessions. This is useful for:

- **System Operations** - Run shell commands, manage processes
- **Environment Setup** - Install packages, configure environments
- **File Processing** - Use command-line tools for file operations
- **Automation** - Automate complex workflows

### Command Module Features

- ✅ Synchronous command execution
- ✅ Timeout support
- ✅ Output and error capture
- ✅ Exit code handling

<a id="basic-command-execution"></a>
## 💻 Basic Command Execution

### Simple Commands

```python
from agentbay import AgentBay

agent_bay = AgentBay(api_key="your-api-key")
result = agent_bay.create()

if result.success:
    session = result.session
    
    cmd_result = session.command.execute_command("ls -la /tmp")
    if cmd_result.success:
        print("Output:", cmd_result.output)
    else:
        print("Command failed:", cmd_result.error_message)
    
    agent_bay.delete(session)
else:
    print("Failed to create session:", result.error_message)

# Output example:
# Output: total 140
# drwxrwxrwt 21 root   root    4096 Oct  2 14:57 .
# drwxr-xr-x 19 root   root    4096 Oct  2 14:20 ..
# -rw-------  1 root   root       0 Oct  2 14:20 example.lock
# srwxr-xr-x  1 root   root       0 Oct  2 14:20 service.sock
# ...
```

### Command with Arguments

```python
session = agent_bay.create().session

commands = [
    "echo 'Hello from cloud'",
    "pwd",
    "whoami",
    "uname -a"
]

for cmd in commands:
    result = session.command.execute_command(cmd)
    if result.success:
        print(f"{cmd} -> {result.output.strip()}")
    else:
        print(f"{cmd} failed: {result.error_message}")

agent_bay.delete(session)

# Output example:
# echo 'Hello from cloud' -> Hello from cloud
# pwd -> /home/user
# whoami -> user
# uname -a -> Linux hostname 5.15.0-125-generic #135-Ubuntu SMP x86_64 x86_64 x86_64 GNU/Linux
```

<a id="command-with-timeout"></a>
## ⏱️ Command with Timeout

### Setting Execution Timeout

```python
session = agent_bay.create().session

# Command completes within timeout
result = session.command.execute_command("sleep 3", timeout_ms=5000)
if result.success:
    print("Command completed within timeout")
else:
    print("Command timed out or failed:", result.error_message)

# Command exceeds timeout
result = session.command.execute_command("sleep 10", timeout_ms=2000)
if result.success:
    print("Command completed")
else:
    print("Command timed out:", result.error_message)

agent_bay.delete(session)

# Output example:
# Command completed within timeout
# Command timed out: Error in response: Execution failed. Error code:-1 Error message: [timeout]
```

<a id="working-with-command-output"></a>
## 📤 Working with Command Output

### Capturing Output

```python
session = agent_bay.create().session

result = session.command.execute_command("df -h")
if result.success:
    print("Full output:")
    print(result.output)
    
    lines = result.output.strip().split('\n')
    print(f"Found {len(lines)} filesystems")
else:
    print("Command failed:", result.error_message)

agent_bay.delete(session)

# Output example:
# Full output:
# Filesystem      Size  Used Avail Use% Mounted on
# tmpfs           756M  2.9M  753M   1% /run
# /dev/vda3        99G   23G   72G  24% /
# tmpfs           3.7G     0  3.7G   0% /dev/shm
# tmpfs           5.0M     0  5.0M   0% /run/lock
# ...
# Found 8 filesystems
```

<a id="advanced-patterns"></a>
## 🔧 Advanced Patterns

### Command Chaining

```python
session = agent_bay.create().session

result = session.command.execute_command(
    "mkdir -p /tmp/test && cd /tmp/test && echo 'Hello' > file.txt && cat file.txt"
)
if result.success:
    print("Output:", result.output)

agent_bay.delete(session)

# Output example:
# Output: Hello
```

## 📚 Related Documentation

- [Code Execution (CodeSpace)](../../codespace/code-execution.md) - Python, JavaScript code execution
- [File Operations](file-operations.md) - File handling and management
- [Session Management](session-management.md) - Session lifecycle

## 🆘 Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Documentation Home](../README.md)

Happy automating with AgentBay! 🚀




# Complete Data Persistence Guide

This guide covers AgentBay SDK's data persistence features, including context concepts, context management, and data synchronization strategies for maintaining state across sessions.

## 📋 Table of Contents

- [Core Concepts](#core-concepts)
- [Context Management](#context-management)
- [Data Synchronization Strategies](#data-synchronization-strategies)

<a id="core-concepts"></a>
## 🎯 Core Concepts

### Understanding Context - A Simple Example

Before diving into complex features, let's understand what Context and ContextId represent with the simplest possible example:

```python
from agentbay import AgentBay

# Initialize client
agent_bay = AgentBay()

# Create a context - think of it as a "named storage box"
context_result = agent_bay.context.get("my-storage-box", create=True)
context = context_result.context

print(f"Context Name: {context.name}")        # Output: "my-storage-box"
print(f"Context ID: {context.id}")           # Output: "SdkCtx-123abc456def" (unique identifier)
```

**What is a Context?**
- A **Context** is like a persistent storage container that survives beyond individual sessions
- The **Context Name** (like "my-storage-box") is what you use to reference it
- The **Context ID** (like "SdkCtx-123abc456def") is the system's unique identifier for that storage container

**What is a ContextId?**
- Every Context has a unique ID assigned by the system
- You use this ID to mount the context's data into sessions
- Think of it as the "address" where your persistent data lives

### The Persistence Problem

In AgentBay, **sessions are temporary** - when a session ends, all its data disappears:

```python
# Without Context: Data is LOST when session ends
session1 = agent_bay.create().session
session1.file_system.write_file("/tmp/data.txt", "Important data")
agent_bay.delete(session1)
# Session ends -> data.txt is GONE forever!

# With Context: Data is SAVED permanently
from agentbay import ContextSync, CreateSessionParams

context = agent_bay.context.get("my-storage", create=True).context
context_sync = ContextSync.new(context.id, "/tmp/persistent")  # Mount context at /tmp/persistent

session2 = agent_bay.create(CreateSessionParams(context_syncs=[context_sync])).session
session2.file_system.write_file("/tmp/persistent/data.txt", "Important data")
agent_bay.delete(session2, sync_context=True)  # Ensure data syncs before continuing

# Later, in a new session, you can access the same data:
session3 = agent_bay.create(CreateSessionParams(context_syncs=[context_sync])).session
content = session3.file_system.read_file("/tmp/persistent/data.txt")
print(content.content)  # Output: "Important data"
agent_bay.delete(session3)
```

### Implementation Principle - How Context Works Under the Hood

Understanding the technical implementation helps you better use the Context system:

**Context Storage Architecture:**
```
ContextId (e.g., "SdkCtx-123abc456def")
    ↓
OSS Directory (/contexts/SdkCtx-123abc456def/)
    ├── file1.txt
    ├── data/
    │   └── config.json
    └── logs/
        └── app.log
```

**What happens when you create a Context:**
1. **OSS Directory Creation**: AgentBay creates a dedicated OSS (Object Storage Service) directory
2. **Unique Mapping**: Each ContextId maps to a specific OSS path like `/contexts/{SdkCtx-123abc456def}/`
3. **Persistent Storage**: All files in this OSS directory persist beyond session lifecycles

**What happens when you bind Context to Session:**
```python
# This line tells the session: "Download OSS files to /tmp/persistent"
context_sync = ContextSync.new(context.id, "/tmp/persistent")
session = agent_bay.create(CreateSessionParams(context_syncs=[context_sync])).session
```

**Session Lifecycle with Context:**
1. **Session Start**: Downloads all files from OSS directory to `/tmp/persistent`
2. **Session Runtime**: You work with files in `/tmp/persistent` as normal local files  
3. **Session End**: Uploads all changes from `/tmp/persistent` back to OSS directory

**Visual Flow:**
```
OSS Storage          Session Environment          OSS Storage After Upload
┌─────────────┐      ┌──────────────────┐      ┌──────────────────┐
│             │ ───► │ /tmp/persistent/ │ ───► │                  │
│ SdkCtx-123/ │      │   ├── file1      │      │ SdkCtx-123/      │
│ ├── file1   │      │   ├── data       │      │ ├── file1        │
│ └── data    │      │   └── output.log │      │ ├── data         │
└─────────────┘      │   (new file)     │      │ └── output.log   │
   Download          └──────────────────┘      └──────────────────┘
   on Start                                       Upload on End
```

**What this diagram shows:**
- **Left**: Initial OSS directory with existing files (`file1`, `data`) 
- **Middle**: Session workspace with downloaded files + new files you create (`output.log`)
- **Right**: Final OSS directory with ALL changes uploaded back (modified/original files + new files)

**Key Benefits of this Architecture:**
- **Scalability**: OSS handles large files and directories efficiently
- **Reliability**: Cloud storage ensures data durability and availability
- **Performance**: Local file operations during session for fast I/O
- **Sharing**: Multiple sessions can mount the same OSS directory

### Context vs Session

| Feature | Session | Context |
|---------|---------|---------|
| Lifecycle | Temporary, destroyed when session ends | Persistent, destroyed only when manually deleted |
| Data Storage | Not saved | Permanently saved in OSS |
| Sharing | Independent, not shared | Can be shared across multiple sessions |
| Use Case | Execute temporary tasks | Store project data, configurations, etc. |
| Implementation | Local filesystem only | OSS directory + local filesystem sync |

<a id="context-management"></a>
## 📦 Context Management

### Creating and Getting Contexts

```python
from agentbay import AgentBay

# Initialize AgentBay client (requires valid API key)
#api_key from your os env
agent_bay = AgentBay(api_key=api_key)

 # Initialize AgentBay client (requires valid API key)
agent_bay = AgentBay()

# Get or create context
context_result = agent_bay.context.get("my-project", create=True)
if context_result.success:
    context = context_result.context
    print(f"Context ID: {context.id}")
    print(f"Context Name: {context.name}")
    print(f"Created At: {context.created_at}")
else:
    print(f"Context operation failed: {context_result.success}")

# Get existing context only
existing_context_result = agent_bay.context.get("my-project", create=False)
if not existing_context_result.success:
    print("Context does not exist")
else:
context = existing_context_result.context
print(f"Found context: {context.name}")
```


### Listing and Deleting Contexts

```python
# List all contexts
contexts_result = agent_bay.context.list()
if contexts_result.success:
    for context in contexts_result.contexts:
        print(f"Context: {context.name} (ID: {context.id})")
else:
    print(f"Failed to list contexts: {contexts_result.error_message}")

# Delete context
context_to_delete = agent_bay.context.get("my-project", create=False).context
if context_to_delete:
    delete_result = agent_bay.context.delete(context_to_delete)
    if delete_result.success:
        print("Context deleted successfully")
    else:
        print(f"Failed to delete context: {delete_result.error_message}")
```

### Context with Sessions

```python
from agentbay import ContextSync, CreateSessionParams

# Create context
context_result = agent_bay.context.get("my-project", create=True)
if context_result.success:
    context = context_result.context
    print(f"Context ID: {context.id}")

    # Create context sync configuration
    context_sync = ContextSync.new(
        context_id=context.id,
        path="/tmp/data"  # Mount path in session
    )

    # === Session 1: Write data ===
    print("\n--- Session 1: Writing data ---")
    params = CreateSessionParams(context_syncs=[context_sync])
    session1_result = agent_bay.create(params)
    
    if session1_result.success:
        session1 = session1_result.session
        print(f"Session 1 ID: {session1.session_id}")

        # Write files to persistent storage
        session1.file_system.write_file("/tmp/data/config.json", '{"version": "1.0", "app": "demo"}')
        session1.file_system.write_file("/tmp/data/user_data.txt", "User preferences and settings")
        print("Data written to /tmp/data/")
        
        # End session1 and ensure data is fully synced to Context
        agent_bay.delete(session1, sync_context=True)
        print("Session 1 ended - data fully synced to Context")
    else:
        print(f"Failed to create session 1: {session1_result.error_message}")

    # === Session 2: Read persisted data ===
    print("\n--- Session 2: Reading persisted data ---")
    session2_result = agent_bay.create(params)
    
    if session2_result.success:
        session2 = session2_result.session
        print(f"Session 2 ID: {session2.session_id}")

        # Read data that was persisted from session1
        config_result = session2.file_system.read_file("/tmp/data/config.json")
        user_data_result = session2.file_system.read_file("/tmp/data/user_data.txt")
        
        if config_result.success and user_data_result.success:
            print(f"✅ Config data: {config_result.content}")
            print(f"✅ User data: {user_data_result.content}")
            print("🎉 Data successfully persisted across sessions!")
        else:
            print("❌ Failed to read persisted data")
            
        # Clean up
        agent_bay.delete(session2)
        print("Session 2 ended")
    else:
        print(f"Failed to create session 2: {session2_result.error_message}")
else:
    print(f"Failed to create context: {context_result.error_message}")
```

### 🔍 Important: Session Deletion and Sync Timing

**The `sync_context` parameter is crucial for reliable persistence:**

```python
# ❌ Potential race condition - may return before upload completes
agent_bay.delete(session)

# ✅ Guaranteed sync - waits for upload completion  
agent_bay.delete(session, sync_context=True)
```

**Why this matters:**

1. **Asynchronous Upload**: When a session ends, file upload to OSS happens asynchronously
2. **Race Condition**: `delete()` returns immediately, but upload may still be in progress
3. **Data Consistency**: Creating a new session too quickly might not see the latest data

**When to use `sync_context=True`:**
- When you need to immediately create another session to access the data
- In automated workflows where timing is critical
- When data consistency across sessions is essential

**Technical Details:**
- `sync_context=True` triggers upload and polls until completion
- The SDK waits for OSS upload confirmation before returning
- This ensures the next session will definitely see all persisted data

**⚠️ Auto-upload Timeout Limitation:**

Even with auto-upload enabled in the sync policy, the backend enforces a **1-minute timeout** for automatic uploads when a session ends. This can cause issues with:

- **Large file counts**: Many files may not finish uploading within 60 seconds
- **Large file sizes**: Big files may not complete upload before timeout
- **Network latency**: Slow connections may trigger timeout

**Best Practice to Prevent Data Loss:**

```python
# Option 1: Manual sync before session ends (recommended for large datasets)
session.file_system.write_file("/tmp/data/large_file.bin", large_content)
sync_result = session.context.sync()  # Explicit sync with no timeout limit
if sync_result.success:
    print("✅ Data fully synced")
agent_bay.delete(session)  # Safe to delete now

# Option 2: Use sync_context=True on delete (recommended for standard workflows)
session.file_system.write_file("/tmp/data/config.json", config_data)
agent_bay.delete(session, sync_context=True)  # Ensures complete sync before deletion
```

**Key Differences:**

| Method | Timeout Limit | Best For | Notes |
|--------|---------------|----------|-------|
| Auto-upload only | 1 minute | Small files, quick operations | May fail silently for large datasets |
| `session.context.sync()` | None | Large files, many files | Full control, no timeout constraint |
| `delete(sync_context=True)` | None | Standard workflows | Convenient, guaranteed completion |

**Recommendation:** Always use either manual `sync()` or `delete(sync_context=True)` to ensure data persistence, especially when working with large files or multiple files.

<a id="data-synchronization-strategies"></a>

## 🔄 Data Synchronization Strategies

### Sync Policies

#### Default Synchronization Behavior

By default, AgentBay uses **automatic synchronization** when you don't specify a custom policy:

```python
from agentbay import ContextSync, CreateSessionParams

# Default behavior - no policy specified
context_sync = ContextSync.new(context.id, "/tmp/data")  # Uses default policy
session = agent_bay.create(CreateSessionParams(context_syncs=[context_sync])).session

# Equivalent to:
default_policy = SyncPolicy.default()
context_sync = ContextSync.new(context.id, "/tmp/data", default_policy)
```

**Default policy characteristics:**
- **Auto-download**: Context data is automatically downloaded when session starts
- **Auto-upload**: Local changes are automatically uploaded when session ends
- **Service-controlled intervals**: The sync timing is managed by the AgentBay service

#### When to Use Custom Sync Policies

You should consider custom sync policies in these scenarios:

1. **Manual control**: When you need precise control over when data is synced (use manual sync policy)
2. **Unidirectional sync**: When you only need upload or download (use upload-only or download-only policies)
3. **Large datasets**: When working with large files that don't need immediate sync
4. **Large file synchronization**: When you need to sync large quantities of files, compression mode can significantly reduce sync time and storage costs (use Archive upload mode)


**Note:** Selective file synchronization based on patterns is currently not supported. Use the default policy to sync all files, or organize files into separate contexts.

#### Available Sync Policy Options

```python
from agentbay import SyncPolicy, UploadPolicy, DownloadPolicy, BWList, WhiteList

# 1. Default policy - syncs all files
default_policy = SyncPolicy(
    upload_policy=UploadPolicy(auto_upload=True),
    download_policy=DownloadPolicy(auto_download=True)
)

# 2. Manual sync - sync only when explicitly requested
manual_policy = SyncPolicy(
    upload_policy=UploadPolicy(auto_upload=False),
    download_policy=DownloadPolicy(auto_download=False)
)

# 3. Upload-only policy (for write-heavy workflows)
upload_only_policy = SyncPolicy(
    upload_policy=UploadPolicy(auto_upload=True),
    download_policy=DownloadPolicy(auto_download=False)
)

# 4. Download-only policy (for read-heavy workflows)
download_only_policy = SyncPolicy(
    upload_policy=UploadPolicy(auto_upload=False),
    download_policy=DownloadPolicy(auto_download=True)
)
```


#### Compression Mode Configuration

AgentBay SDK provides file compression capabilities to optimize storage space and transfer performance during context synchronization. This is particularly beneficial when working with large text files, source code, or other compressible content.

**Upload Mode Options:**

| Mode | Description | Best For | Compression |
|------|-------------|----------|-------------|
| `UploadMode.FILE` | Default mode - files uploaded as-is | Small files | None |
| `UploadMode.ARCHIVE` | Files compressed before upload | Large text files, source code, logs | Yes |

**When to Use Archive Mode:**

1. **Large text-based files**: Source code, configuration files, logs, documentation
2. **Multiple small files**: Many small files benefit from compression and bundling
3. **Bandwidth optimization**: Slow network connections or limited bandwidth
4. **Storage cost reduction**: Minimize OSS storage usage for compressible content

**Basic Usage:**

```python
from agentbay import AgentBay, CreateSessionParams
from agentbay.context_sync import ContextSync, SyncPolicy, UploadPolicy, UploadMode
import asyncio

# Initialize AgentBay client
agent_bay = AgentBay(api_key="your-api-key")

# Create context
context_result = agent_bay.context.get("my-project", create=True)
context = context_result.context

# Configure sync policy with Archive upload mode
upload_policy = UploadPolicy(upload_mode=UploadMode.ARCHIVE)  # Enable compression
sync_policy = SyncPolicy(upload_policy=upload_policy)

# Create context sync with compression enabled
context_sync = ContextSync(
    context_id=context.id,
    path="/tmp/data",
    policy=sync_policy
)

# Create session with Archive mode
session_params = CreateSessionParams(
    labels={
        "example": "archive-mode-demo",
        "type": "compression-test",
    },
    context_syncs=[context_sync]
)

session_result = agent_bay.create(session_params)
session = session_result.session

# Files written to /tmp/data will be compressed before upload
session.file_system.write_file("/tmp/data/large-file.txt", large_content, mode="overwrite")
session.file_system.write_file("/tmp/data/config.json", config_data, mode="overwrite")

# Perform context sync before getting info (async operation)
async def run_sync():
    return await session.context.sync()

sync_result = asyncio.run(run_sync())
if sync_result.success:
    print("Context sync successful!")
    
    # Get context status information after sync
    info_result = session.context.info()
    if info_result.success:
        print(f"Context status data count: {len(info_result.context_status_data)}")
        for status in info_result.context_status_data:
            print(f"Context ID: {status.context_id}, Path: {status.path}, Status: {status.status}")

    # List files in context sync directory
    list_result = agent_bay.context.list_files(context.id, "/tmp/data", page_number=1, page_size=10)
    if list_result.success:
        print(f"Total files found: {len(list_result.entries)}")
        for entry in list_result.entries:
            print(f"File: {entry.file_name}, Size: {entry.size} bytes, Type: {entry.file_type}")

# Clean up with sync to ensure compressed upload completes
agent_bay.delete(session, sync_context=True)
```

####  Data Lifecycle Management (RecyclePolicy)

`RecyclePolicy` controls how long your context data is retained in the cloud before automatic cleanup. This is useful for managing storage costs and automatically removing temporary data.

**Key Concepts:**
- **Default Behavior**: Data is kept **FOREVER** (permanently) if no RecyclePolicy is specified
- **Automatic Cleanup**: Data is automatically deleted after the specified duration
- **Path-Specific**: Apply different lifecycles to different directories
- **No Wildcards**: Paths must be exact - wildcard patterns are not supported for safety

**Available Lifecycle Options:**

| Lifecycle | Duration | Use Case |
|-----------|----------|----------|
| `LIFECYCLE_1DAY` | 1 day | Temporary cache, test data |
| `LIFECYCLE_3DAYS` | 3 days | Short-term work files |
| `LIFECYCLE_5DAYS` | 5 days | Weekly data |
| `LIFECYCLE_10DAYS` | 10 days | Sprint data |
| `LIFECYCLE_15DAYS` | 15 days | Bi-weekly data |
| `LIFECYCLE_30DAYS` | 30 days | Monthly archives |
| `LIFECYCLE_90DAYS` | 90 days | Quarterly data |
| `LIFECYCLE_180DAYS` | 180 days | Semi-annual data |
| `LIFECYCLE_360DAYS` | 360 days | Annual archives |
| `LIFECYCLE_FOREVER` | Permanent | Important data (default) |

**Basic Usage:**

```python
from agentbay.context_sync import RecyclePolicy, Lifecycle, SyncPolicy, ContextSync

# Example 1: Keep data for 1 day
recycle_policy = RecyclePolicy(
    lifecycle=Lifecycle.LIFECYCLE_1DAY,
    paths=[""]  # "" means apply to all paths
)

sync_policy = SyncPolicy(recycle_policy=recycle_policy)
context_sync = ContextSync.new(context.id, "/tmp/cache", sync_policy)

# This creates a RecyclePolicy with:
# - lifecycle: Lifecycle_1Day
# - paths: ['']
```

**Path-Specific Cleanup:**

```python
# Example 2: Different lifespans for different directories
recycle_policy = RecyclePolicy(
    lifecycle=Lifecycle.LIFECYCLE_3DAYS,
    paths=["/tmp/cache", "/tmp/logs"]  # Only these paths
)

# Important: Use exact paths, NOT wildcards like "/tmp/*"
sync_policy = SyncPolicy(recycle_policy=recycle_policy)

# This applies the 3-day lifecycle only to /tmp/cache and /tmp/logs
```

**Important Restrictions:**

```python
# ❌ WRONG: Wildcard patterns are NOT supported
recycle_policy = RecyclePolicy(
    lifecycle=Lifecycle.LIFECYCLE_1DAY,
    paths=["/tmp/*", "/var/*.log"]  # Will raise ValueError
)
# Raises: ValueError: Wildcard patterns are not supported in recycle policy paths.
#         Got: /tmp/*. Please use exact directory paths instead.

# ✅ CORRECT: Use exact directory paths
recycle_policy = RecyclePolicy(
    lifecycle=Lifecycle.LIFECYCLE_1DAY,
    paths=["/tmp/cache", "/var/logs"]  # Exact paths only
)
# Successfully creates RecyclePolicy with exact paths
```

**When to Use RecyclePolicy:**

1. **Temporary Data**: Set short lifecycles (1-3 days) for cache, temp files, or test data
2. **Project Data**: Use medium lifecycles (30-90 days) for project files
3. **Archives**: Use long lifecycles (180-360 days) for important archives
4. **Permanent Data**: Use `LIFECYCLE_FOREVER` (default) for critical data

**Complete Example:**

```python
from agentbay import AgentBay, CreateSessionParams
from agentbay.context_sync import (
    ContextSync, SyncPolicy, RecyclePolicy, Lifecycle,
    UploadPolicy, DownloadPolicy, BWList, WhiteList
)

# Create context
context = agent_bay.context.get("my-project", create=True).context

# Create RecyclePolicy with 5 days lifecycle
recycle_policy = RecyclePolicy(
    lifecycle=Lifecycle.LIFECYCLE_5DAYS,  # Note: No LIFECYCLE_7DAYS, use 5 or 10
    paths=[""]  # Apply to all paths
)

# Create comprehensive SyncPolicy
sync_policy = SyncPolicy(
    upload_policy=UploadPolicy.default(),
    download_policy=DownloadPolicy.default(),
    recycle_policy=recycle_policy  # Add lifecycle management
)

# Create session with lifecycle-managed context
context_sync = ContextSync.new(context.id, "/tmp/data", sync_policy)
session = agent_bay.create(CreateSessionParams(context_syncs=[context_sync])).session

# The session is now configured with RecyclePolicy
# Data uploaded to this context will be automatically deleted after 5 days
```

> **Note**: RecyclePolicy applies from the time data is uploaded to the cloud. The timer starts after the session ends and data is synchronized, not when files are created in the session.

#### Selective Directory Sync

Use `bw_list` (blacklist/whitelist) to control which subdirectories within the context mount point are synced:

```python
from agentbay import BWList, WhiteList

# Example: Sync only /src and /config, exclude /src/node_modules
policy = SyncPolicy(
    upload_policy=UploadPolicy(auto_upload=True),
    download_policy=DownloadPolicy(auto_download=True),
    bw_list=BWList(
        white_lists=[
            WhiteList(
                path="/src",  # No wildcards like *.json or /src/*
                exclude_paths=["/node_modules"]  # Exact path, not patterns like *.log
            ),
            WhiteList(path="/config")
        ]
    )
)

# Mount point: use any directory with write permissions
# In linux_latest image, /home/wuying is recommended
# Whitelisted paths are relative to mount point:
# - "/src" → /home/wuying/src  
# - "/config" → /home/wuying/config
# - "/node_modules" in exclude → /home/wuying/src/node_modules
context_sync = ContextSync.new(context.id, "/home/wuying", policy)
```

**Mount Point Selection:**
- Use any directory where you have write permissions
- In `linux_latest` image: `/home/wuying`, `/tmp`, `/var/tmp` are available
- System directories like `/workspace`, `/opt`, `/usr` typically require elevated privileges

**Path Specifications:**
- `path` in WhiteList is **relative to the context mount point**
- `exclude_paths` are **relative to the whitelist path**
- Example: If mounted at `/home/wuying`, then `path="/src"` refers to `/home/wuying/src`
- Wildcard patterns (e.g., `*.json`, `/data/*`) are not supported



### Manual Synchronization

When using manual sync policies, you need to explicitly call `session.context.sync()` to trigger data synchronization:

```python
from agentbay import SyncPolicy, UploadPolicy, DownloadPolicy

agent_bay = AgentBay()
# Create session with manual sync policy
manual_policy = SyncPolicy(
    upload_policy=UploadPolicy(auto_upload=False),
    download_policy=DownloadPolicy(auto_download=False)
)
context = agent_bay.context.get("my-project", create=True).context

context_sync = ContextSync.new(context.id, "/tmp/data", manual_policy)
session_result = agent_bay.create(CreateSessionParams(context_syncs=[context_sync]))

if session_result.success:
    session = session_result.session

    # Write some data
    session.file_system.write_file("/tmp/data/temp.txt", "Temporary data")

    # Manually trigger sync to save data (synchronous call - returns when sync is complete)
    sync_result = session.context.sync()
    if sync_result.success:
        print("Data synchronized successfully")
    else:
        print(f"Sync failed: {sync_result.success}")

    # Data is now persisted even if session ends
else:
    print(f"Failed to create session: {session_result.error_message}")
```


### Bidirectional Sync

By default, `session.context.sync()` triggers file **upload** (mode="upload"). You can explicitly specify the sync direction:

```python
# Default behavior - upload local changes to OSS (mode="upload" is default)
upload_result = session.context.sync()  # Same as sync(mode="upload")
if upload_result.success:
    print("Local changes uploaded to context")
else:
    print(f"Upload failed: {upload_result.error_message}")

# Explicitly download latest data from OSS to session
download_result = session.context.sync(mode="download")
if download_result.success:
    print("Latest data downloaded from context")
else:
    print(f"Download failed: {download_result.error_message}")

# Explicitly upload local changes to OSS
upload_result = session.context.sync(mode="upload")
if upload_result.success:
    print("Local changes uploaded to context")
else:
    print(f"Upload failed: {upload_result.error_message}")
```

<a id="troubleshooting"></a>
## 🔧 Troubleshooting

### Issue 1: Permission Denied When Creating Files

**Error Message:**
```
Permission denied
Failed to create directory: /workspace, error: Permission denied
```

**Cause:** Mount point directory lacks write permissions for the current user.

**Solution:**
```python
# ❌ Wrong: Using directory without write permission
context_sync = ContextSync.new(context.id, "/workspace", policy)
context_sync = ContextSync.new(context.id, "/opt/myapp", policy)

# ✅ Correct: Use directory with write permission
context_sync = ContextSync.new(context.id, "/home/wuying", policy)
context_sync = ContextSync.new(context.id, "/tmp/myapp", policy)
```

**Available directories in `linux_latest` image:** `/home/wuying`, `/tmp`, `/var/tmp`

### Issue 2: Files Not Persisted (WhiteList Path Error)

**Symptom:** Files created in session are not found in the next session, even though sync completed.

**Cause:** WhiteList paths are treated as absolute instead of relative to mount point.

**Example of the error:**
```python
# ❌ Wrong: This looks for /home/wuying/home/wuying/src (doesn't exist)
policy = SyncPolicy(
    bw_list=BWList(
        white_lists=[WhiteList(path="/home/wuying/src")]
    )
)
context_sync = ContextSync.new(context.id, "/home/wuying", policy)
```

**Solution:**
```python
# ✅ Correct: Paths are relative to mount point
policy = SyncPolicy(
    bw_list=BWList(
        white_lists=[WhiteList(path="/src")]  # → /home/wuying/src
    )
)
context_sync = ContextSync.new(context.id, "/home/wuying", policy)
```

### Issue 3: Wildcard Patterns Not Supported

**Symptom:** Files are not persisted even though sync completes successfully. No error is reported.

**Cause:** Using wildcard patterns (`*`, `**`) in WhiteList paths or exclude_paths.

**Example of the error:**
```python
# ❌ Wrong: Wildcards silently fail
policy = SyncPolicy(
    bw_list=BWList(
        white_lists=[
            WhiteList(path="*.json"),           # No files synced
            WhiteList(path="/data/*"),          # No files synced
            WhiteList(path="/logs/**/*.txt"),   # No files synced
            WhiteList(path="/src", exclude_paths=["*.log"])  # No files synced
        ]
    )
)
```

**Solution:**
```python
# ✅ Correct: Use exact directory paths
policy = SyncPolicy(
    bw_list=BWList(
        white_lists=[
            WhiteList(path="/data"),  # Syncs all files in /data
            WhiteList(path="/src", exclude_paths=["/temp"])  # Syncs /src except /src/temp
        ]
    )
)
```

### Issue 4: Data Loss After Session Deletion

**Symptom:** Files written in session are not available in the next session.

**Cause:** Session deleted before sync upload completes.

**Solution:**
```python
# ❌ Wrong: May delete before upload finishes
session.file_system.write_file("/home/wuying/data.txt", "content")
agent_bay.delete(session)

# ✅ Correct: Wait for sync to complete
session.file_system.write_file("/home/wuying/data.txt", "content")
agent_bay.delete(session, sync_context=True)
```

### Issue 5: Understanding RecyclePolicy and Data Retention

**Question:** When will my context data be deleted?

**Answer:**
- **Default**: Data is kept **FOREVER** unless you specify a RecyclePolicy
- **With RecyclePolicy**: Data is automatically deleted after the specified period from upload time
- **Timer Start**: The lifecycle countdown begins when data is uploaded to the cloud (after session ends and sync completes)

**Example:**
```python
# Scenario: Set 1 day lifecycle
recycle_policy = RecyclePolicy(
    lifecycle=Lifecycle.LIFECYCLE_1DAY,
    paths=[""]
)

# Timeline:
# Day 0, 10:00 AM - Session created, files written
# Day 0, 11:00 AM - Session deleted, sync uploads data to cloud
# Day 0, 11:00 AM - Lifecycle timer starts
# Day 1, 11:00 AM - Data automatically deleted (24 hours after upload)
```

**Common Mistakes:**

```python
# ❌ Wrong: Using wildcards in paths
recycle_policy = RecyclePolicy(
    lifecycle=Lifecycle.LIFECYCLE_1DAY,
    paths=["/tmp/*", "/var/*.log"]  # ValueError: wildcards not supported
)

# ✅ Correct: Use exact directory paths
recycle_policy = RecyclePolicy(
    lifecycle=Lifecycle.LIFECYCLE_1DAY,
    paths=["/tmp/cache", "/var/logs"]  # Exact paths only
)
```

**Choosing the Right Lifecycle:**
- **Temporary cache/test data**: `LIFECYCLE_1DAY` or `LIFECYCLE_3DAYS`
- **Development work**: `LIFECYCLE_5DAYS` to `LIFECYCLE_15DAYS`
- **Project archives**: `LIFECYCLE_30DAYS` to `LIFECYCLE_90DAYS`
- **Important data**: `LIFECYCLE_FOREVER` (default)

### Verifying Sync Status

```python
context_info = session.context.info()

if context_info.context_status_data:
    for status in context_info.context_status_data:
        print(f"Context: {status.context_id}")
        print(f"Path: {status.path}")
        print(f"Status: {status.status}")
        if status.error_message:
            print(f"Error: {status.error_message}")
else:
    print("No sync tasks found")
```



## 📚 Related Guides

- [Session Management](session-management.md) - Session lifecycle and configuration
- [File Operations](file-operations.md) - File handling and management
- [OSS Integration](../advanced/oss-integration.md) - Object storage service integration

## 🆘 Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Documentation Home](../README.md)




# Complete Guide to File Operations

This guide provides a complete introduction to file operations in the AgentBay SDK, including basic file operations, directory management, batch operations, permission management, and performance optimization.

## 📋 Table of Contents

- [Basic Concepts](#basic-concepts)
- [API Quick Reference](#api-quick-reference)
- [Basic File Operations](#basic-file-operations)
- [Directory Management](#directory-management)
- [Batch Operations](#batch-operations)
- [File Editing Operations](#file-editing-operations)  
- [File Permissions and Attributes](#file-permissions-and-attributes)
- [File Transfer Operations](#file-transfer-operations)
- [Error Handling](#error-handling)

<a id="basic-concepts"></a>
## 🎯 Basic Concepts

### File System Structure

AgentBay sessions provide complete file system access, supporting different operating systems. Each system image provides a fully functional environment with standard directory structures:

#### Linux Environment (`linux_latest`)
```
/
├── bin -> usr/bin          # Essential command binaries (symlink)
├── boot/                   # Boot loader files
├── dev/                    # Device files
├── etc/                    # System configuration files
├── home/                   # User home directories
│   └── wuying/            # Default user directory
├── lib -> usr/lib         # Essential libraries (symlink)
├── media/                  # Removable media mount points
├── mnt/                    # Mount points (for context synchronization)
├── opt/                    # Optional application packages
├── proc/                   # Process information filesystem
├── root/                   # Root user home directory
├── run/                    # Runtime variable data
├── snap/                   # Snap packages
├── srv/                    # Service data
├── sys/                    # System information filesystem
├── tmp/                    # Temporary files (recommended for testing)
├── usr/                    # User programs and libraries
└── var/                    # Variable data files

Working Directory: /home/wuying
User: wuying
```

#### Windows Environment (`windows_latest`)
```
C:\
├── LogtailData\           # Logging service data
├── PerfLogs\              # Performance monitoring logs
├── Program Files\         # 64-bit application programs
├── Program Files (x86)\   # 32-bit application programs
├── temp\                  # Temporary files (for AgentBay operations)
├── Users\                 # User profile directories
│   └── Administrator\     # Default administrator account
└── Windows\               # Windows system files

Working Directory: C:\Users\Administrator
User: Administrator
```

#### Mobile/Android Environment (`mobile_latest`)
```
/
├── acct/                  # Process accounting
├── apex/                  # Android package extensions
├── bin -> /system/bin     # Binary executables (symlink)
├── cache/                 # System cache
├── config/                # Configuration files
├── data/                  # Application and user data
├── dev/                   # Device files
├── etc -> /system/etc     # System configuration (symlink)
├── metadata/              # Filesystem metadata
├── mnt/                   # Mount points
├── proc/                  # Process information
├── storage/               # External storage access
├── sys/                   # System information
├── system/                # Core Android system
└── vendor/                # Vendor-specific files

Working Directory: /
User: root
```

### Path Conventions

- **Linux/Android**: Use forward slash `/tmp/file.txt`
- **Windows**: Use backslash `C:\temp\file.txt` or forward slash `C:/temp/file.txt`
- **Recommendation**: Prefer absolute paths to avoid ambiguity

<a id="api-quick-reference"></a>
## 🚀 API Quick Reference

### Python
```python
# Create session
session = agent_bay.create().session
 #Create Directory
session.file_system.create_directory("/path/to")
print("✅ Directory created successfully")


# Write text file (UTF-8 text only)
result = session.file_system.write_file("/path/to/file.txt", "Hello, World!")
if result.success:
    print("Text file written successfully")

# Read text file (UTF-8 text only)
result = session.file_system.read_file("/path/to/file.txt")
if result.success:
    content = result.content  # String content
    print(f"File content: {content}")

# List directory
result = session.file_system.list_directory("/path/to")
if result.success:
    entries = result.entries
    for entry in entries:
        print(f"Name: {entry['name']}")

# Get file info
result = session.file_system.get_file_info("/path/to/file.txt")

if result.success:
    info = result.file_info
    print(f"File info: {info}")
agent_bay.delete(session)
```


<a id="basic-file-operations"></a>
## 📝 Basic File Operations

**⚠️ Important: Text Files Only**: The `read_file()` and `write_file()` methods are designed specifically for **text files** (UTF-8 encoded). They cannot handle binary files such as images, executables, archives, or other non-text formats. For binary file operations, use command-line tools through the `session.command` interface or context synchronization features.

**File Size Support**: Both `read_file()` and `write_file()` methods support text files of any size through automatic chunked transfer. You don't need to worry about file size limitations - the SDK handles large text files transparently.

**Supported File Types**:
- ✅ Text files: `.txt`, `.json`, `.py`, `.html`, etc.
- ❌ Binary files: `.jpg`, `.pdf`, `.exe`, `.zip`, etc.

### Reading Files

```python
from agentbay import AgentBay

agent_bay = AgentBay()
session = agent_bay.create().session

# Read text file
result = session.file_system.read_file("/tmp/sample.txt")
if result.success:
    content = result.content
    print(f"File content: {content}")
else:
    print(f"Failed to read file: {result.error_message}")
    
agent_bay.delete(session)
```


### Writing Files

```python
from agentbay import AgentBay

agent_bay = AgentBay()
session = agent_bay.create().session

# Write plain text file
content = "Hello, AgentBay!\nThis is a multi-line text file."
result = session.file_system.write_file("/tmp/hello.txt", content)
if result.success:
    print("Text file written successfully")
else:
    print(f"Failed to write file: {result.error_message}")

# Append to file
result = session.file_system.write_file("/tmp/hello.txt", "\nNew log entry", mode="append")
if result.success:
    print("File appended successfully")
    
agent_bay.delete(session)
```

### Handling Binary Files

Since `read_file()` and `write_file()` only support text files, **use `upload_file()` and `download_file()` APIs for binary file operations**.

For detailed examples and usage, see [File Transfer Operations](#file-transfer-operations) section.


<a id="directory-management"></a>
## 📁 Directory Management

### Creating and moving Directories

```python
from agentbay import AgentBay

agent_bay = AgentBay()
session = agent_bay.create().session

# Create directory
result = session.file_system.create_directory("/tmp/data/my_project")
if result.success:
    print("Directory created successfully")
else:
    print(f"Failed to create directory: {result.error_message}")

# Remove directory with parent directories
result = session.file_system.move_file("/tmp/data", "/tmp/test/")
if result.success:
    print("Directory moved successfully")
#List direction
result = session.file_system.list_directory("/tmp/")
if result.success:
    entries = result.entries
    for entry in entries:
        print(f"Name: {entry['name']}")
agent_bay.delete(session)
```

### Listing Directory Contents

```python
from agentbay import AgentBay

agent_bay = AgentBay()
session = agent_bay.create().session

# List directory contents
result = session.file_system.list_directory("/tmp")
if result.success:
    entries = result.entries
    for entry in entries:
        print(f"Name: {entry['name']}")
        print(f"Is Directory: {entry['isDirectory']}")
        print("---")
else:
    print(f"Failed to list directory: {result.error_message}")
```

### Directory Monitoring

Monitor directories for file changes in real-time:

```python
import os
import time
import threading
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams

# Initialize AgentBay
api_key = os.getenv("AGENTBAY_API_KEY")
agentbay = AgentBay(api_key=api_key)

# Create session
session_params = CreateSessionParams(image_id="linux_latest")
session_result = agentbay.create(session_params)
session = session_result.session

# Define callback function
def on_file_change(events):
    for event in events:
        print(f"{event.event_type}: {event.path} ({event.path_type})")

# Start monitoring
monitor_thread = session.file_system.watch_directory(
    path="/tmp/my_directory",
    callback=on_file_change,
    interval=1.0  # Check every second
)
monitor_thread.start()

# Do your work...
time.sleep(10)

# Stop monitoring
monitor_thread.stop_event.set()
monitor_thread.join()

# Clean up
agentbay.delete(session)
```

#### Event Filtering

```python
def on_file_change(events):
    # Only process file modifications
    for event in events:
        if event.event_type == "modify" and event.path_type == "file":
            print(f"File modified: {event.path}")
        elif event.event_type == "create":
            print(f"File created: {event.path}")
        elif event.event_type == "delete":
            print(f"File deleted: {event.path}")
```

<a id="batch-operations"></a>
## 📦 Batch Operations

### Batch File Operations

```python
from agentbay import AgentBay

agent_bay = AgentBay()
session = agent_bay.create().session

# Batch write files
files_to_write = [
    ("/tmp/file1.txt", "Content of file 1"),
    ("/tmp/file2.txt", "Content of file 2"),
    ("/tmp/file3.txt", "Content of file 3")
]

results = []
for file_path, content in files_to_write:
    result = session.file_system.write_file(file_path, content)
    results.append((file_path, result))

# Check results
for file_path, result in results:
    if result.success:
        print(f"✅ {file_path} written successfully")
    else:
        print(f"❌ {file_path} failed: {result.error_message}")

# Batch read files using read_multiple_files
files_to_read = ["/tmp/file1.txt", "/tmp/file2.txt", "/tmp/file3.txt"]
result = session.file_system.read_multiple_files(files_to_read)

if result.success:
    for file_path, content in result.contents.items():
        print(f"✅ {file_path}: {content[:50]}...")  # First 50 chars
else:
    print(f"❌ Failed to read multiple files: {result.error_message}")
```

### File Search Operations

```python
from agentbay import AgentBay

session = agent_bay.create().session

# Search for files with pattern (partial name matching, NOT wildcards)
result = session.file_system.search_files("/tmp", "systemd")
if result.success:
    print(f"Found {len(result.matches)} files containing 'test':")
    for match in result.matches:
        print(f"  - {match}")
else:
    print(f"Search failed: {result.error_message}")

# Search with exclusion patterns
result = session.file_system.search_files(
    "/tmp",
    "systemd",
    exclude_patterns=["geoclue"]
)
if result.success:
    print(f"Found {len(result.matches)} files containing 'config' (excluding 'backup' and 'temp'):")
    for match in result.matches:
        print(f"  - {match}")
```

#### ⚠️ Important: Search Rules and Limitations

**Pattern Matching Rules:**
- **NOT wildcard-based**: Patterns like `*.txt` or `test*` are NOT supported
- **Partial name matching**: The pattern matches any part of the file/directory name
- **Recursive search**: Searches through all subdirectories from the starting path
- **Case sensitivity**:
  - **Windows**: Case-insensitive matching
  - **Linux/Unix**: Case-sensitive matching

**Examples of Pattern Matching:**

```python
# ✅ CORRECT: Partial name matching
session.file_system.search_files("/tmp", "test")
# Matches: test.txt, my_test_file.py, testing.log, etc.

session.file_system.search_files("/tmp", "config")
# Matches: config.json, app_config.xml, configuration.ini, etc.

# ❌ INCORRECT: Wildcard patterns (NOT supported)
session.file_system.search_files("/tmp", "*.txt")     # Won't work as expected
session.file_system.search_files("/tmp", "test*")     # Won't work as expected
session.file_system.search_files("/tmp", "?.log")     # Won't work as expected
```

**Platform-Specific Behavior:**

```python
# On Windows (case-insensitive)
result = session.file_system.search_files("/tmp", "TEST")
# Matches: TEST.txt, TEST.log, TEST.config, MyTEST.py

# On Linux/Unix (case-sensitive)
result = session.file_system.search_files("/tmp", "TEST")
# Matches only: TEST.config, MyTEST.py (exact case match)
result = session.file_system.search_files("/tmp", "test")
# Matches only: test.txt, my_test.py (exact case match)
```



<a id="file-editing-operations"></a>
## ✏️ File Editing Operations

### Text Find and Replace

```python
from agentbay import AgentBay

agent_bay = AgentBay()
session = agent_bay.create().session

# Create a test file
initial_content = "This is old1 text with old2 content.\nAnother line with old1 data."
result = session.file_system.write_file("/tmp/edit_test.txt", initial_content)

# Edit file with multiple find-replace operations
edits = [
    {"oldText": "old1", "newText": "new1"},
    {"oldText": "old2", "newText": "new2"}
]

result = session.file_system.edit_file("/tmp/edit_test.txt", edits, dry_run=False)
if result.success:
    print("File edited successfully")

    # Verify changes
    read_result = session.file_system.read_file("/tmp/edit_test.txt")
    if read_result.success:
        print(f"Updated content: {read_result.content}")
else:
    print(f"Edit failed: {result.error_message}")
```
### Global Character Replacement
**Note**: Each call to the `edit_file` method will only modify the first matched instance. If you need to globally replace the same string, there are two methods:
```python

from agentbay import AgentBay

agent_bay = AgentBay()
session = agent_bay.create().session

# Create a test file
initial_content = "This is old1 text with old2 content.\nAnother line with old1 data."
result = session.file_system.write_file("/tmp/edit_test.txt", initial_content)

# Method One: Single Call to `edit_file` for Global Replacement
edits = [
    {"oldText": "old1", "newText": "new1"},
    {"oldText": "old1", "newText": "new1"}
]

result = session.file_system.edit_file("/tmp/edit_test.txt", edits, dry_run=False)
if result.success:
    print("File edited successfully")

    # Verify changes
    read_result = session.file_system.read_file("/tmp/edit_test.txt")
    if read_result.success:
        print(f"Updated content: {read_result.content}")
else:
    print(f"Edit failed: {result.error_message}")
# Method Two:Multiple Calls to edit_file for Global Replacement
# Create a test file
result = session.file_system.write_file("/tmp/edit_test.txt", initial_content)

# Edit file with multiple find-replace operations
edits = [
    {"oldText": "old1", "newText": "new1"},
]

result1 = session.file_system.edit_file("/tmp/edit_test.txt", edits, dry_run=False)
result2 = session.file_system.edit_file("/tmp/edit_test.txt", edits, dry_run=False)
if result.success and result2.success:
    print("File edited successfully")

    # Verify changes
    read_result = session.file_system.read_file("/tmp/edit_test.txt")
    if read_result.success:
        print(f"Updated content: {read_result.content}")
else:
    print(f"Edit failed: {result.error_message}")

```

### Dry Run Mode

```python
from agentbay import AgentBay

agent_bay = AgentBay()
session = agent_bay.create().session
    # Create a test file
initial_content = "This is oldText text with newText content.\nAnother line with newText data."
result = session.file_system.write_file("/tmp/test.txt", initial_content)

# Preview changes without applying them
edits = [
    {"oldText": "newText", "newText": "modified"}
]

# Use dry_run=True to preview changes
result = session.file_system.edit_file("/tmp/test.txt", edits, dry_run=True)
if result.success:
    print("Dry run completed - changes would be applied")
    result = session.file_system.read_file("/tmp/test.txt")
    if result.success:
        print(f"Preview content: {result.content}")

    # Apply changes if preview looks good
    actual_result = session.file_system.edit_file("/tmp/test.txt", edits, dry_run=False)
    if actual_result.success:
        print("Changes applied successfully")
        result = session.file_system.read_file("/tmp/test.txt")
        if result.success:
            print(f"updated content: {result.content}")
else:
    print(f"Dry run failed: {result.error_message}")
```

<a id="file-permissions-and-attributes"></a>
## 🔐 File Permissions and Attributes

### Getting File Permissions Info

```python
from agentbay import AgentBay

agent_bay = AgentBay()
session = agent_bay.create().session

# Get file info
result = session.file_system.get_file_info("/tmp/example.txt")
if result.success:
    info = result.file_info
    print(f"Size: {info.get('size', 'N/A')} bytes")
    print(f"Created: {info.get('created', 'N/A')}")
    print(f"Modified: {info.get('modified', 'N/A')}")
    print(f"Is Directory: {info.get('isDirectory', 'N/A')}")
```

<a id="file-transfer-operations"></a>
## 📤📥 File Transfer Operations

AgentBay provides dedicated `upload_file()` and `download_file()` methods for transferring files between your local machine and the cloud environment. These methods support both text and binary files, making them ideal for handling any file type.

### Key Features
- **Universal file support**: Works with both text and binary files
- **Automatic synchronization**: Handles cloud storage synchronization automatically  
- **Progress tracking**: Optional progress callbacks for monitoring large transfers
- **Robust error handling**: Comprehensive error reporting and retry capabilities
- **Flexible timeouts**: Configurable wait times for different use cases

### File Upload

Upload files from your local machine to the cloud environment:

```python
from agentbay import AgentBay

agent_bay = AgentBay()
session = agent_bay.create().session

# Basic file upload
upload_result = session.file_system.upload_file(
    local_path="/path/to/local/file.txt",
    remote_path="/tmp/uploaded_file.txt"
)

if upload_result.success:
    print(f"✅ Upload successful!")
    print(f"   Bytes sent: {upload_result.bytes_sent}")
    print(f"   HTTP status: {upload_result.http_status}")
    print(f"   Remote path: {upload_result.path}")
else:
    print(f"❌ Upload failed: {upload_result.error}")

agent_bay.delete(session)
```

### File Download

Download files from the cloud environment to your local machine:

```python
from agentbay import AgentBay

agent_bay = AgentBay()
session = agent_bay.create().session

# Basic file download
download_result = session.file_system.download_file(
    remote_path="/tmp/cloud_file.txt",
    local_path="/path/to/local/downloaded_file.txt"
)

if download_result.success:
    print(f"✅ Download successful!")
    print(f"   Bytes received: {download_result.bytes_received}")
    print(f"   HTTP status: {download_result.http_status}")
    print(f"   Local path: {download_result.local_path}")
else:
    print(f"❌ Download failed: {download_result.error}")

agent_bay.delete(session)
```

### Binary File Transfer

Unlike `read_file()` and `write_file()`, the transfer methods work seamlessly with binary files:

```python
from agentbay import AgentBay
import os

agent_bay = AgentBay()
session = agent_bay.create().session

# Upload binary files (images, archives, executables, etc.)
binary_files = [
    ("/path/to/image.jpg", "/tmp/uploaded_image.jpg"),
    ("/path/to/data.zip", "/tmp/uploaded_archive.zip")
]

for local_path, remote_path in binary_files:
    if os.path.exists(local_path):
        upload_result = session.file_system.upload_file(
            local_path=local_path,
            remote_path=remote_path
        )
        
        if upload_result.success:
            print(f"✅ {os.path.basename(local_path)}: {upload_result.bytes_sent} bytes")
        else:
            print(f"❌ {os.path.basename(local_path)}: {upload_result.error}")

agent_bay.delete(session)
```

### File Transfer vs. Read/Write Methods

| Feature | `upload_file()` / `download_file()` | `read_file()` / `write_file()` |
|---------|-----------------------------------|------------------------------|
| **File Types** | ✅ Text and Binary | ❌ Text only (UTF-8) |
| **Use Case** | Local ↔ Cloud transfer | Cloud-side text processing |
| **Size Limit** | ✅ No practical limit | ✅ No limit (chunked) |
| **Progress Tracking** | ✅ Available | ❌ Not available |
| **Binary Support** | ✅ Full support | ❌ Not supported |

### When to Use Each Method

**Use `upload_file()` / `download_file()` for:**
- Transferring files between local machine and cloud
- Working with binary files (images, archives, executables)
- Large file transfers with progress monitoring
- Moving files into/out of the cloud environment

**Use `read_file()` / `write_file()` for:**
- Processing text content within the cloud environment
- Reading configuration files for analysis
- Generating reports and logs
- Text manipulation and editing tasks




<a id="error-handling"></a>
## ❌ Error Handling

### Binary File Error Handling

When attempting to read or write binary files with text methods, you'll encounter specific errors. Here are the actual error messages and how to handle them:

```python
from agentbay import AgentBay
import base64

agent_bay = AgentBay()
session = agent_bay.create().session

# ❌ Binary data write will fail with JSON serialization error
try:
    binary_data = b'\x89PNG\r\n\x1a\n'  # PNG header example
    result = session.file_system.write_file("/tmp/image.png", binary_data)
    if not result.success:
        # Actual error: "Failed to call MCP tool write_file: Object of type bytes is not JSON serializable"
        print(f"Binary data write error: {result.error_message}")
        
        # ✅ Use alternative method: base64 encoding
        base64_content = base64.b64encode(binary_data).decode('utf-8')
        session.file_system.write_file("/tmp/binary_b64.txt", base64_content)
        result = session.command.execute_command("base64 -d /tmp/binary_b64.txt > /tmp/image.png")
        if result.success:
            print("✅ Binary file created successfully using base64")
            
except Exception as e:
    print(f"Exception during binary write: {e}")

# ⚠️ Note: Binary file reads may unexpectedly succeed
# Some binary files might be read as text, but the content will be corrupted
try:
    result = session.file_system.read_file("/bin/ls")  # Binary executable
    if result.success:
        print("⚠️ Binary file read succeeded, but content may be corrupted")
        print(f"Content preview: {repr(result.content[:50])}...")
        
        # ✅ Use command-line tools for proper binary handling
        cmd_result = session.command.execute_command("file /bin/ls")
        if cmd_result.success:
            print(f"File type: {cmd_result.output}")
            
except Exception as e:
    print(f"Exception reading binary file: {e}")

# 📁 File not found errors
try:
    result = session.file_system.read_file("/tmp/nonexistent_file.txt")
    if not result.success:
        # Actual error: "Error in response: Execution failed. Error code:-32602 Error message: Failed to get file status: /tmp/nonexistent_file.txt, error: No such file or directory"
        print(f"File not found error: {result.error_message}")
        
except Exception as e:
    print(f"Exception reading non-existent file: {e}")

agent_bay.delete(session)
```

## 📋 API Method Selection Guide

| Use Case | Recommended Method | Notes |
|----------|-------------------|-------|
| Read text file | `read_file()` | **Text files only**, supports any size via chunked transfer |
| Read multiple text files | `read_multiple_files()` | **Text files only**, more efficient than individual reads |
| Write text content | `write_file()` | **Text files only**, supports any size via chunked transfer |
| Upload file (local → cloud) | `upload_file()` | Supports all file types, with progress tracking |
| Download file (cloud → local) | `download_file()` | Supports all file types, with progress tracking |
| Find and replace text | `edit_file()` | **Text files only**, better than read-modify-write |
| Search for files | `search_files()` | Partial name matching, NO wildcards |
| Move/rename files | `move_file()` | Works for both text and binary files |
| Get file metadata | `get_file_info()` | File size, type, timestamps |
| List directory | `list_directory()` | Directory contents |
| Create directories | `create_directory()` | Supports nested creation |
| Monitor directory changes | `watch_directory()` | Real-time file change monitoring with callbacks |

## 📚 Related Resources

- [Session Management Guide](session-management.md)
- [Command Execution Guide](command-execution.md)
- [Data Persistence Guide](data-persistence.md)

## 🆘 Getting Help

If you encounter issues with file operations:

1. Check file paths and permissions
2. Verify available disk space
3. Review error messages for specific details
4. Consult the [Documentation](../README.md) for detailed information
5. Search [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues) for similar problems

Remember: File operations are fundamental to most cloud workflows. Master these concepts to build robust and efficient applications! 🚀




# Session Management Documentation

This document provides comprehensive guidance on using the session management capabilities of the AgentBay SDK across all supported languages.

## Overview

Sessions are the fundamental unit of interaction with the AgentBay cloud environment. Each session represents an isolated cloud environment where you can execute commands, manipulate files, run applications, and perform automation tasks.

The session management system provides:
1. **Session Creation**: Create isolated cloud environments with customizable image types and parameters
2. **Session Information**: Access session details including direct browser URLs and connection credentials
3. **Label Management**: Organize and categorize sessions using descriptive labels
4. **Session Recovery**: Restore session objects using session IDs for continued operations
5. **Session Deletion**: Clean up sessions to free cloud resources

## Getting Started

### Prerequisites

Before running the example programs in this guide, please ensure you have completed the following setup:

**Required Setup (2 minutes):**
1. **SDK Installation & API Key Configuration**: Follow the [Installation and API Key Setup Guide](../../../quickstart/installation.md) to install the AgentBay SDK and configure your API key
2. **SDK Configuration**: Review the [SDK Configuration Guide](../configuration/sdk-configuration.md) for detailed configuration options including environment variables and API gateway selection
3. **Core Concepts**: Review [Core Concepts Guide](../../../quickstart/basic-concepts.md) to understand AgentBay fundamentals including sessions, images, and data persistence

**Quick Verification:**
After setup, verify everything works with this simple test:
```python
import os
from agentbay import AgentBay

api_key = os.getenv("AGENTBAY_API_KEY")
agent_bay = AgentBay(api_key=api_key)
result = agent_bay.create()
if result.success:
    print("✅ Setup successful - ready to use session management!")
    agent_bay.delete(result.session)
else:
    print(f"❌ Setup issue: {result.error_message}")
```

### Creating a Session

Creating a session is the first step in using the AgentBay SDK:

```python
from agentbay import AgentBay

# Initialize the SDK
agent_bay = AgentBay(api_key=api_key)

# Create a session with default parameters
session_result = agent_bay.create()
if session_result.success:
    session = session_result.session
    print(f"Session created with ID: {session.session_id}")
```

## Creating Sessions with Custom Parameters

You can customize sessions by specifying parameters such as [image ID](../../../quickstart/basic-concepts.md#image-types) and [labels](#session-label-management). For production environments, consider using [custom images](../advanced/custom-images.md) with fixed versions:

```python
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams

# Initialize the SDK
agent_bay = AgentBay(api_key="your_api_key")

# Create a session with custom parameters
params = CreateSessionParams(
    image_id="linux_latest",
    labels={"project": "demo", "environment": "testing"}
)
session_result = agent_bay.create(params)
session = session_result.session

if session_result.success:
    session = session_result.session
    print(f"Session created with ID: {session.session_id}")
```



## Session Label Management

Labels help organize and categorize sessions for easier management:

### Setting Session Labels

```python
from agentbay import AgentBay

# Initialize the SDK and create a session
agent_bay = AgentBay(api_key=api_key)
session_result = agent_bay.create()
session = session_result.session

# Set labels
labels = {"project": "demo", "environment": "testing"}
result = session.set_labels(labels)

if result.success:
    print("Labels set successfully")
else:
    print(f"Failed to set labels: {result.error_message}")
```

### Getting Session Labels

```python
from agentbay import AgentBay

# Initialize the SDK and create a session
agent_bay = AgentBay(api_key=api_key)
session_result = agent_bay.create()
session = session_result.session

# Get labels
result = session.get_labels()

if result.success:
    print("Session labels:")
    for key, value in result.data.items():
        print(f"  {key}: {value}")
else:
    print(f"Failed to get labels: {result.error_message}")
```

## Listing Sessions

The `list()` method allows you to query and retrieve session IDs from your AgentBay account. This is useful for managing multiple sessions, monitoring active environments, and organizing your cloud resources.

### Basic Usage

```python
from agentbay import AgentBay

# Initialize the SDK
agent_bay = AgentBay(api_key=api_key)

# List all active sessions
result = agent_bay.list()

if result.success:
    print(f"Found {result.total_count} total sessions")
    print(f"Showing {len(result.session_ids)} session IDs on this page")
    print(f"Request ID: {result.request_id}")

    for session_id in result.session_ids:
        print(f"Session ID: {session_id}")
else:
    print(f"Failed to list sessions: {result.error_message}")

# Output:
# Found 0 total sessions
# Showing 0 session IDs on this page
# Request ID: 6620****-****-****-****-********C2C1
```

### Filtering by Labels

You can filter sessions by labels to find specific environments:

```python
from agentbay import AgentBay

# Initialize the SDK
agent_bay = AgentBay(api_key=api_key)

# List sessions with specific labels
result = agent_bay.list(labels={"project": "demo", "environment": "testing"})

if result.success:
    print(f"Found {len(result.session_ids)} sessions matching the labels")
    for session_id in result.session_ids:
        print(f"Session ID: {session_id}")

# Output (after creating a session with matching labels):
# Found 1 sessions matching the labels
# Session ID: session-**********************sic
```

### Pagination

For accounts with many sessions, use pagination to retrieve results in manageable chunks:

```python
from agentbay import AgentBay

# Initialize the SDK
agent_bay = AgentBay(api_key=api_key)

# Get page 2 with 10 items per page
result = agent_bay.list(labels={"project": "demo"}, page=2, limit=10)

if result.success:
    print(f"Page 2 of results (showing {len(result.session_ids)} sessions)")
    print(f"Total sessions: {result.total_count}")
    print(f"Next page token: {result.next_token}")

# Output (when there are no sessions on page 2):
# Page 2 of results (showing 0 sessions)
# Total sessions: 0
# Next page token: None
```

### Important Notes

**Active Sessions Only:**
- The `list()` method **only returns currently active sessions**
- Sessions that have been deleted or released (either manually via `delete()` or automatically due to timeout) will **not** be included in the results
- To check if a specific session is still active, use the `get()` method or `session.info()` method

**Return Value:**
- The method returns session IDs (strings) rather than full Session objects
- Use `agent_bay.get(session_id)` to retrieve a full Session object if needed

**Key Features:**
- **Flexible Filtering**: List all sessions or filter by any combination of labels
- **Pagination Support**: Use `page` and `limit` parameters for easy pagination
- **Request ID**: All responses include a `request_id` for tracking and debugging
- **Efficient**: Returns only session IDs for better performance

## Getting Session Information

The `info()` method provides detailed information about a session, including direct browser access URLs and SDK integration credentials. This API serves two primary purposes:

1. **Cloud Environment Access**: Get the `resource_url` to directly access the cloud environment in a web browser with real-time video streaming and full mouse/keyboard control
2. **Session Status Validation**: Check if a session is still active and hasn't been released
3. **SDK Integration**: Extract authentication credentials for Web SDK (desktop) and Android SDK (mobile) integration

### Session Information Retrieval

```python
from agentbay import AgentBay

# Initialize the SDK and create a session
agent_bay = AgentBay(api_key=api_key)
session_result = agent_bay.create()
session = session_result.session

# Get session information
info_result = session.info()

if info_result.success:
    info = info_result.data
    print(f"Session ID: {info.session_id}")
    print(f"Resource ID: {info.resource_id}")
    print(f"Resource URL: {info.resource_url}")
    print(f"App ID: {info.app_id}")
    print(f"Resource Type: {info.resource_type}")
    print(f"Request ID: {info_result.request_id}")

    # Authentication info (displayed safely)
    print(f"Auth Code: {info.auth_code[:8]}***{info.auth_code[-8:]}")
    print(f"Connection Properties: {len(info.connection_properties)} chars")
    print(f"Ticket: {info.ticket[:50]}...")

    # The resource_url can be opened in a browser for direct access
    print("\n🌐 Open the resource_url in your browser to access the cloud environment!")
else:
    print(f"Failed to get session info: {info_result.error_message}")
```

### Session Information Field Details

- **session_id**: Unique identifier for the session
- **resource_id**: Cloud resource identifier (e.g., "p-xxxxxxxxx")
- **resource_url**: **Direct browser access URL** - Open this URL in any web browser to access the cloud environment with real-time video stream and full mouse/keyboard control
- **app_id**: Application type identifier
- **resource_type**: Resource classification (typically "AIAgent")
- **auth_code**: Authentication token required for Web SDK and Android SDK integration
- **connection_properties**: JSON configuration for SDK connection settings
- **ticket**: Gateway access ticket containing connection endpoints and tokens for SDK integration

### Session Information Use Cases

For detailed practical examples and use cases of session information, including browser access, Android SDK integration, and session health monitoring, see the [Session Information Use Cases Guide](../use-cases/session-info-use-cases.md).



## Session Release

Sessions consume cloud resources while active. Understanding how sessions are released is crucial for resource management.

### Two Ways to Release Sessions

**1. Manual Release (Recommended)**

Explicitly delete sessions when you're done:

```python
from agentbay import AgentBay

# Initialize the SDK and create a session
agent_bay = AgentBay(api_key=api_key)
session_result = agent_bay.create()
session = session_result.session

# Perform your tasks...

# Release resources immediately
delete_result = agent_bay.delete(session)
if delete_result.success:
    print("Session deleted successfully")
else:
    print(f"Failed to delete session: {delete_result.error_message}")
```

**2. Automatic Timeout Release**

If you don't manually delete a session, it will be automatically released after a configured timeout period:

- **Configuration**: Timeout duration is set in the [AgentBay Console](https://agentbay.console.aliyun.com/)
- **Behavior**: Once the timeout is reached, the session is automatically released
- **Recovery**: After release (manual or automatic), the session cannot be recovered - the session ID becomes invalid

### Important Notes

- Released sessions (either manually or by timeout) will **not** appear in `agent_bay.list()` results
- Once released, all non-persistent data in the session is permanently lost
- Use [Data Persistence](data-persistence.md) to preserve important data across sessions


## Session Recovery

In certain scenarios, you may need to recover a Session object using its session ID. The SDK provides the `get` method to retrieve an existing session.

### Using the get Method

The `get` method is the recommended way to recover a session. It retrieves session information from the cloud and returns a ready-to-use Session object with the API request ID.

```python
from agentbay import AgentBay

# Initialize the SDK
agent_bay = AgentBay(api_key="your_api_key")

# Retrieve session using its ID
session_id = "your_existing_session_id"
get_result = agent_bay.get(session_id)

if get_result.success:
    session = get_result.session
    print(f"Retrieved session: {session.session_id}")
    print(f"Request ID: {get_result.request_id}")
    
    # You can now perform any session operations
    result = session.command.execute_command("echo 'Hello, World!'")
    print(result.output)
else:
    print(f"Failed to get session: {get_result.error_message}")

# Output (when session exists):
# Retrieved session: session-**********************uhi
# Request ID: B27C****-****-****-****-********0366
# Command output: Hello, World!

# Output (when session is deleted or not found):
# Failed to get session: Failed to get session session-**********************uhi: Failed to get session session-**********************uhi: Error: InvalidMcpSession.NotFound code: 400,   Resource [McpSession] is not found. request id: 1C3C****-****-****-****-********AD3F ...
```


### Important Considerations

**Session Recovery Limitations:**

1. **Released Sessions Cannot Be Recovered**: If the session ID corresponds to a cloud environment that has been actually released (either through active deletion via `Session.delete()` or automatic timeout release), it cannot be recovered using the session ID. In such cases, you must:
   - Create a new session
   - Use data persistence (see [Data Persistence Guide](data-persistence.md)) to restore your data

2. **Session Status Validation**: Use the `Session.info()` method to determine if a session has been released. Only active (non-released) sessions can return information through the info interface.

3. **Automatic Release Timeout**: Session automatic release timeout can be configured in the [console page](https://agentbay.console.aliyun.com/).

## Advanced Session Patterns

### Error-Safe Session Creation

Create sessions with comprehensive error handling:

```python
import os
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams

def create_session_safely(image_id="linux_latest"):
    agent_bay = AgentBay(api_key=os.getenv("AGENTBAY_API_KEY"))
    
    params = CreateSessionParams(image_id=image_id) if image_id != "linux_latest" else None
    result = agent_bay.create(params)
    
    if result.success:
        print(f"✅ Session created: {result.session.session_id}")
        return result.session, agent_bay
    else:
        print(f"❌ Failed: {result.error_message}")
        return None, None

session, client = create_session_safely("browser_latest")
if session:
    client.delete(session)
```

### Context Manager Pattern

Implement automatic cleanup using Python's context manager protocol:

```python
import os
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams

class SessionManager:
    def __init__(self, image_id="linux_latest"):
        self.agent_bay = AgentBay(api_key=os.getenv("AGENTBAY_API_KEY"))
        self.image_id = image_id
        self.session = None
    
    def __enter__(self):
        params = CreateSessionParams(image_id=self.image_id) if self.image_id != "linux_latest" else None
        result = self.agent_bay.create(params)
        if result.success:
            self.session = result.session
            return self.session
        else:
            raise Exception(f"Session creation failed: {result.error_message}")
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            self.agent_bay.delete(self.session)
            print("🧹 Session automatically cleaned up")

try:
    with SessionManager("code_latest") as session:
        result = session.command.execute_command("echo 'Automatic cleanup!'")
        print(f"Output: {result.output}")
except Exception as e:
    print(f"Error: {e}")
```

## API Reference

For detailed API documentation, see:
- [Python Session API](../../../../python/docs/api/common-features/basics/session.md)
- [TypeScript Session API](../../../../typescript/docs/api/common-features/basics/session.md)
- [Golang Session API](../../../../golang/docs/api/common-features/basics/session.md)
- [Python AgentBay API](../../../../python/docs/api/common-features/basics/agentbay.md)
- [TypeScript AgentBay API](../../../../typescript/docs/api/common-features/basics/agentbay.md)
- [Golang AgentBay API](../../../../golang/docs/api/common-features/basics/agentbay.md)

## 📚 Related Guides

- [Data Persistence](data-persistence.md) - Persistent data storage across sessions
- [File Operations](file-operations.md) - File handling and management
- [Command Execution](command-execution.md) - Execute shell commands
- [VPC Sessions](../advanced/vpc-sessions.md) - Isolated network environments

## 🆘 Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Documentation Home](../README.md)




# Configuration

SDK configuration options and settings.

## Documentation

- [SDK Configuration](sdk-configuration.md) - API keys, gateway regions, and endpoints
- [Logging](logging.md) - Configure log levels, output, and data masking

## Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Main Documentation](../../../README.md)




# Logging Configuration Guide

This guide shows how to configure logging in AgentBay SDK. Each language has its own documentation with specific details.

## Quick Links

- **[Python Logging Guide](../../../../python/docs/api/common-features/basics/logging.md)** - Setup, configuration, and file logging
- **[Go Logging Guide](../../../../golang/docs/api/common-features/basics/logging.md)** - Environment variables and code-level configuration
- **[TypeScript Logging Guide](../../../../typescript/docs/api/common-features/basics/logging.md)** - Import-time setup and RequestID tracking

---

## Overview

All AgentBay SDKs provide:
- Multiple log levels (DEBUG, INFO, WARNING/WARN, ERROR)
- **.env file support** - Automatically loaded from project directory
- Environment variable configuration (AGENTBAY_LOG_LEVEL or LOG_LEVEL)
- Code-level setup
- Automatic sensitive data masking
- Color output detection

### Quick Start: Using .env File (Recommended)

Create a `.env` file in your project root:

```
# .env file
AGENTBAY_LOG_LEVEL=DEBUG

# Other configuration
AGENTBAY_API_KEY=your_api_key_here
```

All SDKs automatically load this file - no additional code needed!

### Priority System (All Languages)

Log levels are applied in this order (highest to lowest):

1. **setup() method** - Explicitly calling setup() always takes effect (code-level configuration)
2. **Environment variables** - AGENTBAY_LOG_LEVEL or LOG_LEVEL
3. **.env file** - Automatically loaded from current directory or parent directories
4. **Default values** - INFO level if nothing else is configured

---

## Python Example

### Set Log Level via .env File (Recommended)

Create a `.env` file in your project root:

```
# .env file
AGENTBAY_LOG_LEVEL=DEBUG
```

The SDK automatically loads this file.

### Set Log Level via Environment Variable

```bash
export AGENTBAY_LOG_LEVEL=DEBUG
python your_script.py
```

### Set Log Level in Code

```python
from agentbay.logger import AgentBayLogger, get_logger

# Configure logging level with setup()
AgentBayLogger.setup(level="DEBUG")

logger = get_logger("my_app")
logger.debug("Debug message")
logger.info("Info message")
```

### Available Log Levels

| Level | Use Case |
|-------|----------|
| **DEBUG** | Development - see everything |
| **INFO** | Default - important events |
| **WARNING** | Issues but not failures |
| **ERROR** | Only failures |

### File Logging

> **Note**: File logging is currently only available in the Python SDK. TypeScript and Golang SDKs log to stdout/stderr.

The Python SDK supports file logging with automatic log rotation and retention. By default, logs are written to `python/agentbay.log`.

```python
from agentbay.logger import AgentBayLogger

# Configure file logging with rotation
AgentBayLogger.setup(
    level="DEBUG",
    log_file="/var/log/myapp.log",  # Custom log file path
    rotation="100 MB",               # Rotate when file reaches 100 MB
    retention="30 days"              # Keep logs for 30 days
)
```

---

## Sensitive Data Masking

All SDKs automatically mask sensitive information:

- API keys, tokens, passwords
- Authorization headers
- Private keys

No configuration needed - it works automatically.





# SDK Configuration Guide

This guide explains how to configure the AgentBay SDK for different environments and requirements.

> **Important:** The `endpoint` configuration specifies the **API Gateway location** used for SDK-backend communication. This determines which regional gateway your SDK connects to, but does not necessarily determine where your cloud sessions will be created. A future feature may allow selecting the cloud environment region separately when creating sessions.

## Configuration Parameters

| Parameter | Environment Variable | Description | Default Value |
|-----------|---------------------|-------------|---------------|
| API Key | `AGENTBAY_API_KEY` | Authentication key for API access | Required |
| Endpoint | `AGENTBAY_ENDPOINT` | API Gateway endpoint URL (determines gateway location for SDK communication) | `wuyingai.cn-shanghai.aliyuncs.com` |

## Supported API Gateway Regions

The following API gateway locations are available. Choose the gateway closest to your users for optimal network performance:

| Gateway Location | Endpoint |
|-----------------|----------|
| Shanghai | `wuyingai.cn-shanghai.aliyuncs.com` |
| Singapore | `wuyingai.ap-southeast-1.aliyuncs.com` |

## Default Configuration

If no configuration is provided, the SDK uses the following default values:

```json
{
    "endpoint": "wuyingai.cn-shanghai.aliyuncs.com"
}
```

## Configuration Priority

Configuration values are resolved in the following order (highest to lowest priority):

1. **Hard-coded configuration** (passed directly to SDK)
2. **Environment variables**
3. **`.env` configuration file** (searched upward from current directory)
4. **Default configuration**

## Configuration Methods

### Method 1: Environment Variables

Set configuration using shell commands:

**Linux/macOS:**
```bash
export AGENTBAY_API_KEY=your-api-key-here
export AGENTBAY_ENDPOINT=wuyingai.ap-southeast-1.aliyuncs.com
```

**Windows:**
```cmd
set AGENTBAY_API_KEY=your-api-key-here
set AGENTBAY_ENDPOINT=wuyingai.ap-southeast-1.aliyuncs.com
```

### Method 2: .env File

The SDK automatically searches for `.env` files using the following strategy:

1. **Current directory** - starts from where your program runs
2. **Parent directories** - searches upward until it finds a `.env` file or reaches the root
3. **First match wins** - stops searching when the first `.env` file is found

**Basic usage:**
```env
# .env file (can be placed in project root or any parent directory)
AGENTBAY_API_KEY=your-api-key-here
AGENTBAY_ENDPOINT=wuyingai.ap-southeast-1.aliyuncs.com
```

**File locations examples:**
```
my-project/
├── .env                    # ✅ Found from any subdirectory
└── src/
    └── app/
        └── main.py         # Searches upward: app/ → src/ → my-project/ ✅
```

**Custom .env file path:**

```python
from agentbay import AgentBay
client = AgentBay(env_file="/path/to/custom.env")
```

### Method 3: Hard-coded Configuration (Debug Only)

For debugging purposes, you can pass configuration directly in code:

```python
from agentbay import AgentBay, Config

# Hard-coded configuration (not recommended for production)
config = Config(
    endpoint="wuyingai.ap-southeast-1.aliyuncs.com",
    timeout_ms=60000
)
agent_bay = AgentBay(api_key="your-api-key-here", cfg=config)
```

> **Warning:** Hard-coding API keys and configuration is not recommended for production environments due to security risks.

### SDK Initialization

After setting configuration, initialize the SDK:

```python
from agentbay import AgentBay
agent_bay = AgentBay()  # Automatically searches for .env files
```

## Common Scenarios

### Switch to Singapore Gateway

To use the Singapore API gateway for better network performance in Asia-Pacific regions:

```bash
export AGENTBAY_ENDPOINT=wuyingai.ap-southeast-1.aliyuncs.com
```


### Development vs Production

**Development:** 
- Use `.env` file in project root for local configuration
- SDK automatically finds configuration regardless of execution directory
- For different environments, use custom paths: `AgentBay(env_file=".env.development")`

**Production:** 
- Use environment variables for secure deployment
- Environment variables always take precedence over `.env` files

## Troubleshooting

### Check Configuration

```bash
env | grep AGENTBAY  # Verify environment variables
```

**Debug .env file discovery:**
```bash
# Check if .env file exists in current directory or parent directories
find . -name ".env" -o -name ".git" -type d 2>/dev/null | head -10
```

### Common Error Messages

#### 1. Missing API Key
**Error:** `ValueError: API key is required. Provide it as a parameter or set the AGENTBAY_API_KEY environment variable`

**Solution:** 
- Set the `AGENTBAY_API_KEY` environment variable
- Or pass `api_key` parameter when creating AgentBay instance

#### 2. Invalid API Key
**Error:** `NOT_LOGIN code: 400, You are not logged in or your login token has expired`

**Solution:**
- Verify your API key is correct and not expired
- Check if your API key has proper permissions
- Contact support if the key should be valid

#### 3. API Key and Gateway Mismatch
**Error:** `NOT_LOGIN code: 400` with unexpected `HostId` in error response

**Example:** Error shows `'HostId': 'wuyingai.ap-southeast-1.aliyuncs.com'` but you expected to connect to Shanghai gateway.

**Solution:**
- Check if your API key belongs to the correct gateway region
- Ensure `AGENTBAY_ENDPOINT` matches your API key's gateway region
- Shanghai API keys work with `wuyingai.cn-shanghai.aliyuncs.com` gateway endpoint
- Singapore API keys work with `wuyingai.ap-southeast-1.aliyuncs.com` gateway endpoint

#### 4. Wrong Endpoint/Network Issues
**Error:** `Failed to resolve 'invalid-endpoint.com'` or `NameResolutionError`

**Solution:**
- Verify the gateway endpoint URL is correct
- Ensure your network can reach the gateway endpoint
- Check if you're behind a corporate firewall
- Confirm gateway location and endpoint match (see supported gateway regions table above)

#### 5. .env File Not Found
**Symptom:** SDK uses default configuration despite having a `.env` file

**Solution:**
- Ensure `.env` file is in your project root or a parent directory
- Check file permissions (must be readable)
- Verify file format (no spaces around `=`, proper line endings)
- Use absolute path if needed: `AgentBay(env_file="/full/path/to/.env")`
- Debug with: `find . -name ".env" -type f` to locate your `.env` files

### Quick Diagnosis

```python
from agentbay import AgentBay

try:
    agent_bay = AgentBay()  # Test basic initialization
    result = agent_bay.create()  # Test API connectivity
    print("Configuration is working correctly")
except ValueError as e:
    print(f"Configuration issue: {e}")
except Exception as e:
    print(f"Network/API issue: {e}")
```

## Best Practices

- **Gateway Selection:** Choose the API gateway closest to your users for optimal network performance
- **Security:** Use environment variables in production (not hardcoded values)
- **Validation:** Test configuration during application startup
- **Future Planning:** Be aware that future versions may support specifying cloud environment regions separately during session creation

## Related Documentation

- [Getting Started](../../../quickstart/installation.md)
- [Session Management](../basics/session-management.md)

## 📚 Related Guides

- [Session Management](../basics/session-management.md) - Session lifecycle and configuration
- [VPC Sessions](../advanced/vpc-sessions.md) - Isolated network environments

## 🆘 Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Documentation Home](../../README.md)




# Use Cases

This directory contains practical use cases and examples for the AgentBay SDK. Each use case provides detailed implementation examples, integration patterns, and best practices for specific scenarios.

## Available Use Cases

### Session Management

- **[Session Information Use Cases](session-info-use-cases.md)** - Practical examples for using session information, including browser access, Android SDK integration, and session health monitoring
- **[Session Link Use Cases](session-link-use-cases.md)** - Practical examples for connecting external tools to cloud sessions, including browser automation, web application access, and custom service connections

## How to Use This Directory

Each use case document follows a consistent structure:

1. **Overview** - Brief description of the use case and its applications
2. **Prerequisites** - Required setup and dependencies
3. **Implementation Examples** - Step-by-step code examples with explanations
4. **Best Practices** - Recommended approaches and common patterns
5. **Troubleshooting** - Common issues and solutions
6. **Related Resources** - Links to relevant guides and API documentation

## Contributing Use Cases

When adding new use cases to this directory:

1. Follow the established naming convention: `{feature}-use-cases.md`
2. Include practical, real-world examples
3. Provide comprehensive code samples with explanations
4. Add troubleshooting sections for common issues
5. Update this README.md to include the new use case
6. Cross-reference with related guides and API documentation

## Getting Help

If you need assistance with any of these use cases:

1. Visit the [Quick Start guide](../../../quickstart/README.md) for basic setup
2. Consult the specific guide documents in the [guides directory](../../README.md)
3. Check the troubleshooting sections in individual guide documents

For additional support, please refer to the main [AgentBay SDK documentation](../../README.md).



# Session Information Use Cases

This document provides practical examples and use cases for using session information obtained from the `session.info()` API. These examples demonstrate common scenarios for integrating AgentBay sessions with different platforms and systems.

## Overview

The `session.info()` method provides detailed information about a session, including direct browser access URLs and SDK integration credentials. This API serves multiple purposes:

1. **Cloud Environment Access**: Get the `resource_url` to directly access the cloud environment in a web browser with real-time video streaming and full mouse/keyboard control
2. **Session Status Validation**: Check if a session is still active and hasn't been released  
3. **SDK Integration**: Extract authentication credentials for Web SDK (desktop) and Android SDK (mobile) integration

## Use Case 1: Cloud Environment Access via Browser

The most common use case is accessing the cloud environment directly through a web browser using the `resource_url`:

```python
def access_cloud_environment_browser(session):
    """Get cloud environment access URL for browser-based remote control."""
    info_result = session.info()

    if info_result.success:
        info = info_result.data
        resource_url = info.resource_url

        print(f"Cloud environment ready for session: {info.session_id}")
        print(f"Resource URL: {resource_url}")
        print("\n🌐 Copy and paste the Resource URL into any web browser to access the cloud environment")
        print("   Features available:")
        print("   - Real-time video stream of the desktop")
        print("   - Mouse and keyboard interaction capabilities")
        print("   - Full remote desktop experience")

        return {
            "session_id": info.session_id,
            "resource_url": resource_url,
            "access_method": "browser_direct"
        }
    else:
        print(f"Failed to get session info: {info_result.error_message}")
        return None

# Usage
access_info = access_cloud_environment_browser(session)
if access_info:
    print("Cloud environment URL is ready - open it in your browser to start using the remote desktop")
```

## Use Case 2: Android SDK Configuration for Cloud Environment Access

The session information obtained from `session.info()` can be used as configuration parameters for the Alibaba Cloud Android SDK, enabling users to connect to the session's cloud environment through the Android SDK:

```python
def prepare_android_sdk_config(session):
    """Prepare Android SDK configuration for cloud environment connection."""
    info_result = session.info()
    
    if info_result.success:
        info = info_result.data
        
        # Android SDK Config parameters based on Alibaba Cloud Android SDK documentation
        # Reference: https://help.aliyun.com/zh/ecp/android-sdk-of-cloud-phone section 4.1 Config
        # info.resource_id maps to CONFIG_DESKTOP_ID
        # info.ticket maps to CONFIG_CONNECTION_TICKET
        android_config = {
            "CONFIG_DESKTOP_ID": info.resource_id,      # Desktop ID for connection
            "CONFIG_CONNECTION_TICKET": info.ticket,    # Connection ticket for authentication
            "CONFIG_USE_VPC": False,                     # VPC configuration (set based on your network setup)
            "OS_TYPE": "android",                        # OS type for the connection
            "CONFIG_USER": "",                           # User identifier (optional)
            "CONFIG_UUID": ""                            # UUID identifier (optional)
        }
        
        print("Android SDK Configuration:")
        print(f"CONFIG_DESKTOP_ID: {info.resource_id}")
        print(f"CONFIG_CONNECTION_TICKET: {info.ticket[:50]}...")  # Truncated for security
        print(f"CONFIG_USE_VPC: {android_config['CONFIG_USE_VPC']}")
        print(f"OS_TYPE: {android_config['OS_TYPE']}")
        
        return android_config
    else:
        print(f"Failed to prepare Android SDK config: {info_result.error_message}")
        return None

# Usage example for Android SDK integration
android_config = prepare_android_sdk_config(session)
if android_config:
    print("Android SDK configuration ready for StreamView connection")
    
    # Method 1: Using StreamView.start() with mConfigs (reference section 2.2)
    # Map<String, Object> mConfigs = new HashMap<>();
    # mConfigs.put("CONFIG_DESKTOP_ID", android_config.get("CONFIG_DESKTOP_ID"));
    # mConfigs.put("CONFIG_CONNECTION_TICKET", android_config.get("CONFIG_CONNECTION_TICKET"));
    # mConfigs.put("CONFIG_USE_VPC", android_config.get("CONFIG_USE_VPC"));
    # mConfigs.put("OS_TYPE", android_config.get("OS_TYPE"));
    # mConfigs.put("CONFIG_USER", android_config.get("CONFIG_USER"));
    # mConfigs.put("CONFIG_UUID", android_config.get("CONFIG_UUID"));
    # mStreamView.start(mConfigs);
    
    # Method 2: Using IAspEngine with ConnectionConfig (reference section 2.5)
    # ConnectionConfig cc = new ConnectionConfig();
    # cc.id = android_config.get("CONFIG_DESKTOP_ID");
    # cc.connectionTicket = android_config.get("CONFIG_CONNECTION_TICKET");
    # cc.useVPC = android_config.get("CONFIG_USE_VPC");
    # cc.type = android_config.get("OS_TYPE");
    # cc.user = android_config.get("CONFIG_USER");
    # cc.uuid = android_config.get("CONFIG_UUID");
    # engine.start(cc);
```

### Android SDK Integration Notes

- **`info.resource_id`** maps to **`CONFIG_DESKTOP_ID`** - This is the unique identifier for the cloud desktop/resource that the Android client will connect to
- **`info.ticket`** maps to **`CONFIG_CONNECTION_TICKET`** - This is the authentication ticket required to establish a secure connection to the cloud environment
- **`CONFIG_USE_VPC`** - Set to `true` if your cloud environment uses VPC networking, `false` for standard networking
- **`OS_TYPE`** - Specifies the OS type, typically set to "android" for mobile connections
- **`CONFIG_USER`** and **`CONFIG_UUID`** - Optional parameters that can be set based on your specific requirements
- The Android SDK supports two connection methods:
  1. **StreamView.start(mConfigs)** - Direct connection using configuration map (section 2.2)
  2. **IAspEngine with ConnectionConfig** - Multi-StreamView mode for advanced scenarios (section 2.5)
- For detailed Android SDK integration steps, refer to the [Alibaba Cloud Android SDK documentation](https://help.aliyun.com/zh/ecp/android-sdk-of-cloud-phone)

## Use Case 3: Session Status Validation and Health Check

Use `info()` to check if a session is still active and hasn't been released:

```python
def check_session_status(session):
    """Check if session is still active and hasn't been released."""
    try:
        info_result = session.info()

        if info_result.success:
            info = info_result.data
            print(f"✅ Session {info.session_id} is ACTIVE")
            print(f"   Resource ID: {info.resource_id}")
            print(f"   App ID: {info.app_id}")
            print(f"   Resource Type: {info.resource_type}")
            return True
        else:
            print(f"❌ Session status check failed: {info_result.error_message}")
            return False

    except Exception as e:
        print(f"❌ Session has been RELEASED or is inaccessible: {e}")
        return False

def monitor_session_health(session, check_interval=30):
    """Continuously monitor session health."""
    import time

    print(f"Starting health monitoring for session: {session.session_id}")

    while True:
        is_active = check_session_status(session)

        if not is_active:
            print("🚨 Session is no longer active - stopping monitoring")
            break

        print(f"💚 Session health check passed - next check in {check_interval}s")
        time.sleep(check_interval)

# Usage examples
print("=== Session Status Check ===")
if check_session_status(session):
    print("Session is ready for use")
else:
    print("Session needs to be recreated")

# For continuous monitoring (run in background thread)
# import threading
# monitor_thread = threading.Thread(target=monitor_session_health, args=(session, 60))
# monitor_thread.daemon = True
# monitor_thread.start()
```

## Additional Integration Scenarios

### Web SDK Integration

For web-based applications that need to embed cloud environment access:

```python
def prepare_web_sdk_config(session):
    """Prepare configuration for Web SDK integration."""
    info_result = session.info()
    
    if info_result.success:
        info = info_result.data
        
        web_config = {
            "session_id": info.session_id,
            "resource_url": info.resource_url,
            "auth_code": info.auth_code,
            "connection_properties": info.connection_properties
        }
        
        return web_config
    else:
        return None
```

### API Gateway Integration

For scenarios where session access needs to be proxied through an API gateway:

```python
def create_session_proxy_endpoint(session):
    """Create API endpoint configuration for session proxy."""
    info_result = session.info()
    
    if info_result.success:
        info = info_result.data
        
        proxy_config = {
            "endpoint": f"/api/sessions/{info.session_id}/proxy",
            "target_url": info.resource_url,
            "auth_token": info.auth_code,
            "session_metadata": {
                "resource_id": info.resource_id,
                "app_id": info.app_id,
                "resource_type": info.resource_type
            }
        }
        
        return proxy_config
    else:
        return None
```

## Best Practices

1. **Always validate session info results** - Check the `success` field before using session information
2. **Handle authentication securely** - Never log or expose auth codes and tickets in plain text
3. **Implement proper error handling** - Session info calls can fail if sessions are released
4. **Cache session information appropriately** - Avoid excessive info() calls, but refresh when needed
5. **Monitor session lifecycle** - Use periodic health checks for long-running applications
6. **Secure credential transmission** - Use HTTPS/TLS when transmitting session credentials to other systems

## Troubleshooting

### Common Issues

1. **Session info returns null/empty**: Session may have been released or expired
2. **Authentication failures**: Verify auth codes and tickets are correctly transmitted
3. **Connection timeouts**: Check network connectivity and firewall settings
4. **Invalid resource URLs**: Ensure the session is still active before using URLs

### Error Handling

```python
def robust_session_info_handler(session):
    """Robust session info handling with comprehensive error handling."""
    try:
        info_result = session.info()
        
        if info_result.success:
            return info_result.data
        else:
            print(f"Session info failed: {info_result.error_message}")
            # Consider session recreation or fallback logic
            return None
            
    except Exception as e:
        print(f"Session info exception: {e}")
        # Session likely released - implement recovery logic
        return None
```

For more information about session management, see the [Session Management Guide](../basics/session-management.md).
## 📚 Related Guides

- [Session Management](../basics/session-management.md) - Session lifecycle and configuration
- [Session Link Access](../advanced/session-link-access.md) - Session connectivity

## 🆘 Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Documentation Home](../../README.md)




# Session Link Use Cases

This document provides practical use cases for Session Link Access, showing you how to connect external tools to services running in your AgentBay cloud sessions.

> **⚠️ Important Notice**: The Session Link feature is currently in whitelist-only access. To request access to this feature, please send your application to agentbay_dev@alibabacloud.com. For product feedback or suggestions, please submit through the [Alibaba Cloud ticket system](https://smartservice.console.aliyun.com/service/list).

## 📋 Table of Contents

- [Overview](#overview)
- [Use Case 1: Browser Automation](#use-case-1-browser-automation)
- [Use Case 2: Access Web Applications](#use-case-2-access-web-applications)
- [Use Case 3: Connect to Custom Services](#use-case-3-connect-to-custom-services)
- [Quick Selection Guide](#quick-selection-guide)
- [Complete Code Examples](#complete-code-examples)

---

## Overview

Session Link provides **direct network access URLs** to services in your cloud session. The `get_link()` method enables three main scenarios:

1. ✅ **Control a cloud browser** with Playwright/Puppeteer (browser automation via CDP)
2. ✅ **Access web applications** running in your session (like dev servers on custom ports)
3. ✅ **Connect to custom services** in the cloud (like WebSocket servers, databases)

---

<a id="use-case-1-browser-automation"></a>
## Use Case 1: Browser Automation 🤖

### Your Need
I want to control a cloud browser with Playwright/Puppeteer for automation tasks.

### Solution
Call `get_link()` **with no parameters**. It returns a browser control address (CDP endpoint).

### Minimal Code

```python
import asyncio
from agentbay import AgentBay, CreateSessionParams
from agentbay.browser.browser import BrowserOption
from playwright.async_api import async_playwright

async def main():
    # 1. Create session (MUST use Browser Use image)
    agent_bay = AgentBay(api_key="your_api_key")
    session = agent_bay.create(
        CreateSessionParams(image_id="browser_latest")  # or other Browser Use images
    ).session

    # 2. Initialize browser and wait for it to be ready
    await session.browser.initialize_async(BrowserOption())
    await asyncio.sleep(10)  # Wait for browser to be fully ready

    # 3. Get browser control address
    link = session.get_link()
    print(f"Browser address: {link.data}")
    # Output: wss://gateway.../websocket_ai/...

    # 4. Connect with Playwright
    async with async_playwright() as p:
        browser = await p.chromium.connect_over_cdp(link.data)
        context = browser.contexts[0]
        page = await context.new_page()
        await page.goto("https://example.com")
        # Now you can control the cloud browser!
        await browser.close()
    
    # 5. Cleanup
    agent_bay.delete(session)

asyncio.run(main())
```

### Key Points
- ✅ MUST use Browser Use image (e.g., `browser_latest` or custom Browser Use images)
- ✅ No parameters needed (or use `protocol_type="wss"`)
- ✅ Returns a WebSocket URL starting with `wss://`

### Who Is This For?
- Browser automation testing
- Web scraping with headless browsers
- RPA automation workflows

---

<a id="use-case-2-access-web-applications"></a>
## Use Case 2: Access Web Applications 🌐

### Your Need
I'm running a web service in the cloud session (like `npm run dev`) and want to access it from my local browser.

### Solution
Call `get_link(protocol_type="https", port=port_number)` to get an HTTPS URL.

### Minimal Code

```python
from agentbay import AgentBay

# 1. Create session (any image works)
agent_bay = AgentBay(api_key="your_api_key")
session = agent_bay.create().session

# 2. Start a web server in the cloud (port 30150)
session.file_system.write_file(
    "/tmp/index.html", 
    "<h1>Hello from Cloud!</h1>"
)
session.command.execute_command(
    "cd /tmp && python3 -m http.server 30150 &"
)

# 3. Get access URL
link = session.get_link(protocol_type="https", port=30150)
print(f"Web app URL: {link.data}")
# Output: https://gateway.../request_ai/.../path/

# 4. Open this URL in your browser to access the cloud web service!
```

### Key Points
- ✅ MUST specify both `protocol_type="https"` and `port`
- ✅ Port number MUST be in **30100-30199** range
- ✅ Returns an HTTPS URL you can open in a browser

### Who Is This For?
- Debugging frontend projects in the cloud (React/Vue dev servers)
- Viewing web apps running in the cloud

---

<a id="use-case-3-connect-to-custom-services"></a>
## Use Case 3: Connect to Custom Services 🔌

### Your Need
I'm running a custom service in the cloud and want to connect to it from my local machine.

### Solution
Call `get_link(port=port_number)` to get a WebSocket URL.

### Minimal Code

```python
from agentbay import AgentBay

# 1. Create session
agent_bay = AgentBay(api_key="your_api_key")
session = agent_bay.create().session

# 2. Start a service in the cloud (port 30180)
session.command.execute_command(
    "python3 -m http.server 30180 &"
)

# 3. Get connection URL
link = session.get_link(port=30180)
print(f"Service URL: {link.data}")
# Output: wss://gateway.../websocket_ai/...

# 4. Connect from your local code
# (Use appropriate client based on your service type)
```

### Key Points
- ✅ Only pass `port`, don't pass `protocol_type`
- ✅ Port number MUST be in **30100-30199** range
- ✅ Returns a WebSocket URL (wss://)

### Who Is This For?
- Connecting to custom WebSocket services
- Accessing database services (via port forwarding)
- Debugging network services

---

## Quick Selection Guide

### Decision Tree

```
Question: What do you want to do?
    ↓
├─ A. Control a browser → [Use Case 1] No parameters
├─ B. Access a web page → [Continue to Question 2]
└─ C. Connect to other services → [Continue to Question 3]

Question 2: This web page is...
├─ Running in the cloud session → [Use Case 2] HTTPS + port
└─ External website → ⚠️  No need for get_link, access directly

Question 3: This service is...
├─ HTTP/HTTPS service → [Use Case 2] HTTPS + port
├─ WebSocket or other → [Use Case 3] Port only
└─ Other protocols → ⚠️  Only HTTPS and WSS are supported
```

### Quick Reference Table

| Your Need | How to Call | protocol_type | port | Image Required |
|-----------|------------|---------------|------|----------------|
| Browser automation (CDP) | `get_link()` | Don't pass | Don't pass | Browser Use image |
| Access web app | `get_link("https", 30150)` | `"https"` | 30100-30199 | Any |
| WebSocket service | `get_link(port=30150)` | Don't pass | 30100-30199 | Any |
| Custom HTTPS service | `get_link("https", 30150)` | `"https"` | 30100-30199 | Any |

### Common Mistakes

| You Write | What Happens | Correct Way |
|-----------|--------------|-------------|
| `get_link("https")` | ❌ Error: "port is not valid" | `get_link("https", 30150)` |
| `get_link(port=8080)` | ❌ Error: "Port must be in 30100-30199" | `get_link(port=30150)` |
| `get_link("http", 30150)` | ❌ Error: "http not supported" | `get_link("https", 30150)` |
| Non-Browser Use image + `get_link()` | ❌ Error: "only BrowserUse image support cdp" | Use Browser Use image (e.g., `browser_latest`) |

---

## Complete Code Examples

These are complete, tested examples you can copy and run directly.

### Example 1: Browser Automation Complete Flow

**Goal**: Control a cloud browser with Playwright and visit a website

```python
import asyncio
import os
from agentbay import AgentBay, CreateSessionParams
from playwright.async_api import async_playwright

async def browser_automation_example():
    """Complete browser automation example"""
    
    # 1. Initialize (get API key from environment variable)
    api_key = os.environ.get("AGENTBAY_API_KEY")
    if not api_key:
        print("❌ Error: AGENTBAY_API_KEY environment variable is not set")
        print("Please set it using: export AGENTBAY_API_KEY=your_api_key")
        return
    
    agent_bay = AgentBay(api_key=api_key)
    session = None
    
    try:
        # 2. Create Browser Use session
        print("Creating cloud browser session...")
        session_result = agent_bay.create(
            CreateSessionParams(image_id="browser_latest")
        )
        
        if not session_result.success:
            print(f"❌ Failed: {session_result.error_message}")
            return
        
        session = session_result.session
        print(f"✅ Session created: {session.session_id}")
        
        # 3. Initialize browser
        print("\nInitializing browser...")
        from agentbay.browser.browser import BrowserOption
        init_ok = await session.browser.initialize_async(BrowserOption())
        if not init_ok:
            print("❌ Browser initialization failed")
            return
        print("✅ Browser initialized")
        
        # Wait for browser to be ready
        print("Waiting for browser to be ready...")
        await asyncio.sleep(10)
        
        # 4. Get browser CDP address
        print("\nGetting browser control address...")
        link_result = session.get_link()
        
        if not link_result.success:
            print(f"❌ Failed: {link_result.error_message}")
            return
        
        cdp_url = link_result.data
        print(f"✅ CDP URL: {cdp_url[:60]}...")
        
        # 5. Connect with Playwright and control browser
        print("\nConnecting to browser...")
        async with async_playwright() as p:
            browser = await p.chromium.connect_over_cdp(cdp_url)
            print("✅ Connected to browser!")
            
            # Create new page
            context = browser.contexts[0]
            page = await context.new_page()
            
            # Visit Alibaba Cloud website
            print("\nVisiting https://www.aliyun.com ...")
            await page.goto("https://www.aliyun.com")
            title = await page.title()
            print(f"✅ Page title: {title}")
            
            # Close browser
            await browser.close()
            print("✅ Browser closed")
        
        print("\n🎉 SUCCESS: Browser automation completed!")
        
    except Exception as e:
        print(f"❌ Error: {e}")
        import traceback
        traceback.print_exc()
    
    finally:
        # 6. Cleanup
        if session:
            print("\nCleaning up...")
            agent_bay.delete(session)
            print("✅ Session deleted")

if __name__ == "__main__":
    asyncio.run(browser_automation_example())
```

**Before Running**:
1. Install dependencies: `pip install wuying-agentbay-sdk playwright`
2. Install browser: `playwright install chromium`
3. Set your API key: `export AGENTBAY_API_KEY=your_api_key`

**Expected Output**:
```
Creating cloud browser session...
✅ Session created: session-abc123

Getting browser control address...
✅ CDP URL: wss://gateway.../websocket_ai/...

Connecting to browser...
✅ Connected to browser!

Visiting https://www.aliyun.com ...
✅ Page title: 阿里云-计算，为了无法计算的价值
✅ Browser closed

🎉 SUCCESS: Browser automation completed!

Cleaning up...
✅ Session deleted
```

---

### Example 2: Access Cloud Web Application

**Goal**: Start an HTTP server in the cloud and access it from local browser

```python
import time
import os
from agentbay import AgentBay

def web_app_access_example():
    """Complete web application access example"""
    
    # 1. Initialize (get API key from environment variable)
    api_key = os.environ.get("AGENTBAY_API_KEY")
    if not api_key:
        print("❌ Error: AGENTBAY_API_KEY environment variable is not set")
        print("Please set it using: export AGENTBAY_API_KEY=your_api_key")
        return
    
    agent_bay = AgentBay(api_key=api_key)
    session = None
    
    try:
        # 2. Create session (any image works)
        print("Creating session...")
        session = agent_bay.create().session
        print(f"✅ Session ID: {session.session_id}")
        
        # 3. Create a simple HTML file in the cloud
        print("\nCreating HTML file in cloud...")
        session.file_system.write_file(
            "/tmp/index.html",
            "<h1>Hello from AgentBay Cloud!</h1><p>Running on port 30150</p>"
        )
        print("✅ HTML file created")
        
        # 4. Start HTTP server on port 30150
        print("\nStarting HTTP server...")
        port = 30150
        session.command.execute_command(
            f"cd /tmp && nohup python3 -m http.server {port} > /dev/null 2>&1 &"
        )
        time.sleep(3)  # Wait for server to start
        print(f"✅ HTTP server started on port {port}")
        
        # 5. Get access URL
        print("\nGetting access URL...")
        link_result = session.get_link(protocol_type="https", port=port)
        
        if not link_result.success:
            print(f"❌ Failed: {link_result.error_message}")
            return
        
        web_url = link_result.data
        print(f"✅ Web URL: {web_url}")
        
        print("\n" + "=" * 70)
        print("🎉 SUCCESS: Web application is accessible!")
        print("=" * 70)
        print(f"\n👉 Open this URL in your browser:")
        print(f"   {web_url}")
        print(f"\nSession will stay alive for 30 seconds...")
        
        time.sleep(30)
        
    except Exception as e:
        print(f"❌ Error: {e}")
        import traceback
        traceback.print_exc()
    
    finally:
        # 6. Cleanup
        if session:
            print("\nCleaning up...")
            agent_bay.delete(session)
            print("✅ Session deleted")

if __name__ == "__main__":
    web_app_access_example()
```

**Key Points**:
- Port must be in 30100-30199 range
- Must pass both `protocol_type` and `port`
- Returned URL can be opened directly in browser

---

### Example 3: Custom Port Access

**Goal**: Demonstrate port parameter usage for custom services

```python
import time
import os
from agentbay import AgentBay

def custom_port_example():
    """Custom port access example"""
    
    # 1. Initialize (get API key from environment variable)
    api_key = os.environ.get("AGENTBAY_API_KEY")
    if not api_key:
        print("❌ Error: AGENTBAY_API_KEY environment variable is not set")
        print("Please set it using: export AGENTBAY_API_KEY=your_api_key")
        return
    
    agent_bay = AgentBay(api_key=api_key)
    session = None
    
    try:
        # 2. Create session
        print("Creating session...")
        session = agent_bay.create().session
        print(f"✅ Session ID: {session.session_id}")
        
        # 3. Start a service on custom port 30180
        print("\nStarting service on port 30180...")
        port = 30180
        session.command.execute_command(
            f"cd /tmp && nohup python3 -m http.server {port} > /dev/null 2>&1 &"
        )
        time.sleep(3)
        print(f"✅ Service started on port {port}")
        
        # 4. Get link with custom port
        print("\nGetting link with custom port...")
        link_result = session.get_link(port=port)
        
        if not link_result.success:
            print(f"❌ Failed: {link_result.error_message}")
            return
        
        service_url = link_result.data
        print(f"✅ Service URL: {service_url[:80]}...")
        print(f"✅ Protocol: {service_url.split('://')[0]}://")
        
        # Verify protocol
        if service_url.startswith("wss://"):
            print("✅ Confirmed: WebSocket Secure (wss://) URL")
        
        print("\n🎉 SUCCESS: Custom port link obtained!")
        print(f"\nKey findings:")
        print(f"  - Port: {port}")
        print(f"  - Protocol: wss://")
        print(f"  - Port range: 30100-30199")
        
    except Exception as e:
        print(f"❌ Error: {e}")
        import traceback
        traceback.print_exc()
    
    finally:
        # 5. Cleanup
        if session:
            print("\nCleaning up...")
            agent_bay.delete(session)
            print("✅ Session deleted")

if __name__ == "__main__":
    custom_port_example()
```

**Note**: These examples have been tested and verified with real AgentBay API calls.

---

## Related Resources

- [Session Link Access Guide](../advanced/session-link-access.md) - Complete API documentation and advanced topics
- [Session Management Guide](../basics/session-management.md) - Session lifecycle management
- [Session Information Use Cases](session-info-use-cases.md) - Other session-related use cases

## Getting Help

If you encounter issues:

1. Check the [Session Link Access Guide](../advanced/session-link-access.md) for detailed documentation
2. Search [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
3. Contact support with detailed error information

Remember: Session Link Access is your gateway to cloud session connectivity! 🔗

## 📚 Related Guides

- [Session Link Access](../advanced/session-link-access.md) - Session connectivity and URL generation
- [Session Management](../basics/session-management.md) - Session lifecycle and configuration
- [Browser Use Overview](../../browser-use/README.md) - Browser automation features

## 🆘 Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Documentation Home](../../README.md)




# Computer Use Guide

Computer Use is AgentBay's desktop automation environment for Windows and Linux systems.

## Documentation

- [Application Management](computer-application-management.md) - Desktop application lifecycle management
- [Window Management](window-management.md) - Window control and positioning
- [UI Automation](computer-ui-automation.md) - Mouse and keyboard automation

## Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Main Documentation](../../README.md)




# Browser Capabilities by Image Type

Different image types provide different levels of browser automation capabilities. Understanding these differences is crucial for choosing the right image for your use case.

## Feature Comparison Table

| Feature | Browser Use Image | Computer Use Image (Linux) | Computer Use Image (Windows) |
|---------|-------------------|---------------------------|------------------------------|
| **Image ID** | `browser_latest` | `linux_latest` | `windows_latest` |
| **Browser Initialization** | ✅ Full Support | ✅ Full Support | ❌ Not Available |
| **CDP Endpoint Access** | ✅ Available | ✅ Available | ❌ Not Available |
| **Playwright/Puppeteer Integration** | ✅ Supported | ✅ Supported | ❌ Not Supported |
| **Browser Options** (viewport, user agent, stealth) | ✅ All Options | ✅ All Options | ❌ Not Available |
| **Browser Type Selection** (Chrome/Chromium) | ❌ Chromium Only | ✅ Chrome or Chromium | ❌ Not Available |
| **Browser Proxies** | ✅ Supported | ✅ Supported | ❌ Not Supported |
| **Browser Context** | ✅ Supported | ✅ Supported | ❌ Not Supported |
| **Browser Command-line Args** | ✅ Supported | ✅ Supported | ❌ Not Supported |
| **Browser Default Navigate** | ✅ Supported | ✅ Supported | ❌ Not Supported |
| **CAPTCHA Solving** | ✅ Supported | ✅ Supported | ❌ Not Supported |
| **Page Use Agent** (AI-powered automation) | ✅ Supported | ❌ Not Available | ❌ Not Available |
| **Desktop UI Automation** | ❌ Not Available | ✅ Supported | ✅ Supported |
| **Window Management** | ❌ Not Available | ✅ Supported | ✅ Supported |
| **Best For** | Pure web automation (best performance) | Web + Desktop automation (Linux apps) | Desktop automation only (Windows apps) |

## When to Use Each Image Type

### 1. Browser Use Image (`browser_latest`)

**Use when you only need web browser automation**

- ✅ Provides full browser capabilities including AI-powered Page Use Agent
- ✅ **Best performance and lowest resource cost** for browser automation
- ✅ Optimized specifically for web automation with minimal overhead
- ✅ Best for web scraping, testing, form filling, and web-based workflows
- ❌ Cannot control desktop applications or windows
- ℹ️ Browser type is fixed to Chromium

**Ideal Use Cases:**
- Web scraping and data extraction
- Automated web testing
- Form filling and submission
- Web-based workflow automation
- AI-powered web interactions (Page Use Agent)

### 2. Computer Use Image - Linux (`linux_latest`)

**Use when you need both browser automation AND Linux desktop application control**

- ✅ Provides most browser features except Page Use Agent
- ✅ Can control Linux desktop applications and windows
- ✅ Supports browser type selection between Chrome and Chromium
- ✅ Best for hybrid workflows (web + desktop automation on Linux)
- ℹ️ Slightly higher resource usage than Browser Use Image

**Ideal Use Cases:**
- Hybrid workflows combining web and desktop automation
- Testing Linux desktop applications
- Browser automation with desktop application integration
- Scenarios requiring both web and window management

### 3. Computer Use Image - Windows (`windows_latest`)

**Use when you only need Windows desktop application automation**

- ✅ Full Windows application and window management
- ✅ Complete desktop UI automation capabilities
- ❌ No browser automation capabilities available
- ❌ Cannot initialize or control browsers via SDK

**Ideal Use Cases:**
- Windows desktop application automation
- Window management and UI testing
- Office automation (Word, Excel, PowerPoint)
- Legacy Windows application testing

## Code Examples

### Python

```python
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams

api_key = "your_api_key"
agent_bay = AgentBay(api_key=api_key)

# For pure web automation with AI capabilities
params = CreateSessionParams(image_id="browser_latest")
result = agent_bay.create(params)

# For Linux desktop + browser automation (no Page Use Agent)
params = CreateSessionParams(image_id="linux_latest")
result = agent_bay.create(params)

# For Windows desktop automation only (no browser)
params = CreateSessionParams(image_id="windows_latest")
result = agent_bay.create(params)
```

### TypeScript

```typescript
import { AgentBay, CreateSessionParams } from '@wuying-org/agentbay-sdk';

const apiKey = process.env.AGENTBAY_API_KEY;
const agentBay = new AgentBay(apiKey);

// For pure web automation with AI capabilities
const params = new CreateSessionParams({ imageId: 'browser_latest' });
const result = await agentBay.create(params);

// For Linux desktop + browser automation (no Page Use Agent)
const params = new CreateSessionParams({ imageId: 'linux_latest' });
const result = await agentBay.create(params);

// For Windows desktop automation only (no browser)
const params = new CreateSessionParams({ imageId: 'windows_latest' });
const result = await agentBay.create(params);
```

### Golang

```go
import (
	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
)

apiKey := os.Getenv("AGENTBAY_API_KEY")
agentBay := agentbay.NewAgentBay(apiKey)

// For pure web automation with AI capabilities
params := &agentbay.CreateSessionParams{
	ImageId: "browser_latest",
}
result, err := agentBay.Create(params)

// For Linux desktop + browser automation (no Page Use Agent)
params := &agentbay.CreateSessionParams{
	ImageId: "linux_latest",
}
result, err := agentBay.Create(params)

// For Windows desktop automation only (no browser)
params := &agentbay.CreateSessionParams{
	ImageId: "windows_latest",
}
result, err := agentBay.Create(params)
```

## Decision Guide

### Choose Browser Use Image if:
- ✓ You only need web browser automation
- ✓ You want the best performance and lowest cost
- ✓ You need AI-powered Page Use Agent
- ✓ You don't need desktop application control

### Choose Computer Use Image (Linux) if:
- ✓ You need both web AND desktop automation
- ✓ You need to control Linux applications
- ✓ You want to switch between Chrome and Chromium
- ✓ You need window management alongside browser automation

### Choose Computer Use Image (Windows) if:
- ✓ You only need Windows desktop automation
- ✓ You need to control Windows applications
- ✓ You don't need any browser automation
- ✓ You need full Windows UI automation capabilities

## Important Notes

> **Performance Consideration**: Browser Use Image offers the best performance and lowest resource cost for browser automation, and includes Page Use Agent for AI-powered natural language automation. If you only need manual browser control with Playwright/Puppeteer without desktop features, Browser Use Image is the optimal choice. Use Computer Use Image (Linux) only when you need both browser AND desktop automation capabilities.

> **Page Use Agent Availability**: The AI-powered Page Use Agent is only available in Browser Use Image. If you need natural language browser automation, you must use `browser_latest`.

> **Browser Type Selection**: Only Computer Use Image (Linux) supports choosing between Chrome and Chromium. Browser Use Image is fixed to Chromium, and Computer Use Image (Windows) has no browser support.

## Related Documentation

- [Browser Use Guide](../browser-use/README.md) - Complete browser automation guide
- [Computer Use Guide](README.md) - Desktop automation guide
- [Browser Core Features](../browser-use/core-features.md) - Essential browser features
- [Browser Advanced Features](../browser-use/advance-features.md) - Advanced capabilities
- [Page Use Agent](../browser-use/advance-features/page-use-agent.md) - AI-powered automation





# Application Management for Computer Use

This guide covers application management capabilities for desktop environments (Windows/Linux) using the AgentBay SDK. Learn how to discover, launch, monitor, and control desktop applications in cloud environments.

## 📋 Table of Contents

- [Overview](#overview)
- [Prerequisites](#prerequisites)
- [Getting Installed Applications](#getting-installed-applications)
- [Starting Applications](#starting-applications)
- [Stopping Applications](#stopping-applications)
- [Listing Running Applications](#listing-running-applications)
- [Complete Workflow Example](#complete-workflow-example)
- [API Reference](#api-reference)

<a id="overview"></a>
## 🎯 Overview

The Computer Use module provides comprehensive application management capabilities for desktop environments:

1. **Application Discovery** - Find installed applications in the system
2. **Application Lifecycle** - Start and stop desktop applications
3. **Process Monitoring** - Track running applications and their processes
4. **Desktop Automation** - Automate complex desktop workflows

These features have been tested and verified on `windows_latest` and `linux_latest` system images.

<a id="prerequisites"></a>
## 📦 Prerequisites

First, create a session with a desktop environment:

```python
import os
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams

api_key = os.getenv("AGENTBAY_API_KEY")
if not api_key:
    raise ValueError("AGENTBAY_API_KEY environment variable is required")

agent_bay = AgentBay(api_key=api_key)

params = CreateSessionParams(image_id="linux_latest")
result = agent_bay.create(params)

if result.success:
    session = result.session
    print(f"Session created: {session.session_id}")
    # Output: Session created: session-xxxxxxxxxxxxxxxxx
else:
    print(f"Failed to create session: {result.error_message}")
    exit(1)
```

<a id="getting-installed-applications"></a>
## 🔍 Getting Installed Applications

Discover all applications available in the desktop environment:

```python
result = session.computer.get_installed_apps(
    start_menu=True,
    desktop=False,
    ignore_system_apps=True
)

# Verification: Result type is InstalledAppListResult
# Verification: Success = True
# Verification: Found 76 installed applications on test system

if result.success:
    apps = result.data
    print(f"Found {len(apps)} installed applications")
    # Output: Found 76 installed applications
    
    for app in apps[:5]:
        print(f"Name: {app.name}")
        print(f"Start Command: {app.start_cmd}")
        print(f"Stop Command: {app.stop_cmd if app.stop_cmd else 'N/A'}")
        print(f"Work Directory: {app.work_directory if app.work_directory else 'N/A'}")
        print("---")
    # Output example:
    # Name: AptURL
    # Start Command: apturl %u
    # Stop Command: N/A
    # Work Directory: N/A
    # ---
    # Name: Bluetooth Transfer
    # Start Command: bluetooth-sendto
    # Stop Command: N/A
    # Work Directory: N/A
    # ---
else:
    print(f"Error: {result.error_message}")
```

**Parameters:**
- `start_menu` (bool): Whether to include start menu applications
- `desktop` (bool): Whether to include desktop applications
- `ignore_system_apps` (bool): Whether to filter out system applications

**Returns:**
- `InstalledAppListResult` containing a list of `InstalledApp` objects

<a id="starting-applications"></a>
## 🚀 Starting Applications

Launch desktop applications using their start commands:

### Method 1: Start by Command

```python
start_cmd = "/usr/bin/google-chrome-stable"

result = session.computer.start_app(start_cmd)

# Verification: Result type is ProcessListResult
# Verification: Success = True
# Verification: Started 6 processes (chrome main process + helper processes)

if result.success:
    processes = result.data
    print(f"Application started with {len(processes)} processes")
    # Output: Application started with 6 processes
    
    for process in processes:
        print(f"Process: {process.pname} (PID: {process.pid})")
    # Output example:
    # Process: chrome (PID: 4443)
    # Process: cat (PID: 4448)
    # Process: cat (PID: 4449)
    # Process: chrome (PID: 4459)
    # Process: chrome (PID: 4460)
    # Process: chrome (PID: 4462)
else:
    print(f"Failed to start application: {result.error_message}")
```

### Method 2: Start with Working Directory

```python
start_cmd = "/usr/bin/google-chrome-stable"
work_directory = "/tmp"

result = session.computer.start_app(
    start_cmd=start_cmd,
    work_directory=work_directory
)

# Verification: Result type is ProcessListResult
# Verification: Success = True
# Verification: Application starts in the specified working directory

if result.success:
    processes = result.data
    print(f"Application started with {len(processes)} processes")
    # Output: Application started with 6 processes
else:
    print(f"Failed to start application: {result.error_message}")
```

### Method 3: Start from Installed Apps List

```python
result = session.computer.get_installed_apps(
    start_menu=True,
    desktop=False,
    ignore_system_apps=True
)

# Verification: Successfully retrieves installed apps list

if result.success:
    apps = result.data
    
    target_app = None
    for app in apps:
        if "chrome" in app.name.lower():
            target_app = app
            break
    
    # Verification: Found "Google Chrome" in the apps list
    
    if target_app:
        print(f"Starting {target_app.name}...")
        # Output: Starting Google Chrome...
        
        start_result = session.computer.start_app(target_app.start_cmd)
        
        # Verification: Successfully started the application
        
        if start_result.success:
            print("Application started successfully!")
            # Output: Application started successfully!
        else:
            print(f"Failed to start: {start_result.error_message}")
    else:
        print("Target application not found")
```

<a id="stopping-applications"></a>
## 🛑 Stopping Applications

Stop running applications using process ID, process name, or stop command:

### Method 1: Stop by Process ID (PID)

```python
start_result = session.computer.start_app("/usr/bin/google-chrome-stable")

# Verification: Application started successfully with multiple processes

if start_result.success:
    target_pid = None
    for process in start_result.data:
        print(f"Process: {process.pname} (PID: {process.pid})")
        # Output example:
        # Process: chrome (PID: 6378)
        # Process: cat (PID: 6383)
        # Process: cat (PID: 6384)
        
        if 'chrome' in process.pname.lower():
            target_pid = process.pid
            break
    
    if target_pid:
        result = session.computer.stop_app_by_pid(target_pid)
        
        # Verification: Result type is AppOperationResult
        # Verification: Success = True
        
        if result.success:
            print(f"Successfully stopped process {target_pid}")
            # Output: Successfully stopped process 6378
        else:
            print(f"Failed to stop process: {result.error_message}")
```

### Method 2: Stop by Process Name

```python
start_result = session.computer.start_app("/usr/bin/google-chrome-stable")

# Verification: Application started successfully

if start_result.success:
    target_pname = None
    for process in start_result.data:
        print(f"Process: {process.pname} (PID: {process.pid})")
        target_pname = process.pname
        break
    
    # Verification: Retrieved process name "chrome"
    
    if target_pname:
        result = session.computer.stop_app_by_pname(target_pname)
        
        # Verification: Result type is AppOperationResult
        # Verification: Success = True
        
        if result.success:
            print(f"Successfully stopped process {target_pname}")
            # Output: Successfully stopped process chrome
        else:
            print(f"Failed to stop process: {result.error_message}")
```

### Method 3: Stop by Stop Command

```python
result = session.computer.get_installed_apps(
    start_menu=True,
    desktop=False,
    ignore_system_apps=True
)

# Verification: Successfully retrieved installed apps

if result.success:
    apps = result.data
    
    target_app = None
    for app in apps:
        if app.stop_cmd:
            target_app = app
            break
    
    # Note: Most desktop apps on Linux don't have stop_cmd defined
    # This is normal - use stop_app_by_pid or stop_app_by_pname instead
    
    if target_app:
        start_result = session.computer.start_app(target_app.start_cmd)
        
        if start_result.success:
            print("Application started successfully!")
            
            result = session.computer.stop_app_by_cmd(target_app.stop_cmd)
            
            # Verification: Result type is AppOperationResult
            
            if result.success:
                print("Successfully stopped application using command")
            else:
                print(f"Failed to stop application: {result.error_message}")
```

<a id="listing-running-applications"></a>
## 📊 Listing Running Applications

Monitor currently running applications with visible windows:

```python
result = session.computer.list_visible_apps()

# Verification: Result type is ProcessListResult
# Verification: Success = True
# Verification: Found 1 visible application (chrome with visible window)

if result.success:
    visible_apps = result.data
    print(f"Found {len(visible_apps)} running applications")
    # Output: Found 1 running applications
    
    for app in visible_apps:
        print(f"Process: {app.pname}")
        print(f"PID: {app.pid}")
        print(f"Command: {app.cmdline}")
        print("---")
    # Output example:
    # Process: chrome
    # PID: 6378
    # Command: /opt/google/chrome/chrome
    # ---
else:
    print(f"Error: {result.error_message}")
```

**Process Object Properties:**
- `pname` (str): Process name
- `pid` (int): Process ID
- `cmdline` (str): Full command line used to start the process

<a id="complete-workflow-example"></a>
## 🔄 Complete Workflow Example

Complete example showing how to find, launch, and control a desktop application:

```python
import os
import time
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams

api_key = os.getenv("AGENTBAY_API_KEY")
if not api_key:
    raise ValueError("AGENTBAY_API_KEY environment variable is required")

agent_bay = AgentBay(api_key=api_key)

params = CreateSessionParams(image_id="linux_latest")
result = agent_bay.create(params)

if not result.success:
    print(f"Failed to create session: {result.error_message}")
    exit(1)

session = result.session
print(f"Session created: {session.session_id}")
# Output: Session created: session-xxxxxxxxxxxxxxxxx

print("Step 1: Finding installed applications...")
apps_result = session.computer.get_installed_apps(
    start_menu=True,
    desktop=False,
    ignore_system_apps=True
)

# Verification: Successfully retrieved 76 applications

if not apps_result.success:
    print(f"Failed to get apps: {apps_result.error_message}")
    agent_bay.delete(session)
    exit(1)

target_app = None
for app in apps_result.data:
    if "chrome" in app.name.lower():
        target_app = app
        break

# Verification: Found "Google Chrome" application

if not target_app:
    print("Google Chrome not found")
    agent_bay.delete(session)
    exit(1)

print(f"Found application: {target_app.name}")
# Output: Found application: Google Chrome

print("Step 2: Launching application...")
start_result = session.computer.start_app(target_app.start_cmd)

# Verification: Successfully started with 6 processes

if not start_result.success:
    print(f"Failed to start app: {start_result.error_message}")
    agent_bay.delete(session)
    exit(1)

print(f"Application started with {len(start_result.data)} processes")
# Output: Application started with 6 processes

for process in start_result.data:
    print(f"  - {process.pname} (PID: {process.pid})")
# Output example:
#   - chrome (PID: 6420)
#   - cat (PID: 6425)
#   - cat (PID: 6426)
#   - chrome (PID: 6436)
#   - chrome (PID: 6437)
#   - chrome (PID: 6439)

print("Step 3: Waiting for application to load...")
time.sleep(5)

print("Step 4: Checking running applications...")
visible_result = session.computer.list_visible_apps()

# Verification: Found 1 visible application

if visible_result.success:
    print(f"Found {len(visible_result.data)} visible applications")
    # Output: Found 1 visible applications

print("Step 5: Stopping application...")
if start_result.data:
    stop_result = session.computer.stop_app_by_pid(start_result.data[0].pid)
    
    # Verification: Successfully stopped the application
    
    if stop_result.success:
        print("Application stopped successfully")
        # Output: Application stopped successfully
    else:
        print(f"Failed to stop application: {stop_result.error_message}")

print("Cleaning up session...")
agent_bay.delete(session)
print("Workflow completed!")
# Output: Workflow completed!

# === Complete Workflow Verification Results ===
# ✓ Session creation: Success
# ✓ Get installed apps: 76 applications found
# ✓ Find target app: Google Chrome found
# ✓ Start application: 6 processes started
# ✓ List visible apps: 1 visible application
# ✓ Stop application: Successfully stopped
# ✓ Session cleanup: Success
```

<a id="api-reference"></a>
## 📚 API Reference

### Computer Application Management Methods

All application management methods are accessed through `session.computer.*`:

| Method | Parameters | Returns | Description |
|--------|------------|---------|-------------|
| `get_installed_apps()` | `start_menu: bool = True`<br/>`desktop: bool = False`<br/>`ignore_system_apps: bool = True` | `InstalledAppListResult` | Get list of installed applications |
| `start_app()` | `start_cmd: str`<br/>`work_directory: str = ""`<br/>`activity: str = ""` | `ProcessListResult` | Start an application |
| `stop_app_by_pid()` | `pid: int` | `AppOperationResult` | Stop application by process ID |
| `stop_app_by_pname()` | `pname: str` | `AppOperationResult` | Stop application by process name |
| `stop_app_by_cmd()` | `stop_cmd: str` | `AppOperationResult` | Stop application by stop command |
| `list_visible_apps()` | None | `ProcessListResult` | List currently visible applications |

### Return Types

**InstalledAppListResult**
- `success` (bool): Whether the operation succeeded
- `data` (List[InstalledApp]): List of installed applications
- `error_message` (str): Error message if operation failed
- `request_id` (str): Unique request identifier

**InstalledApp**
- `name` (str): Application name
- `start_cmd` (str): Command to start the application
- `stop_cmd` (Optional[str]): Command to stop the application
- `work_directory` (Optional[str]): Working directory for the application

**ProcessListResult**
- `success` (bool): Whether the operation succeeded
- `data` (List[Process]): List of process objects
- `error_message` (str): Error message if operation failed
- `request_id` (str): Unique request identifier

**Process**
- `pname` (str): Process name
- `pid` (int): Process ID
- `cmdline` (Optional[str]): Full command line

**AppOperationResult**
- `success` (bool): Whether the operation succeeded
- `error_message` (str): Error message if operation failed
- `request_id` (str): Unique request identifier

## 🎯 Summary

This guide covered desktop application management capabilities:

- **Application Discovery**: Find installed desktop applications
- **Application Lifecycle**: Start and stop applications reliably
- **Process Monitoring**: Track running processes
- **Desktop Automation**: Build automated desktop workflows

These features enable you to build sophisticated desktop automation solutions for testing, workflow automation, and remote desktop management scenarios using AgentBay SDK's Computer Use capabilities.

## 📚 Related Guides

- [Computer UI Automation](computer-ui-automation.md) - Mouse and keyboard automation
- [Window Management](window-management.md) - Window control and positioning
- [Session Management](../common-features/basics/session-management.md) - Session lifecycle and configuration
- [Command Execution](../common-features/basics/command-execution.md) - Execute shell commands

## 🆘 Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Documentation Home](../README.md)




# Computer UI Automation Guide

This guide covers computer UI automation capabilities in AgentBay SDK for desktop environments, including mouse operations, keyboard operations, and screen operations.

**Verified System Images:** These features have been verified to work with `windows_latest` and `linux_latest` system images.

## 📋 Table of Contents

- [Overview](#overview)
- [Prerequisites](#prerequisites)
- [Mouse Operations](#mouse-operations)
- [Keyboard Operations](#keyboard-operations)
- [Screen Operations](#screen-operations)
- [Troubleshooting](#troubleshooting)

<a id="overview"></a>
## 🎯 Overview

AgentBay provides powerful computer UI automation capabilities for interacting with Windows desktop environments in the cloud. You can:

1. **Mouse Operations** - Click, move, drag, and scroll with precise control
2. **Keyboard Operations** - Type text and send key combinations
3. **Screen Operations** - Capture screenshots and get screen information

All operations are performed through the `session.computer` module, which provides a comprehensive API for desktop automation tasks.

<a id="prerequisites"></a>
## ⚙️ Prerequisites

Computer UI automation requires creating a session with a computer use system image:

```python
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams

agent_bay = AgentBay()
# Use windows_latest or linux_latest
session_params = CreateSessionParams(image_id="windows_latest")
session = agent_bay.create(session_params).session
```

<a id="mouse-operations"></a>
## 🖱️ Mouse Operations

### Click Operations

The `click_mouse()` method supports multiple click types. You can use the `MouseButton` enum for type safety:

```python
from agentbay.computer import MouseButton

session_params = CreateSessionParams(image_id="windows_latest")
session = agent_bay.create(session_params).session

# Left click
result = session.computer.click_mouse(x=500, y=300, button=MouseButton.LEFT)
if result.success:
    print("Left click successful")
# Output: Left click successful

# Right click
result = session.computer.click_mouse(x=500, y=300, button=MouseButton.RIGHT)
if result.success:
    print("Right click successful")
# Output: Right click successful

# Middle click
result = session.computer.click_mouse(x=500, y=300, button=MouseButton.MIDDLE)
if result.success:
    print("Middle click successful")
# Output: Middle click successful

# Double left click
result = session.computer.click_mouse(x=500, y=300, button=MouseButton.DOUBLE_LEFT)
if result.success:
    print("Double click successful")
# Output: Double click successful

agent_bay.delete(session)
```

**Supported button types:** `MouseButton.LEFT`, `MouseButton.RIGHT`, `MouseButton.MIDDLE`, `MouseButton.DOUBLE_LEFT`

### Move Mouse

Move the mouse cursor to specific coordinates:

```python
session_params = CreateSessionParams(image_id="windows_latest")
session = agent_bay.create(session_params).session

result = session.computer.move_mouse(x=600, y=400)
if result.success:
    print("Mouse moved successfully")
# Output: Mouse moved successfully

agent_bay.delete(session)
```

### Drag Operations

Drag the mouse from one point to another using the `MouseButton` enum:

```python
from agentbay.computer import MouseButton

session_params = CreateSessionParams(image_id="windows_latest")
session = agent_bay.create(session_params).session

# Drag with left button
result = session.computer.drag_mouse(
    from_x=100, 
    from_y=100, 
    to_x=200, 
    to_y=200, 
    button=MouseButton.LEFT
)
if result.success:
    print("Drag operation successful")
# Output: Drag operation successful

agent_bay.delete(session)
```

**Supported button types for drag:** `MouseButton.LEFT`, `MouseButton.RIGHT`, `MouseButton.MIDDLE`

### Scroll Operations

Scroll the mouse wheel at specific coordinates using the `ScrollDirection` enum:

```python
from agentbay.computer import ScrollDirection

session_params = CreateSessionParams(image_id="windows_latest")
session = agent_bay.create(session_params).session

# Scroll up
result = session.computer.scroll(x=500, y=500, direction=ScrollDirection.UP, amount=3)
if result.success:
    print("Scrolled up successfully")
# Output: Scrolled up successfully

# Scroll down
result = session.computer.scroll(x=500, y=500, direction=ScrollDirection.DOWN, amount=5)
if result.success:
    print("Scrolled down successfully")
# Output: Scrolled down successfully

agent_bay.delete(session)
```

**Supported directions:** `ScrollDirection.UP`, `ScrollDirection.DOWN`, `ScrollDirection.LEFT`, `ScrollDirection.RIGHT`

### Get Cursor Position

Retrieve the current mouse cursor position:

```python
import json

session_params = CreateSessionParams(image_id="windows_latest")
session = agent_bay.create(session_params).session

result = session.computer.get_cursor_position()
if result.success:
    cursor_data = json.loads(result.data)
    print(f"Cursor at x={cursor_data['x']}, y={cursor_data['y']}")
# Output: Cursor at x=512, y=384

agent_bay.delete(session)
```

<a id="keyboard-operations"></a>
## ⌨️ Keyboard Operations

### Text Input

Type text into the active window or field:

```python
session_params = CreateSessionParams(image_id="windows_latest")
session = agent_bay.create(session_params).session

result = session.computer.input_text("Hello AgentBay!")
if result.success:
    print("Text input successful")
# Output: Text input successful

agent_bay.delete(session)
```

### Press Keys

Press key combinations (supports modifier keys):

```python
session_params = CreateSessionParams(image_id="windows_latest")
session = agent_bay.create(session_params).session

# Press Ctrl+A to select all
result = session.computer.press_keys(keys=["Ctrl", "a"])
if result.success:
    print("Keys pressed successfully")
# Output: Keys pressed successfully

# Press Ctrl+C to copy
result = session.computer.press_keys(keys=["Ctrl", "c"])
if result.success:
    print("Copy command sent")
# Output: Copy command sent

agent_bay.delete(session)
```

### Release Keys

Release specific keys (useful when keys are held):

```python
session_params = CreateSessionParams(image_id="windows_latest")
session = agent_bay.create(session_params).session

# Hold Ctrl key
session.computer.press_keys(keys=["Ctrl"], hold=True)

# ... perform other operations ...

# Release Ctrl key
result = session.computer.release_keys(keys=["Ctrl"])
if result.success:
    print("Keys released successfully")
# Output: Keys released successfully

agent_bay.delete(session)
```

<a id="screen-operations"></a>
## 📸 Screen Operations

### Take Screenshot

Capture a screenshot of the current screen. The screenshot is saved to cloud storage and a download URL is returned:

```python
session_params = CreateSessionParams(image_id="windows_latest")
session = agent_bay.create(session_params).session

result = session.computer.screenshot()
if result.success:
    screenshot_url = result.data
    print(f"Screenshot URL: {screenshot_url}")
# Output: Screenshot URL: https://***.***.aliyuncs.com/***/screenshot_1234567890.png?***

agent_bay.delete(session)
```

### Get Screen Size

Retrieve screen dimensions and DPI scaling factor:

```python
import json

session_params = CreateSessionParams(image_id="windows_latest")
session = agent_bay.create(session_params).session

result = session.computer.get_screen_size()
if result.success:
    screen_data = json.loads(result.data)
    print(f"Screen width: {screen_data['width']}")
    print(f"Screen height: {screen_data['height']}")
    print(f"DPI scaling factor: {screen_data['dpiScalingFactor']}")
# Output: Screen width: 1024
# Output: Screen height: 768
# Output: DPI scaling factor: 1.0

agent_bay.delete(session)
```

<a id="troubleshooting"></a>
## 🆘 Troubleshooting

### Common Issues

1. **"Tool not found" errors**
   - Ensure you're using a computer use image (`windows_latest` or `linux_latest`)

3. **Screenshot URL handling**
   - The screenshot is saved to cloud storage (OSS)
   - `result.data` contains a download URL, not the image data
   - Use the URL to download the screenshot if needed

### Getting Help

For more assistance:
- Review [Session Management Guide](../common-features/basics/session-management.md)

## 📚 Related Guides

- [Session Management Guide](../common-features/basics/session-management.md) - Learn about session lifecycle
- [Computer Application Management](computer-application-management.md) - Manage applications
- [Window Management](window-management.md) - Manage windows
- [Command Execution](../common-features/basics/command-execution.md) - Execute shell commands
- [Mobile UI Automation](../mobile-use/mobile-ui-automation.md) - Mobile device automation




# Window Management for Computer Use

This guide covers window management capabilities for desktop environments (Windows/Linux) using the AgentBay SDK. Learn how to control window states, positions, focus, and interact with desktop windows in cloud environments.

## 📋 Table of Contents

- [Overview](#overview)
- [Prerequisites](#prerequisites)
- [Listing Windows](#listing-windows)
- [Window Control Operations](#window-control-operations)
- [Focus Management](#focus-management)
- [Getting Active Window](#getting-active-window)
- [Complete Workflow Example](#complete-workflow-example)
- [API Reference](#api-reference)

<a id="overview"></a>
## 🎯 Overview

The Computer Use module provides comprehensive window management capabilities for desktop environments:

1. **Window Discovery** - List and find windows in the system
2. **Window State Control** - Maximize, minimize, restore, and close windows
3. **Window Positioning** - Resize and reposition windows
4. **Focus Management** - Control window focus and activation
5. **Desktop Automation** - Build complex desktop automation workflows

These features have been verified with `windows_latest` and `linux_latest` system images.

<a id="prerequisites"></a>
## 📦 Prerequisites

First, create a session with a desktop environment:

```python
import os
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams

api_key = os.getenv("AGENTBAY_API_KEY")
if not api_key:
    raise ValueError("AGENTBAY_API_KEY environment variable is required")

agent_bay = AgentBay(api_key=api_key)

params = CreateSessionParams(image_id="linux_latest")
result = agent_bay.create(params)

if result.success:
    session = result.session
    print(f"Session created: {session.session_id}")
else:
    print(f"Failed to create session: {result.error_message}")
    exit(1)
```

<a id="listing-windows"></a>
## 🔍 Listing Windows

Get information about all available windows in the desktop environment:

```python
result = session.computer.list_root_windows(timeout_ms=5000)

if result.success:
    windows = result.windows
    print(f"Found {len(windows)} windows")
    # Execution result: Found 0 windows (when no windows are open)
    # or: Found 5 windows (when applications are running)
    
    for window in windows:
        print(f"Title: {window.title}")
        # Execution result: Title: Google Chrome
        print(f"Window ID: {window.window_id}")
        # Execution result: Window ID: 12345678
        print(f"Process: {window.pname if window.pname else 'N/A'}")
        # Execution result: Process: chrome
        print(f"PID: {window.pid if window.pid else 'N/A'}")
        # Execution result: PID: 9876
        print(f"Position: ({window.absolute_upper_left_x}, {window.absolute_upper_left_y})")
        # Execution result: Position: (100, 50)
        print(f"Size: {window.width}x{window.height}")
        # Execution result: Size: 1280x720
        print(f"Child Windows: {len(window.child_windows)}")
        # Execution result: Child Windows: 0
        print("---")
else:
    print(f"Error listing windows: {result.error_message}")
```

**Parameters:**
- `timeout_ms` (int, optional): Timeout in milliseconds. Defaults to 3000.

**Window Object Properties:**
- `window_id` (int): Unique identifier for the window
- `title` (str): Window title/caption
- `absolute_upper_left_x` (Optional[int]): X-coordinate of window's upper-left corner
- `absolute_upper_left_y` (Optional[int]): Y-coordinate of window's upper-left corner
- `width` (Optional[int]): Window width in pixels
- `height` (Optional[int]): Window height in pixels
- `pid` (Optional[int]): Process ID that owns the window
- `pname` (Optional[str]): Process name that owns the window
- `child_windows` (List[Window]): List of child windows

<a id="window-control-operations"></a>
## 🎛️ Window Control Operations

Control window states and positions:

### Activate Window

```python
result = session.computer.list_root_windows()

if result.success and result.windows:
    window_id = result.windows[0].window_id
    
    activate_result = session.computer.activate_window(window_id)
    # Execution result: Window activated successfully
    
    if activate_result.success:
        print("Window activated successfully")
    else:
        print(f"Failed to activate window: {activate_result.error_message}")
```

### Maximize Window

```python
result = session.computer.list_root_windows()

if result.success and result.windows:
    window_id = result.windows[0].window_id
    
    maximize_result = session.computer.maximize_window(window_id)
    # Execution result: Window maximized successfully
    
    if maximize_result.success:
        print("Window maximized successfully")
    else:
        print(f"Failed to maximize window: {maximize_result.error_message}")
```

### Minimize Window

```python
result = session.computer.list_root_windows()

if result.success and result.windows:
    window_id = result.windows[0].window_id
    
    minimize_result = session.computer.minimize_window(window_id)
    # Execution result: Window minimized successfully
    
    if minimize_result.success:
        print("Window minimized successfully")
    else:
        print(f"Failed to minimize window: {minimize_result.error_message}")
```

### Restore Window

```python
result = session.computer.list_root_windows()

if result.success and result.windows:
    window_id = result.windows[0].window_id
    
    restore_result = session.computer.restore_window(window_id)
    # Execution result: Window restored successfully
    
    if restore_result.success:
        print("Window restored successfully")
    else:
        print(f"Failed to restore window: {restore_result.error_message}")
```

### Resize Window

```python
result = session.computer.list_root_windows()

if result.success and result.windows:
    window_id = result.windows[0].window_id
    
    resize_result = session.computer.resize_window(window_id, 800, 600)
    # Execution result: Window resized to 800x600
    
    if resize_result.success:
        print("Window resized to 800x600")
    else:
        print(f"Failed to resize window: {resize_result.error_message}")
```

### Fullscreen Window

```python
result = session.computer.list_root_windows()

if result.success and result.windows:
    window_id = result.windows[0].window_id
    
    fullscreen_result = session.computer.fullscreen_window(window_id)
    # Execution result: Window set to fullscreen
    
    if fullscreen_result.success:
        print("Window set to fullscreen")
    else:
        print(f"Failed to set fullscreen: {fullscreen_result.error_message}")
```

### Close Window

```python
# Note: Use with caution as it permanently closes windows
result = session.computer.list_root_windows()

if result.success and result.windows:
    window_id = result.windows[0].window_id
    
    close_result = session.computer.close_window(window_id)
    
    if close_result.success:
        print("Window closed successfully")
    else:
        print(f"Failed to close window: {close_result.error_message}")
```

### Complete Window Control Function

```python
import time

def control_window(session, window_id):
    print(f"Controlling window ID: {window_id}")
    
    try:
        session.computer.activate_window(window_id)
        print("Window activated")
    except Exception as e:
        print(f"Failed to activate: {e}")
    
    time.sleep(1)
    
    try:
        session.computer.maximize_window(window_id)
        print("Window maximized")
    except Exception as e:
        print(f"Failed to maximize: {e}")
    
    time.sleep(1)
    
    try:
        session.computer.minimize_window(window_id)
        print("Window minimized")
    except Exception as e:
        print(f"Failed to minimize: {e}")
    
    time.sleep(1)
    
    try:
        session.computer.restore_window(window_id)
        print("Window restored")
    except Exception as e:
        print(f"Failed to restore: {e}")
    
    try:
        session.computer.resize_window(window_id, 800, 600)
        print("Window resized to 800x600")
    except Exception as e:
        print(f"Failed to resize: {e}")

windows = session.computer.list_root_windows()
if windows.success and windows.windows:
    control_window(session, windows.windows[0].window_id)
```

<a id="focus-management"></a>
## 🎯 Focus Management

Control system focus behavior to prevent focus stealing:

```python
try:
    session.computer.focus_mode(True)
    # Execution result: Focus mode enabled - windows won't steal focus
    print("Focus mode enabled - windows won't steal focus")
except Exception as e:
    print(f"Failed to enable focus mode: {e}")

try:
    session.computer.focus_mode(False)
    # Execution result: Focus mode disabled
    print("Focus mode disabled")
except Exception as e:
    print(f"Failed to disable focus mode: {e}")
```

**Parameters:**
- `on` (bool): True to enable focus mode, False to disable it

<a id="getting-active-window"></a>
## 🖥️ Getting Active Window

Get information about the currently active window:

```python
# Note: May fail if no window is currently active
result = session.computer.get_active_window(timeout_ms=5000)

if result.success:
    active_window = result.window
    # Execution result when window is active:
    # Active Window:
    #   Title: Google Chrome
    #   Window ID: 87654321
    #   Process: chrome
    #   PID: 4321
    #   Position: (0, 0)
    #   Size: 1920x1080
    print(f"Active Window:")
    print(f"  Title: {active_window.title}")
    print(f"  Window ID: {active_window.window_id}")
    print(f"  Process: {active_window.pname}")
    print(f"  PID: {active_window.pid}")
    print(f"  Position: ({active_window.absolute_upper_left_x}, {active_window.absolute_upper_left_y})")
    print(f"  Size: {active_window.width}x{active_window.height}")
else:
    # Execution result when no window is active:
    # Failed to get active window: Error in response (expected if no window is active)
    print(f"Failed to get active window: {result.error_message}")
```

**Parameters:**
- `timeout_ms` (int, optional): Timeout in milliseconds. Defaults to 3000.

<a id="complete-workflow-example"></a>
## 🔄 Complete Workflow Example

Complete example showing how to launch an application and control its window:

```python
import os
import time
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams

api_key = os.getenv("AGENTBAY_API_KEY")
if not api_key:
    raise ValueError("AGENTBAY_API_KEY environment variable is required")

agent_bay = AgentBay(api_key=api_key)

params = CreateSessionParams(image_id="linux_latest")
result = agent_bay.create(params)

if not result.success:
    print(f"Failed to create session: {result.error_message}")
    exit(1)

session = result.session
print(f"Session created: {session.session_id}")
# Execution result: Session created: session-04bdwfj7u688ec96t

print("Step 1: Finding installed applications...")
apps_result = session.computer.get_installed_apps(
    start_menu=True,
    desktop=False,
    ignore_system_apps=True
)
# Execution result: Found 76 applications

if not apps_result.success:
    print(f"Failed to get apps: {apps_result.error_message}")
    agent_bay.delete(session)
    exit(1)

target_app = None
for app in apps_result.data:
    if "chrome" in app.name.lower():
        target_app = app
        break

if not target_app:
    print("Google Chrome not found")
    agent_bay.delete(session)
    exit(1)

print(f"Found application: {target_app.name}")
# Execution result: Found application: Google Chrome

print("Step 2: Launching application...")
start_result = session.computer.start_app(target_app.start_cmd)

if not start_result.success:
    print(f"Failed to start app: {start_result.error_message}")
    agent_bay.delete(session)
    exit(1)

print(f"Application started with {len(start_result.data)} processes")
# Execution result: Application started with 6 processes

print("Step 3: Waiting for application window to load...")
time.sleep(5)

print("Step 4: Finding application window...")
windows_result = session.computer.list_root_windows()

if not windows_result.success:
    print(f"Failed to list windows: {windows_result.error_message}")
    agent_bay.delete(session)
    exit(1)

app_window = None
for window in windows_result.windows:
    if target_app.name.lower() in window.title.lower():
        app_window = window
        break

if not app_window and windows_result.windows:
    app_window = windows_result.windows[0]
    print("Using first available window")

if app_window:
    print(f"Found window: {app_window.title}")
    # Execution result: Found window: Welcome to Google Chrome
    
    print("Step 5: Controlling the window...")
    try:
        session.computer.activate_window(app_window.window_id)
        print("Window activated")
        # Execution result: Window activated
        
        time.sleep(1)
        session.computer.maximize_window(app_window.window_id)
        print("Window maximized")
        # Execution result: Window maximized
        
        time.sleep(1)
        session.computer.resize_window(app_window.window_id, 1024, 768)
        print("Window resized to 1024x768")
        # Execution result: Window resized to 1024x768
        
    except Exception as e:
        print(f"Window control failed: {e}")

print("Cleaning up session...")
agent_bay.delete(session)
print("Workflow completed!")
# Execution result: Session deleted successfully
```

<a id="api-reference"></a>
## 📚 API Reference

### Window Manager Methods

| Method | Parameters | Returns | Description |
|--------|------------|---------|-------------|
| `list_root_windows()` | `timeout_ms: int = 3000` | `WindowListResult` | List all root windows |
| `get_active_window()` | `timeout_ms: int = 3000` | `WindowInfoResult` | Get currently active window |
| `activate_window()` | `window_id: int` | `BoolResult` | Activate a window |
| `maximize_window()` | `window_id: int` | `BoolResult` | Maximize a window |
| `minimize_window()` | `window_id: int` | `BoolResult` | Minimize a window |
| `restore_window()` | `window_id: int` | `BoolResult` | Restore a window |
| `close_window()` | `window_id: int` | `BoolResult` | Close a window |
| `fullscreen_window()` | `window_id: int` | `BoolResult` | Make window fullscreen |
| `resize_window()` | `window_id: int`<br/>`width: int`<br/>`height: int` | `BoolResult` | Resize a window |
| `focus_mode()` | `on: bool` | `BoolResult` | Toggle focus mode |

### Return Types

**WindowListResult**
- `success` (bool): Whether the operation succeeded
- `windows` (List[Window]): List of window objects
- `error_message` (str): Error message if operation failed
- `request_id` (str): Unique request identifier

**Window**
- `window_id` (int): Unique identifier for the window
- `title` (str): Window title/caption
- `absolute_upper_left_x` (Optional[int]): X-coordinate of upper-left corner
- `absolute_upper_left_y` (Optional[int]): Y-coordinate of upper-left corner
- `width` (Optional[int]): Window width in pixels
- `height` (Optional[int]): Window height in pixels
- `pid` (Optional[int]): Process ID that owns the window
- `pname` (Optional[str]): Process name that owns the window
- `child_windows` (List[Window]): List of child windows

**WindowInfoResult**
- `success` (bool): Whether the operation succeeded
- `window` (Window): Window object
- `error_message` (str): Error message if operation failed
- `request_id` (str): Unique request identifier

**BoolResult**
- `success` (bool): Whether the operation succeeded
- `data` (bool): Operation result data
- `error_message` (str): Error message if operation failed
- `request_id` (str): Unique request identifier

## 🎯 Summary

This guide covered desktop window management capabilities:

- **Window Discovery**: List and find windows in the system
- **Window Control**: Manage window states (maximize, minimize, restore, close)
- **Window Positioning**: Resize and reposition windows
- **Focus Management**: Control window focus and activation

These features enable you to build sophisticated desktop automation solutions that can interact with any application window in cloud environments, making AgentBay SDK's Computer Use module a powerful tool for automated testing, workflow automation, and remote desktop management.

## 📚 Related Guides

- [Computer UI Automation](computer-ui-automation.md) - Mouse and keyboard automation
- [Computer Application Management](computer-application-management.md) - Manage applications
- [Session Management](../common-features/basics/session-management.md) - Session lifecycle and configuration
- [Command Execution](../common-features/basics/command-execution.md) - Execute shell commands

## 🆘 Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Documentation Home](../README.md)




# Mobile Use Guide

Mobile Use is AgentBay's mobile device automation environment for Android devices.

## Documentation

- [Application Management](mobile-application-management.md) - Mobile app lifecycle management
- [UI Automation](mobile-ui-automation.md) - Touch gestures and UI interaction
- [ADB Connection](adb-connection.md) - Connect and control devices via Android Debug Bridge

## Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Main Documentation](../../README.md)




# ADB Connection Guide

This guide explains how to use the `getAdbUrl` method to connect to mobile sessions in AgentBay cloud environment via ADB (Android Debug Bridge).

## Overview

The `getAdbUrl` method provides an ADB connection URL that allows you to use standard ADB commands to interact with mobile sessions running in AgentBay cloud. This enables you to use ADB tools from your local machine to control and debug cloud-based mobile devices.

## Prerequisites

1. **Mobile Session**: A session created with a mobile environment image (e.g., `mobile_latest`)
2. **ADB Tool**: ADB installed on your local machine
3. **API Key**: Valid AgentBay API key

> **Note**: For ADB installation instructions, please refer to the [official Android documentation](https://developer.android.com/studio/command-line/adb).

## Usage Restrictions

⚠️ **Important**: The `getAdbUrl` method is **only available in mobile environments**.

- ✅ **Supported**: Sessions created with mobile environment images (e.g., `mobile_latest`)
- ❌ **Not Supported**: Browser, Linux, or other non-mobile environment images

If you attempt to use this method with a non-mobile session, you will receive an error indicating that the operation is only supported in mobile environments.

## Step-by-Step Guide

### Step 1: Obtain Your ADB Public Key

The `getAdbUrl` method requires your ADB public key for device authentication. You need to provide your actual ADB public key to establish an authorized connection.

**Locate your ADB public key:**

```bash
# ADB public key is typically located at:
# - Linux/macOS: ~/.android/adbkey.pub
# - Windows: %USERPROFILE%\.android\adbkey.pub

# View your ADB public key
cat ~/.android/adbkey.pub
```

Example output:
```
QAAAAI/NTd6RTmNt3enWSGR8iqLQF1/TkNWcMSxmy9vAqQkn6xha/lCkxtiQV4LYJ8nRbCiWIyCaslUCG2dFBcd9nPhhUTHvdMzYjf6DNJH3J0mPmErWrB0tg2BVPZ2eFNG7HnKmi+bztVLBJYx6NS/54Ki5rbWgqNPjRw5riOPtXJsu3KwVS1VMTI8VuBX+Xg401NW3tjrOfybf6fWnqKFpPX+B6dFASm3eIIye5tkhbuG4cNYURLpf10tyv9bssYi0Vdr0GcmTH9yQ0rDVn4L/n2HPa6eLuuX0WYQyj8uD2fKUryunOCbi95k1ZCQMt+ZTZRK+MvaZfly5QA2mNeQ7LURyMDi3g3C6J8Tu+8uzgrwBUPvdSwiTnht4ZyDjGr8JB+lDiDf5LfB52+Npl4wKBiMV2J/aa3FyBgzFEMRKtnRa+r1u2zB6e2LNG8xkDHVF3L7ODeI5QHDkTwz1X9betVss5mV5sALv45nfzOLo4IbAR94eH9jj3j+E8mclHKDqhpkR8KRoh/K4mHQCg+a3Qz3JTaO6ddLqqFN+wCn/7YnHfPfH3HF8m9CXEoPIhFAsWI7H3LH4lZ9AZZqVm3IZJ4UrSbR2pX7a1D4R+Cd7JcantfxmyXrc8K7Ui1/2W9qZkz9cczqnnQTNciqa0i7xITVNFtLGFWfCeEe/wFAds2qn+GKcSwEAAQA= user@hostname
```

**Read the key in Python:**

```python
import os

# Read your ADB public key
adbkey_path = os.path.expanduser('~/.android/adbkey.pub')
with open(adbkey_path, 'r') as f:
    adbkey_pub = f.read().strip()

print(f"ADB key loaded (first 50 chars): {adbkey_pub[:50]}...")
```

> **Important**: You must use your actual ADB public key. Using a test string will result in an "unauthorized" device status, and ADB commands will fail.

### Step 2: Create a Mobile Session

```python
from agentbay import AgentBay

# Initialize AgentBay client
client = AgentBay(api_key="your_api_key")

# Create a mobile session
result = client.create(image_id="mobile_latest")
session = result.session

print(f"Session created: {session.session_id}")
```

### Step 3: Get ADB Connection URL

```python
# Get ADB connection URL using your real ADB public key
adb_result = session.mobile.get_adb_url(adbkey_pub=adbkey_pub)

if adb_result.success:
    print(f"ADB URL: {adb_result.data}")
    print(f"Request ID: {adb_result.request_id}")
else:
    print(f"Error: {adb_result.error_message}")
```

Expected output:
```
ADB URL: adb connect 47.99.76.99:54321
Request ID: 1234567890ABCDEF
```

The returned URL format is: `adb connect <IP>:<Port>`

### Step 4: Connect to the Device via ADB

The returned URL is a complete ADB connect command. Simply copy and execute it:

```python
# The returned URL is already a complete command
# URL format: "adb connect 47.99.76.99:54321"
adb_url = adb_result.data
print(f"Run this command: {adb_url}")
```

Execute the command in your terminal:

```bash
# Copy and run the command from the output
adb connect 47.99.76.99:54321
```

Expected output:
```
connected to 47.99.76.99:54321
```

### Step 5: Verify the Connection

```bash
# List connected devices
adb devices
```

Expected output:
```
List of devices attached
47.99.76.99:54321    device
```

The device status should be `device` (not `offline` or `unauthorized`).

If the device shows as `unauthorized`, you need to use your actual ADB public key (see Step 1).

### Step 6: Use ADB Commands

Once connected, you can use any standard ADB command:

```bash
# Get device information
adb shell getprop ro.product.model
# Output: wuying android14

# List installed packages
adb shell pm list packages
# Output: package:com.android.providers.media.module
#         package:com.android.modulemetadata
#         ...

# Take a screenshot
adb shell screencap -p /sdcard/screenshot.png
adb pull /sdcard/screenshot.png
# Output: /sdcard/screenshot.png: 1 file pulled...

# View real-time logs (press Ctrl+C to stop)
adb logcat

# Install an application
adb install app.apk

# Access device shell
adb shell
# You'll get an interactive shell prompt
```

### Step 7: Disconnect and Cleanup

```bash
# Disconnect from the device
adb disconnect 47.99.76.99:54321
```

```python
# Delete the session when done
session.delete()
print("Session deleted")
```

## Complete Example

Here's a complete Python example that demonstrates the full workflow:

```python
from agentbay import AgentBay
import subprocess
import time

def main():
    # Step 1: Read ADB public key
    import os
    adbkey_path = os.path.expanduser('~/.android/adbkey.pub')
    with open(adbkey_path, 'r') as f:
        adbkey_pub = f.read().strip()
    print(f"ADB key loaded (first 50 chars): {adbkey_pub[:50]}...")
    
    # Initialize client
    client = AgentBay(api_key="your_api_key")
    
    try:
        # Step 2: Create mobile session
        print("\nCreating mobile session...")
        result = client.create(image_id="mobile_latest")
        session = result.session
        print(f"✅ Session created: {session.session_id}")
        
        # Step 3: Get ADB connection URL
        print("\nGetting ADB connection URL...")
        adb_result = session.mobile.get_adb_url(adbkey_pub=adbkey_pub)
        
        if not adb_result.success:
            print(f"❌ Failed: {adb_result.error_message}")
            return
        
        print(f"✅ ADB URL: {adb_result.data}")
        print(f"✅ Request ID: {adb_result.request_id}")
        
        # Step 3: Parse the ADB connect command
        adb_url = adb_result.data  # "adb connect 47.99.76.99:54321"
        # Extract just the address part for later use
        address = adb_url.replace("adb connect ", "")
        
        # Step 4: Connect via ADB
        print(f"\nConnecting to device...")
        print(f"Command: {adb_url}")
        result = subprocess.run(
            ["adb", "connect", address],
            capture_output=True,
            text=True
        )
        print(result.stdout.strip())
        
        # Wait for connection to establish
        time.sleep(2)
        
        # Step 5: Verify connection
        print("\nVerifying connection...")
        print("Command: adb devices")
        result = subprocess.run(
            ["adb", "devices"],
            capture_output=True,
            text=True
        )
        print(result.stdout)
        
        # Check if device is connected
        if "unauthorized" in result.stdout:
            print("❌ Device is unauthorized - check your ADB public key")
            return
        elif address not in result.stdout or "device" not in result.stdout:
            print("❌ Device not connected properly")
            return
        
        print("✅ Device connected successfully!")
        
        # Step 6: Now you can use ADB commands
        print("\nYou can now use ADB commands:")
        print(f"  adb -s {address} shell getprop ro.product.model")
        print(f"  adb -s {address} shell pm list packages")
        print(f"  adb -s {address} shell screencap -p /sdcard/screenshot.png")
        
        # Example: Get device model
        print("\nExample - Getting device model...")
        result = subprocess.run(
            ["adb", "-s", address, "shell", "getprop", "ro.product.model"],
            capture_output=True,
            text=True
        )
        print(f"Device model: {result.stdout.strip()}")
        
        # Step 7: Disconnect
        print(f"\nDisconnecting from {address}...")
        subprocess.run(["adb", "disconnect", address])
        print("✅ Disconnected")
        
    except Exception as e:
        print(f"❌ Error: {e}")
    
    finally:
        # Cleanup
        print("\nCleaning up session...")
        session.delete()
        print("✅ Session deleted")

if __name__ == "__main__":
    main()
```

## Error Handling

### Check ADB Key File

```python
import os

adbkey_path = os.path.expanduser('~/.android/adbkey.pub')
if not os.path.exists(adbkey_path):
    print(f"Error: ADB public key not found at {adbkey_path}")
    exit(1)
```

### Check getAdbUrl Result

```python
result = session.mobile.get_adb_url(adbkey_pub)

if not result.success:
    print(f"Error: {result.error_message}")
    exit(1)
```

### Verify ADB Connection

After connecting, verify the device status:

```bash
adb devices
```

Check the output:
- ✅ `device` - Connected and authorized
- ❌ `unauthorized` - ADB public key is incorrect
- ❌ `offline` - Connection issue

## Troubleshooting

### Device Shows as Unauthorized

If the device shows as "unauthorized" when running `adb devices`:

```
List of devices attached
47.99.76.99:54321	unauthorized
```

**Cause**: You are not using your actual ADB public key.

**Solution**: 
1. Locate your ADB public key: `~/.android/adbkey.pub` (Linux/macOS) or `%USERPROFILE%\.android\adbkey.pub` (Windows)
2. Read the entire content of the file
3. Pass the complete key string to `get_adb_url()`

```python
import os
adbkey_path = os.path.expanduser('~/.android/adbkey.pub')
with open(adbkey_path, 'r') as f:
    adbkey_pub = f.read().strip()  # Read the entire key

result = session.mobile.get_adb_url(adbkey_pub=adbkey_pub)
```

### Connection Refused

If you get "connection refused" errors:

```bash
# Restart ADB server
adb kill-server
adb start-server

# Try connecting again
adb connect <IP>:<Port>
```

### Device Shows as Offline

If the device appears as "offline":

```bash
# Disconnect and reconnect
adb disconnect <IP>:<Port>
adb connect <IP>:<Port>
```

### Multiple Devices Connected

If you have multiple devices, specify the device for each command:

```bash
# Use -s flag to specify device
adb -s <IP>:<Port> shell getprop
adb -s <IP>:<Port> install app.apk
```

### Cannot Find ADB Command

If `adb` command is not found:

```bash
# Check if ADB is installed
which adb

# If not installed, refer to Android documentation for installation
```

## API Documentation

For detailed API documentation in other languages:

- **Python**: [Mobile API Documentation](../../../python/docs/api/mobile-use/mobile.md#getadburl)
- **Golang**: [Mobile API Documentation](../../../golang/docs/api/mobile-use/mobile.md#getadburl)
- **TypeScript**: [Mobile API Documentation](../../../typescript/docs/api/mobile-use/mobile.md#getadburl)

## Example Code

Complete working examples for all languages:

- **Python**: [mobile_get_adb_url_example.py](../../../python/docs/examples/mobile-use/mobile_get_adb_url_example.py)
- **Golang**: [mobile_get_adb_url Example](../../../golang/docs/examples/mobile-use/mobile_get_adb_url/README.md)
- **TypeScript**: [mobile-get-adb-url Example](../../../typescript/docs/examples/mobile-use/mobile-get-adb-url/README.md)

## Related Guides

- [Mobile UI Automation](./mobile-ui-automation.md) - Touch gestures and UI interaction
- [Mobile Application Management](./mobile-application-management.md) - App lifecycle management
- [Session Management](../common-features/basics/session-management.md) - Session creation and management

## Summary

The ADB connection feature enables you to:

1. ✅ Connect to cloud-based mobile sessions from your local machine
2. ✅ Use standard ADB commands to control the device
3. ✅ Integrate with existing ADB-based tools and workflows
4. ✅ Debug and test mobile applications remotely

**Key Points:**
- Only works with `mobile_latest` sessions
- The `adbkey_pub` parameter is not validated (can use any string)
- Returns URL in format: `adb connect <IP>:<Port>`
- Always verify connection with `adb devices` before running commands
- Remember to disconnect and delete the session when done




# Application Management for Mobile Use

This guide covers application management capabilities for mobile devices (Android) using the AgentBay SDK. Learn how to launch, monitor, and control mobile applications in cloud environments.

## 📋 Table of Contents

- [Overview](#overview)
- [Prerequisites](#prerequisites)
- [Getting Installed Applications](#getting-installed-applications)
- [Starting Applications](#starting-applications)
- [Stopping Applications](#stopping-applications)
- [Complete Workflow Example](#complete-workflow-example)
- [API Reference](#api-reference)

<a id="overview"></a>
## 🎯 Overview

The Mobile Use module provides application management capabilities for Android mobile devices:

1. **Application Discovery** - Query installed applications on the device
2. **Application Lifecycle** - Start and stop mobile applications using package names
3. **Activity Management** - Launch specific Android activities
4. **Process Monitoring** - Track running applications and their processes

**Note:** This guide has been verified with the `mobile_latest` system image. These features should also work with other mobile system images.

<a id="prerequisites"></a>
## 📦 Prerequisites

First, create a session with a mobile environment:

```python
import os
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams

api_key = os.getenv("AGENTBAY_API_KEY")
if not api_key:
    raise ValueError("AGENTBAY_API_KEY environment variable is required")

agent_bay = AgentBay(api_key=api_key)

params = CreateSessionParams(image_id="mobile_latest")
result = agent_bay.create(params)

if result.success:
    session = result.session
    print(f"Session created: {session.session_id}")
else:
    print(f"Failed to create session: {result.error_message}")
    exit(1)

# Actual output:
# Session created: session-04bdw8o39c9uiwet4
```

<a id="getting-installed-applications"></a>
## 🔍 Getting Installed Applications

Query the list of installed applications on the mobile device:

```python
result = session.mobile.get_installed_apps(
    start_menu=True,
    desktop=False,
    ignore_system_apps=True
)

if result.success:
    apps = result.data
    print(f"Found {len(apps)} installed applications")
    
    for app in apps[:5]:
        print(f"Name: {app.name}")
        print(f"Start Command: {app.start_cmd}")
        print(f"Stop Command: {app.stop_cmd if app.stop_cmd else 'N/A'}")
        print(f"Work Directory: {app.work_directory if app.work_directory else 'N/A'}")
        print("---")
else:
    print(f"Error: {result.error_message}")

# Actual output (with current mobile_latest image):
# Found 0 installed applications
```

**Parameters:**
- `start_menu` (bool): Whether to include start menu applications
- `desktop` (bool): Whether to include desktop applications
- `ignore_system_apps` (bool): Whether to filter out system applications

**Returns:**
- `InstalledAppListResult` containing a list of `InstalledApp` objects

**Note:** The current `mobile_latest` image does not include pre-installed applications in the listing, so this method returns an empty list. However, you can still launch applications using their package names (see below).

<a id="starting-applications"></a>
## 🚀 Starting Applications

Launch mobile applications using the "monkey -p" command format with package names:

### Start by Package Name

```python
# Use "monkey -p" format for Android package names
start_cmd = "monkey -p com.android.settings"

result = session.mobile.start_app(start_cmd)

if result.success:
    processes = result.data
    print(f"Application started with {len(processes)} processes")
    
    for process in processes:
        print(f"Process: {process.pname} (PID: {process.pid})")
else:
    print(f"Failed to start application: {result.error_message}")

# Actual output:
# Application started with 1 processes
# Process: com.android.settings (PID: 2805)
```

**Important Notes:**
- **Command Format**: Always use `"monkey -p <package_name>"` format for starting apps
- **Package Names**: Common Android package names:
  - Settings: `com.android.settings`
  - Chrome: `com.android.chrome`
  - Calculator: `com.android.calculator2`
  - Contacts: `com.android.contacts`

### Start with Specific Activity (Android)

```python
start_cmd = "monkey -p com.android.settings"
activity = ".Settings"

result = session.mobile.start_app(
    start_cmd=start_cmd,
    activity=activity
)

if result.success:
    processes = result.data
    print(f"Application started with activity {activity}")
    print(f"Found {len(processes)} processes")
    
    for process in processes:
        print(f"Process: {process.pname} (PID: {process.pid})")
else:
    print(f"Failed to start application: {result.error_message}")

# Actual output:
# Application started with activity .Settings
# Found 1 processes
# Process: com.android.settings (PID: 2921)
```

**Note:** The `activity` parameter allows you to launch a specific activity within an app. Activities can be specified as:
- Relative name: `".SettingsActivity"`
- Full name: `"com.package/.Activity"`

Common activity examples:
- Settings: `com.android.settings` with activity `.Settings`
- Browser: `com.android.chrome` with activity `com.google.android.apps.chrome.Main`
- Calculator: `com.android.calculator2` with activity `.Calculator`

<a id="stopping-applications"></a>
## 🛑 Stopping Applications

Stop running mobile applications using the stop command:

```python
# Start an application
start_result = session.mobile.start_app("monkey -p com.android.settings")

if start_result.success:
    print("Application started successfully")
    for process in start_result.data:
        print(f"  Process: {process.pname} (PID: {process.pid})")
    
    # Stop the application using package name
    result = session.mobile.stop_app_by_cmd("com.android.settings")
    
    if result.success:
        print("Successfully stopped application")
    else:
        print(f"Failed to stop application: {result.error_message}")

# Actual output:
# Application started successfully
#   Process: com.android.settings (PID: 3042)
# Successfully stopped application
```

**Note:** The `stop_cmd` parameter should be the package name (e.g., `"com.android.settings"`).

<a id="complete-workflow-example"></a>
## 🔄 Complete Workflow Example

Complete example showing how to launch and control a mobile application:

```python
import os
import time
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams

api_key = os.getenv("AGENTBAY_API_KEY")
if not api_key:
    raise ValueError("AGENTBAY_API_KEY environment variable is required")

agent_bay = AgentBay(api_key=api_key)

# Create mobile session
params = CreateSessionParams(image_id="mobile_latest")
result = agent_bay.create(params)

if not result.success:
    print(f"Failed to create session: {result.error_message}")
    exit(1)

session = result.session
print(f"Session created: {session.session_id}")

# Step 1: Launching application
print("Step 1: Launching Settings application...")
start_result = session.mobile.start_app("monkey -p com.android.settings")

if not start_result.success:
    print(f"Failed to start app: {start_result.error_message}")
    agent_bay.delete(session)
    exit(1)

print(f"Application started with {len(start_result.data)} processes")
for process in start_result.data:
    print(f"  - {process.pname} (PID: {process.pid})")

# Step 2: Waiting for application to load
print("Step 2: Waiting for application to load...")
time.sleep(3)

# Step 3: Stopping application
print("Step 3: Stopping application...")
stop_result = session.mobile.stop_app_by_cmd("com.android.settings")
if stop_result.success:
    print("Application stopped successfully")
else:
    print(f"Failed to stop application: {stop_result.error_message}")

# Cleanup
print("Cleaning up session...")
agent_bay.delete(session)
print("Workflow completed!")

# Actual output:
# Session created: session-04bdwfj7tnhfnzibx
# Step 1: Launching Settings application...
# Application started with 1 processes
#   - com.android.settings (PID: 3268)
# Step 2: Waiting for application to load...
# Step 3: Stopping application...
# Application stopped successfully
# Cleaning up session...
# Workflow completed!
```

<a id="api-reference"></a>
## 📚 API Reference

### Mobile Manager Methods

| Method | Parameters | Returns | Description |
|--------|------------|---------|-------------|
| `get_installed_apps()` | `start_menu: bool`<br/>`desktop: bool`<br/>`ignore_system_apps: bool` | `InstalledAppListResult` | Get list of installed applications |
| `start_app()` | `start_cmd: str`<br/>`work_directory: str = ""`<br/>`activity: str = ""` | `ProcessListResult` | Start a mobile application |
| `stop_app_by_cmd()` | `stop_cmd: str` | `AppOperationResult` | Stop application by package name |

### Return Types

**InstalledAppListResult**
- `success` (bool): Whether the operation succeeded
- `data` (List[InstalledApp]): List of installed applications
- `error_message` (str): Error message if operation failed
- `request_id` (str): Unique request identifier

**InstalledApp**
- `name` (str): Application name
- `start_cmd` (str): Command/package name to start the application
- `stop_cmd` (Optional[str]): Command to stop the application
- `work_directory` (Optional[str]): Working directory for the application

**ProcessListResult**
- `success` (bool): Whether the operation succeeded
- `data` (List[Process]): List of process objects
- `error_message` (str): Error message if operation failed
- `request_id` (str): Unique request identifier

**Process**
- `pname` (str): Process name
- `pid` (int): Process ID
- `cmdline` (Optional[str]): Full command line

**AppOperationResult**
- `success` (bool): Whether the operation succeeded
- `error_message` (str): Error message if operation failed
- `request_id` (str): Unique request identifier

### Mobile-Specific Parameters

**Start Command Format**

The `start_cmd` parameter must use the "monkey -p" format:

```python
session.mobile.start_app("monkey -p com.android.settings")
```

**Stop Command Format**

The `stop_cmd` parameter should be the package name:

```python
session.mobile.stop_app_by_cmd("com.android.settings")
```

**Activity Parameter (Android)**

The `activity` parameter allows launching a specific activity:

```python
session.mobile.start_app(
    start_cmd="monkey -p com.android.settings",
    activity=".Settings"
)
```

Activity names can be specified as:
- **Relative name**: `.SettingsActivity` (package prefix will be added automatically)
- **Full name**: `com.package/.Activity` (complete activity identifier)

## 🎯 Summary

This guide covered mobile application management capabilities:

- **Application Discovery**: Query installed applications on the device
- **Application Lifecycle**: Start and stop Android apps using monkey command format
- **Activity Management**: Launch specific Android activities
- **Process Monitoring**: Track running mobile processes

These features enable you to build automated mobile workflows for testing, automation, and remote mobile device management scenarios using AgentBay SDK's Mobile Use capabilities.

## 📝 Platform Differences

**Mobile vs. Desktop:**
- **Mobile** (this guide): Uses "monkey -p" command format (e.g., `"monkey -p com.android.chrome"`) and supports Android activities
- **Desktop**: Uses executable paths (e.g., `/usr/bin/google-chrome-stable`) and supports working directories
- **Window Management**: Only available for desktop environments; mobile apps use full-screen activities instead
- **Application Discovery**: The current `mobile_latest` image returns an empty list from `get_installed_apps()`, but the API is available for future image versions
- **Stop Methods**: Mobile only supports `stop_app_by_cmd()` using package names; desktop supports additional methods like `stop_app_by_pid()` and `stop_app_by_pname()`

For desktop application management, see the [Computer Use Application Management Guide](../computer-use/computer-application-management.md).

## 📚 Related Guides

- [Mobile UI Automation](mobile-ui-automation.md) - Touch gestures and UI interaction
- [Computer Application Management](../computer-use/computer-application-management.md) - Desktop application management
- [Session Management](../common-features/basics/session-management.md) - Session lifecycle and configuration
- [Command Execution](../common-features/basics/command-execution.md) - Execute shell commands

## 🆘 Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Documentation Home](../README.md)




# Mobile Session Configuration

This guide demonstrates how to create mobile sessions with advanced configuration options using the AgentBay SDK. The mobile configuration allows you to control application access and screen resolution settings for mobile environments.

## Table of Contents
- [Overview](#overview)
- [Configuration Options](#configuration-options)
- [Navigation Bar Control](#navigation-bar-control)
- [Uninstall Protection](#uninstall-protection)
- [Whitelist Configuration](#whitelist-configuration)
- [Blacklist Configuration](#blacklist-configuration)
- [Advanced Configuration Examples](#advanced-configuration-examples)

## Overview

When creating mobile sessions, you can configure advanced settings using the `extra_configs` parameter in `CreateSessionParams`. This allows you to:

- Control application access through whitelist or blacklist rules
- Lock or unlock screen resolution
- Hide or show the system navigation bar
- Protect critical applications from uninstallation
- Enhance security and testing flexibility

## Configuration Options

The mobile configuration supports the following options:

### Resolution Settings

- **`lock_resolution`** (bool): Controls whether the screen resolution is locked
  - `True`: Locks the resolution to prevent changes
  - `False`: Allows resolution changes for flexible display adaptation

### Navigation Bar Control

- **`hide_navigation_bar`** (bool): Controls the visibility of the system navigation bar
  - `True`: Hides the navigation bar for immersive full-screen experience
  - `False`: Shows the navigation bar (default system behavior)

### Uninstall Protection

- **`uninstall_blacklist`** (list): A list of package names protected from uninstallation
  - Prevents accidental or malicious removal of critical applications
  - Commonly used to protect system apps, security tools, and essential services

### App Manager Rule

- **`app_manager_rule`** (AppManagerRule): Controls application access
  - **`rule_type`**: Either "White" (whitelist) or "Black" (blacklist)
  - **`app_package_name_list`**: List of package names to allow or block

## Navigation Bar Control

The navigation bar control feature allows you to create immersive mobile experiences by hiding the system navigation bar. This is particularly useful for:

- **Kiosk Applications**: Creating dedicated-purpose applications without system navigation
- **Immersive Gaming**: Full-screen gaming experiences without distractions
- **UI Testing**: Testing applications in full-screen mode
- **Digital Signage**: Creating clean, distraction-free displays

### Example: Hiding Navigation Bar

```python
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams
from agentbay.api.models import ExtraConfigs, MobileExtraConfig

# Initialize the SDK
agent_bay = AgentBay(api_key="your_api_key")

# Configure mobile settings with hidden navigation bar
mobile_config = MobileExtraConfig(
    lock_resolution=True,
    hide_navigation_bar=True  # Hide navigation bar for immersive experience
)

# Create extra configs
extra_configs = ExtraConfigs(mobile=mobile_config)

# Create session with immersive configuration
params = CreateSessionParams(
    image_id="mobile_latest",
    labels={"project": "immersive-ui", "mode": "kiosk"},
    extra_configs=extra_configs
)

session_result = agent_bay.create(params)
if session_result.success:
    session = session_result.session
    print(f"Immersive mobile session created with ID: {session.session_id}")
    print("Navigation bar hidden for full-screen experience")
```

## Uninstall Protection

The uninstall protection feature prevents critical applications from being accidentally or maliciously uninstalled. This is essential for:

- **System Stability**: Protecting essential system applications
- **Security**: Preventing removal of security and management tools
- **Compliance**: Ensuring required applications remain installed
- **Kiosk Mode**: Maintaining application integrity in public devices

### Example: Protecting Critical Applications

```python
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams
from agentbay.api.models import ExtraConfigs, MobileExtraConfig

# Initialize the SDK
agent_bay = AgentBay(api_key="your_api_key")

# Configure uninstall protection for critical apps
mobile_config = MobileExtraConfig(
    lock_resolution=True,
    uninstall_blacklist=[
        "com.android.systemui",        # System UI
        "com.android.settings",        # Settings app
        "com.google.android.gms",      # Google Play Services
        "com.company.security.app",    # Company security app
        "com.company.management.tool"  # Device management tool
    ]
)

# Create extra configs
extra_configs = ExtraConfigs(mobile=mobile_config)

# Create session with uninstall protection
params = CreateSessionParams(
    image_id="mobile_latest",
    labels={"project": "secure-deployment", "protection": "enabled"},
    extra_configs=extra_configs
)

session_result = agent_bay.create(params)
if session_result.success:
    session = session_result.session
    print(f"Protected mobile session created with ID: {session.session_id}")
    print("Critical applications protected from uninstallation")
```

## Whitelist Configuration

Use whitelists in production environments to ensure only approved applications can be installed and accessed. This provides the highest level of security by explicitly allowing only trusted applications.

### Example: Creating a Session with App Whitelist

```python
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams
from agentbay.api.models import ExtraConfigs, MobileExtraConfig, AppManagerRule

# Initialize the SDK
agent_bay = AgentBay(api_key="your_api_key")

# Configure mobile app management with whitelist
app_whitelist_rule = AppManagerRule(
    rule_type="White",
    app_package_name_list=[
        "com.example.allowed.app",
        "com.company.trusted.app",
        "com.system.essential.service"
    ]
)

# Configure mobile settings with comprehensive options
mobile_config = MobileExtraConfig(
    lock_resolution=True,
    hide_navigation_bar=True,  # Hide navigation bar for clean UI
    uninstall_blacklist=[      # Protect critical system apps
        "com.android.systemui",
        "com.android.settings",
        "com.google.android.gms"
    ],
    app_manager_rule=app_whitelist_rule
)

# Create extra configs
extra_configs = ExtraConfigs(mobile=mobile_config)

# Create session with mobile configuration
params = CreateSessionParams(
    image_id="mobile_latest",
    labels={"project": "mobile-testing", "environment": "development"},
    extra_configs=extra_configs
)

session_result = agent_bay.create(params)
if session_result.success:
    session = session_result.session
    print(f"Mobile session created with ID: {session.session_id}")
    print("Mobile configuration applied:")
    print("- Resolution locked")
    print("- App whitelist enabled with allowed packages")
else:
    print(f"Failed to create mobile session: {session_result.error_message}")
```

## Blacklist Configuration

Use blacklists in development and testing to block known problematic applications while allowing flexibility for other apps. This approach is useful when you want to prevent access to specific applications without restricting the entire environment.

### Example: Creating a Session with App Blacklist

```python
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams
from agentbay.api.models import ExtraConfigs, MobileExtraConfig, AppManagerRule

# Initialize the SDK
agent_bay = AgentBay(api_key="your_api_key")

# Configure mobile app management with blacklist
app_blacklist_rule = AppManagerRule(
    rule_type="Black",
    app_package_name_list=[
        "com.malware.suspicious.app",
        "com.unwanted.adware",
        "com.blocked.social.media"
    ]
)

# Configure mobile settings with resolution flexibility and security
mobile_config = MobileExtraConfig(
    lock_resolution=False,
    hide_navigation_bar=False,  # Keep navigation bar visible
    uninstall_blacklist=[       # Protect essential apps even in blacklist mode
        "com.android.systemui",
        "com.android.settings"
    ],
    app_manager_rule=app_blacklist_rule
)

# Create extra configs
extra_configs = ExtraConfigs(mobile=mobile_config)

# Create session with mobile blacklist configuration
params = CreateSessionParams(
    image_id="mobile_latest",
    labels={"project": "security-testing"},
    extra_configs=extra_configs
)

session_result = agent_bay.create(params)
if session_result.success:
    session = session_result.session
    print(f"Secure mobile session created with ID: {session.session_id}")
    print("Security configuration applied:")
    print("- Resolution unlocked for flexibility")
    print("- App blacklist enabled to block malicious packages")
else:
    print(f"Failed to create mobile session: {session_result.error_message}")
```

## Advanced Configuration Examples

### Comprehensive Mobile Configuration

This example demonstrates all available mobile configuration options working together:

```python
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams
from agentbay.api.models import ExtraConfigs, MobileExtraConfig, AppManagerRule

# Initialize the SDK
agent_bay = AgentBay(api_key="your_api_key")

# Create comprehensive app management rule
app_rule = AppManagerRule(
    rule_type="White",
    app_package_name_list=[
        "com.android.settings",
        "com.company.business.app",
        "com.trusted.productivity.suite"
    ]
)

# Configure all mobile options
mobile_config = MobileExtraConfig(
    lock_resolution=True,           # Lock resolution for consistent testing
    hide_navigation_bar=True,       # Hide navigation bar for immersive experience
    uninstall_blacklist=[           # Protect critical applications
        "com.android.systemui",     # System UI components
        "com.android.settings",     # Device settings
        "com.google.android.gms",   # Google Play Services
        "com.company.security.app", # Company security application
        "com.company.mdm.agent"     # Mobile device management agent
    ],
    app_manager_rule=app_rule       # Application access control
)

# Create extra configs
extra_configs = ExtraConfigs(mobile=mobile_config)

# Create session with comprehensive configuration
params = CreateSessionParams(
    image_id="mobile_latest",
    labels={
        "project": "enterprise-mobile",
        "config_type": "comprehensive",
        "security_level": "high",
        "ui_mode": "immersive"
    },
    extra_configs=extra_configs
)

session_result = agent_bay.create(params)
if session_result.success:
    session = session_result.session
    print(f"Comprehensive mobile session created with ID: {session.session_id}")
    print("Configuration applied:")
    print("✓ Resolution locked for consistent testing")
    print("✓ Navigation bar hidden for immersive experience")
    print("✓ Critical system apps protected from uninstallation")
    print("✓ App whitelist enforced for security")
else:
    print(f"Failed to create comprehensive session: {session_result.error_message}")
```

## Related Documentation

- [Mobile Application Management](./mobile-application-management.md)
- [Mobile UI Automation](./mobile-ui-automation.md)
- [Session Creation Basics](../common-features/basics/session-management.md)




# Mobile UI Automation Guide

This guide covers mobile UI automation capabilities in AgentBay SDK for Android mobile environments, including touch operations, text input, UI element detection, and screen operations.

## 📋 Table of Contents

- [Overview](#overview)
- [Prerequisites](#prerequisites)
- [Touch Operations](#touch-operations)
- [Text Input Operations](#text-input-operations)
- [UI Element Detection](#ui-element-detection)
- [Screen Operations](#screen-operations)
- [Best Practices](#best-practices)
- [Common Use Cases](#common-use-cases)
- [Troubleshooting](#troubleshooting)

<a id="overview"></a>
## 🎯 Overview

AgentBay provides powerful mobile UI automation capabilities for interacting with Android mobile environments in the cloud. You can:

1. **Touch Operations** - Tap and swipe gestures for mobile interaction
2. **Text Input** - Input text and send hardware key events
3. **UI Element Detection** - Discover and interact with UI elements
4. **Screen Operations** - Capture screenshots for visual verification

All operations are performed through the `session.mobile` module, which provides a comprehensive API for mobile automation tasks.

<a id="prerequisites"></a>
## ⚙️ Prerequisites

Mobile UI automation requires creating a session with a mobile system image (this example uses `mobile_latest` for verification):

```python
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams

agent_bay = AgentBay()
session_params = CreateSessionParams(image_id="mobile_latest")
session = agent_bay.create(session_params).session
# Session created successfully for mobile automation
```

<a id="touch-operations"></a>
## 👆 Touch Operations

### Tap Gesture

Tap on the screen at specific coordinates:

```python
session_params = CreateSessionParams(image_id="mobile_latest")
session = agent_bay.create(session_params).session

# Tap at coordinates
result = session.mobile.tap(x=500, y=300)
if result.success:
    print("Tap successful")  # Output: Tap successful
else:
    print(f"Tap failed: {result.error_message}")

agent_bay.delete(session)
```

### Swipe Gesture

Perform swipe gestures from one point to another:

```python
session_params = CreateSessionParams(image_id="mobile_latest")
session = agent_bay.create(session_params).session

# Swipe up (from bottom to top)
result = session.mobile.swipe(
    start_x=100,
    start_y=500,
    end_x=100,
    end_y=200,
    duration_ms=300
)
if result.success:
    print("Swipe up successful")  # Output: Swipe up successful

# Swipe left (from right to left)
result = session.mobile.swipe(
    start_x=500,
    start_y=300,
    end_x=100,
    end_y=300,
    duration_ms=300
)
if result.success:
    print("Swipe left successful")  # Output: Swipe left successful

agent_bay.delete(session)
```

**Parameters:**
- `start_x`, `start_y`: Starting coordinates
- `end_x`, `end_y`: Ending coordinates
- `duration_ms`: Duration of the swipe in milliseconds (default: 300)

<a id="text-input-operations"></a>
## ⌨️ Text Input Operations

### Input Text

Type text into the active field:

```python
session_params = CreateSessionParams(image_id="mobile_latest")
session = agent_bay.create(session_params).session

result = session.mobile.input_text("Hello AgentBay!")
if result.success:
    print("Text input successful")  # Output: Text input successful

agent_bay.delete(session)
```

### Send Hardware Key Events

Send Android hardware key events using KeyCode constants:

```python
from agentbay.mobile.mobile import KeyCode

session_params = CreateSessionParams(image_id="mobile_latest")
session = agent_bay.create(session_params).session

# Press HOME key
result = session.mobile.send_key(KeyCode.HOME)
if result.success:
    print("HOME key pressed")  # Output: HOME key pressed

# KeyCode values are: HOME=3, BACK=4, VOLUME_UP=24, VOLUME_DOWN=25, POWER=26, MENU=82
print(f"HOME keycode value: {KeyCode.HOME}")  # Output: HOME keycode value: 3

agent_bay.delete(session)
```

**Available KeyCode Constants:**

| KeyCode | Value | Description |
|---------|-------|-------------|
| `KeyCode.HOME` | 3 | Home button |
| `KeyCode.BACK` | 4 | Back button |
| `KeyCode.VOLUME_UP` | 24 | Volume up button |
| `KeyCode.VOLUME_DOWN` | 25 | Volume down button |
| `KeyCode.POWER` | 26 | Power button |
| `KeyCode.MENU` | 82 | Menu button |

**Note:** All hardware keys can be used for mobile device automation. The key press events are sent to the Android system and executed accordingly.

<a id="ui-element-detection"></a>
## 🔍 UI Element Detection

### Get All UI Elements

Retrieve all UI elements in the current screen hierarchy:

```python
session_params = CreateSessionParams(image_id="mobile_latest")
session = agent_bay.create(session_params).session

result = session.mobile.get_all_ui_elements(timeout_ms=2000)
if result.success:
    print(f"Found {len(result.elements)} UI elements")  # Output: Found 2172 UI elements
    for element in result.elements:
        # Element structure varies, inspect element data
        print(f"Element: {element}")
        # Output example: Element data contains UI hierarchy information
else:
    print(f"Failed: {result.error_message}")

agent_bay.delete(session)
```

**Parameters:**
- `timeout_ms`: Timeout in milliseconds to wait for UI elements (default: 2000)

### Get Clickable UI Elements

Retrieve only clickable/interactable UI elements:

```python
session_params = CreateSessionParams(image_id="mobile_latest")
session = agent_bay.create(session_params).session

result = session.mobile.get_clickable_ui_elements(timeout_ms=2000)
if result.success:
    print(f"Found {len(result.elements)} clickable elements")  # Output: Found 3 clickable elements
    for element in result.elements:
        # Process clickable elements
        print(f"Clickable element: {element}")
        # Output example: Clickable element data with interaction capabilities
else:
    print(f"Failed: {result.error_message}")

agent_bay.delete(session)
```

**Parameters:**
- `timeout_ms`: Timeout in milliseconds to wait for UI elements (default: 2000)

<a id="screen-operations"></a>
## 📸 Screen Operations

### Take Screenshot

Capture a screenshot of the current mobile screen:

```python
session_params = CreateSessionParams(image_id="mobile_latest")
session = agent_bay.create(session_params).session

result = session.mobile.screenshot()
if result.success:
    screenshot_url = result.data
    print(f"Screenshot URL: {screenshot_url}")
    # Output: Screenshot URL: https://***.***.aliyuncs.com/***/screenshot_1234567890.png?***
else:
    print(f"Screenshot failed: {result.error_message}")

agent_bay.delete(session)
```

<a id="best-practices"></a>
## 💡 Best Practices

### 1. Always Use Mobile System Images

Mobile UI automation requires a mobile system image (examples below use `mobile_latest`):

```python
# Correct - using mobile system image
session_params = CreateSessionParams(image_id="mobile_latest")
session = agent_bay.create(session_params).session

# Incorrect - will not work for mobile operations
session_params = CreateSessionParams(image_id="windows_latest")
session = agent_bay.create(session_params).session
```

### 4. Handle Screenshot URLs Properly

Screenshots return OSS URLs, not image data:

```python
result = session.mobile.screenshot()
if result.success:
    screenshot_url = result.data
    print(f"Screenshot available at: {screenshot_url}")
    # Output: Screenshot available at: https://***.***.aliyuncs.com/***/screenshot_1234567890.png?***
    # Use the URL to download or display the screenshot as needed
else:
    print(f"Screenshot failed: {result.error_message}")
```

<a id="common-use-cases"></a>
## 🎨 Common Use Cases

### Example 1: App Navigation

```python
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams

agent_bay = AgentBay()
session_params = CreateSessionParams(image_id="mobile_latest")
session = agent_bay.create(session_params).session

try:
    # Tap on app icon
    tap_result = session.mobile.tap(x=200, y=400)
    print(f"App tap result: {tap_result.success}")  # Output: App tap result: True
    
    # Wait a moment for app to load
    import time
    time.sleep(2)
    
    # Swipe to navigate
    swipe_result = session.mobile.swipe(
        start_x=400,
        start_y=600,
        end_x=100,
        end_y=600,
        duration_ms=300
    )
    print(f"Navigation swipe result: {swipe_result.success}")  # Output: Navigation swipe result: True
    
    # Tap on a button
    button_result = session.mobile.tap(x=300, y=800)
    print(f"Button tap result: {button_result.success}")  # Output: Button tap result: True
    
finally:
    agent_bay.delete(session)
```

### Example 2: Form Input on Mobile

```python
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams

agent_bay = AgentBay()
session_params = CreateSessionParams(image_id="mobile_latest")
session = agent_bay.create(session_params).session

try:
    # Tap on username field
    username_tap = session.mobile.tap(x=300, y=400)
    print(f"Username field focused: {username_tap.success}")  # Output: Username field focused: True
    
    # Enter username
    username_input = session.mobile.input_text("john_doe")
    print(f"Username entered: {username_input.success}")  # Output: Username entered: True
    
    # Tap on password field
    password_tap = session.mobile.tap(x=300, y=500)
    print(f"Password field focused: {password_tap.success}")  # Output: Password field focused: True
    
    # Enter password
    password_input = session.mobile.input_text("secure_password")
    print(f"Password entered: {password_input.success}")  # Output: Password entered: True
    
    # Tap login button
    login_tap = session.mobile.tap(x=300, y=650)
    print(f"Login button pressed: {login_tap.success}")  # Output: Login button pressed: True
    
finally:
    agent_bay.delete(session)
```

### Example 3: UI Element Discovery and Interaction

```python
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams

agent_bay = AgentBay()
session_params = CreateSessionParams(image_id="mobile_latest")
session = agent_bay.create(session_params).session

try:
    # Get all clickable elements
    result = session.mobile.get_clickable_ui_elements(timeout_ms=3000)
    
    if result.success:
        print(f"Found {len(result.elements)} clickable elements")  # Output: Found 3 clickable elements
        
        # Analyze elements to find target
        for i, element in enumerate(result.elements):
            print(f"Element {i+1}: {element}")  
            # Output example:
            # Element 1: UI element with interaction capabilities
            # Element 2: UI element with interaction capabilities  
            # Element 3: UI element with interaction capabilities
    
    # Take screenshot for verification
    screenshot = session.mobile.screenshot()
    if screenshot.success:
        screenshot_url = screenshot.data
        print(f"Screenshot URL: {screenshot_url}")
        # Output: Screenshot URL: https://***.***.aliyuncs.com/***/screenshot_1234567890.png?***
    
finally:
    agent_bay.delete(session)
```

### Example 4: Scroll Through Content

```python
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams

agent_bay = AgentBay()
session_params = CreateSessionParams(image_id="mobile_latest")
session = agent_bay.create(session_params).session

try:
    # Scroll down multiple times
    for i in range(3):
        scroll_result = session.mobile.swipe(
            start_x=300,
            start_y=800,
            end_x=300,
            end_y=200,
            duration_ms=400
        )
        print(f"Scroll down {i+1}: {scroll_result.success}")  # Output: Scroll down 1: True, etc.
        
        # Brief pause between scrolls
        import time
        time.sleep(1)
    
    # Scroll back up
    up_result = session.mobile.swipe(
        start_x=300,
        start_y=200,
        end_x=300,
        end_y=800,
        duration_ms=400
    )
    print(f"Scroll up result: {up_result.success}")  # Output: Scroll up result: True
    
finally:
    agent_bay.delete(session)
```

<a id="troubleshooting"></a>
## 🆘 Troubleshooting

### Common Issues

1. **"Tool not found" errors**
   - Ensure you're using a mobile system image (e.g., `image_id="mobile_latest"`)
   - Verify the session was created successfully
   - Check that API key and endpoint are configured correctly

2. **Hardware key operations**
   - Hardware key operations send key events to the Android system
   - Check the `result.success` status to verify if the key was sent successfully
   - Example error handling:
     ```python
     result = session.mobile.send_key(KeyCode.HOME)
     if not result.success:
         print(f"Key press failed: {result.error_message}")
     ```

3. **UI element detection returns empty results**
   - Increase the `timeout_ms` parameter
   - Take a screenshot to verify the current UI state
   - Ensure the target screen has fully loaded

4. **Screenshot URL handling**
   - Screenshots return OSS URLs, not image data
   - `result.data` contains a download URL, not the image itself
   - Use the URL to download the screenshot if needed

5. **Swipe gestures not working as expected**
   - Verify coordinates are within screen bounds
   - Adjust `duration_ms` for different gesture speeds
   - Ensure start and end coordinates create meaningful swipe direction

### Getting Help

For more assistance:
- Review [Session Management Guide](../common-features/basics/session-management.md)

## 📚 Related Guides

- [Session Management Guide](../common-features/basics/session-management.md) - Learn about session lifecycle
- [Computer UI Automation](../computer-use/computer-ui-automation.md) - Windows desktop automation
- [Command Execution](../common-features/basics/command-execution.md) - Execute shell commands
- [File Operations](../common-features/basics/file-operations.md) - Upload and download files




# Quick Start Guide for Beginners

Welcome to AgentBay SDK! This guide provides a step-by-step learning path for users new to cloud development.

## 🎯 Learning Objectives

After completing this quick start guide, you will be able to:
- Understand AgentBay's core concepts
- Create your first cloud session
- Perform basic file and command operations in the cloud
- Learn how to save and reuse your work

## 📚 Learning Path (Estimated 25 minutes)

### Step 1: Environment Setup (5 minutes)
- [Installation and Configuration](installation.md)
- Get API key
- Verify installation

### Step 2: Core Concepts (10 minutes)
- [Understanding Basic Concepts](basic-concepts.md)
- What is a cloud session?
- Differences between sessions and local environments
- Data persistence concepts

### Step 3: First Program (5 minutes)
- [Create Your First Session](first-session.md)
- Quick verification (30 seconds)
- Cloud data processing example


## 🚀 Next Steps After Completion

- Check out the [Feature Guides](../guides/README.md) to learn about complete functionality
- Explore [Use Cases](../guides/common-features/use-cases/README.md) for practical application examples
- Join community discussions

## ❓ Having Issues?

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)

## 💡 Tips

- Each step includes complete code examples
- Don't worry if you don't understand everything at first
- The community is here to help!




# Core Concepts

Before we start programming, let's understand the essential concepts you need to know to use AgentBay effectively.

## 🌐 What is AgentBay?

AgentBay is a cloud computing platform that provides on-demand virtual environments. You can think of it as:
- Cloud-based remote computers that support different operating systems (Windows, Linux, Android)
- Virtual machines that can be created and destroyed instantly
- Designed specifically for automation, testing, and development tasks

### 📦 AgentBay Class - Your Cloud Gateway

In the SDK, the `AgentBay` class is your main interface for interacting with the cloud service:

```python
from agentbay import AgentBay

# Create AgentBay client instance
agent_bay = AgentBay()
```

**Core functions of the AgentBay class:**
- **Session Manager**: Create, delete, and manage cloud sessions
- **API Client**: Handle all communication with AgentBay cloud service
- **Authentication Handler**: Automatically manage API keys and security

**Basic usage pattern:**
```python
# 1. Initialize client
agent_bay = AgentBay()

# 2. Create session (uses linux_latest by default)
session = agent_bay.create().session

# 3. Use session for your tasks
# ... your automation tasks ...

# 4. Clean up resources
agent_bay.delete(session)
```

**Learn more**: [SDK Configuration Guide](../guides/common-features/configuration/sdk-configuration.md)

## 🔗 Session

A **session** is your connection to a cloud environment. It's like renting a computer in the cloud for a specific period of time.

### Key Characteristics:
- **Temporary**: Sessions are created when you need them and destroyed when you're done
- **Isolated**: Each session is completely separate from others
- **Billable**: You pay for the time your session is active

### Basic Usage:
```python
# Create a session
session = agent_bay.create().session

# Use the session for your tasks
session.command.execute_command("echo 'Hello World'")

# Always clean up when done
agent_bay.delete(session)
```

### Session Lifecycle:
```
Create Session → Use Session → Delete Session
      ↓             ↓              ↓
  Allocate      Execute         Release
  Resources     Operations      Resources
```

### Session Release

Sessions must be released when you're done to free cloud resources. There are **two ways** to release a session:

**1. Manual Release (Recommended)**
```python
# Explicitly delete when done
agent_bay.delete(session)
```

**2. Automatic Timeout Release**
- If not manually deleted, sessions are automatically released after a timeout period
- Timeout duration is configured in the [AgentBay Console](https://agentbay.console.aliyun.com/)
- After timeout, the session is released and cannot be recovered

**Important**: Always manually delete sessions when finished. This is a best practice for resource management.

**Learn more**: [Session Management Guide](../guides/common-features/basics/session-management.md)

## 🖥️ Image Types

When creating a session, you must choose an **image type** - this determines what kind of environment you get and what you can do with it.

### Official System Images:

The following table shows the latest official system images provided by AgentBay:

| Image ID | Environment | Best For |
|----------|-------------|----------|
| `linux_latest` | Computer Use | General computing, server tasks (default if not specified) |
| `windows_latest` | Computer Use | General Windows tasks, .NET development, Windows apps |
| `browser_latest` | Browser Use | Web scraping, browser automation, testing websites |
| `code_latest` | CodeSpace  | Coding, development tools, programming tasks |
| `mobile_latest` | Mobile Use | Mobile app testing, Android automation |

**Note**:
- If you don't specify an `image_id`, AgentBay will automatically use `linux_latest` as the default environment.
- These are the current latest versions of official system images. You can also create and use **custom images** through the AgentBay console to meet your specific requirements.

**⚠️ Production Environment Recommendation**:
- The `xxxx_latest` images are automatically updated to newer versions, which may introduce API incompatibilities with older SDK versions.
- **For production environments**, it is strongly recommended to use **custom images** with fixed versions to ensure stability and avoid unexpected breaking changes.
- Learn more about custom images and how to create them: [Custom Images Guide](../guides/common-features/advanced/custom-images.md)

### Choosing the Right Image:

**Windows Environment Example:**
```python
from agentbay.session_params import CreateSessionParams

# Create Windows environment and automate notepad
params = CreateSessionParams(image_id="windows_latest")
session = agent_bay.create(params).session

# Start Notepad application
session.computer.start_app("notepad.exe")
# Returns: ProcessListResult with started process info

# Input text into notepad
session.computer.input_text("Hello from Windows!")
# Returns: BoolResult with success status

agent_bay.delete(session)
```

**Browser Environment Example:**
```python
# Create browser environment
params = CreateSessionParams(image_id="browser_latest")
session = agent_bay.create(params).session

# Initialize and navigate
from agentbay.browser import BrowserOption
session.browser.initialize(BrowserOption())
session.browser.agent.navigate("https://www.baidu.com")
print("Web navigation successful")

agent_bay.delete(session)
```

**CodeSpace Environment Example:**
```python
# Create development environment and execute code
params = CreateSessionParams(image_id="code_latest")
session = agent_bay.create(params).session

# Execute code
result = session.code.run_code("print('Hello from CodeSpace!')", "python")
# Returns: CodeExecutionResult with output
# Example: result.result = "Hello from CodeSpace!"

agent_bay.delete(session)
```

**Mobile Environment Example:**
```python
# Create Android environment and send HOME key
params = CreateSessionParams(image_id="mobile_latest")
session = agent_bay.create(params).session

# Press HOME key to return to home screen
from agentbay.mobile import KeyCode
session.mobile.send_key(KeyCode.HOME)
# Returns: BoolResult with success status
# Example: result.success = True (returns to Android home screen)

agent_bay.delete(session)
```

**Important**: Different images support different features. Choose the image that matches your specific use case.

**Learn more about each environment:**
- [Computer Use Guide](../guides/computer-use/README.md) - Windows/Linux automation
- [Browser Use Guide](../guides/browser-use/README.md) - Web automation and scraping
- [CodeSpace Guide](../guides/codespace/README.md) - Code execution environments
- [Mobile Use Guide](../guides/mobile-use/README.md) - Android automation

## 💾 Data Permanence - Temporary vs Persistent

Understanding data permanence is crucial when using cloud environments:

### Temporary Data (Default Behavior)
- **All data in a session is temporary by default**
- **Everything is lost when the session ends**
- Suitable for: processing tasks, temporary files, cache

```python
# This data will be LOST when session ends
session.file_system.write_file("/tmp/temp_data.txt", "This will disappear")
```

### Persistent Data (Context)
- **Data that survives across sessions**
- **Must be explicitly configured**
- Suitable for: project files, configurations, important results

```python
from agentbay import ContextSync

# Create persistent storage
context = agent_bay.context.get("my-project", create=True).context
context_sync = ContextSync.new(context.id, "/persistent")

# Create session with persistent data
params = CreateSessionParams(context_syncs=[context_sync])
session = agent_bay.create(params).session

# This data will be SAVED across sessions
session.file_system.write_file("/persistent/important.txt", "This will persist")
```

**Critical Rule**: If you need to keep data, you MUST use Context. Otherwise, it will be lost forever when the session ends.

**Learn more**: 
- [Data Persistence Guide](../guides/common-features/basics/data-persistence.md)
- [File Operations Guide](../guides/common-features/basics/file-operations.md)

## 🔍 Understanding API Results and Request IDs

When you call AgentBay APIs, the results are wrapped in result objects that contain more than just your data:

```python
# Example API call
screenshot = session.computer.screenshot()

# The result object contains:
print(screenshot.success)     # True/False - whether the operation succeeded
print(screenshot.data)        # Your actual data (screenshot URL)
print(screenshot.request_id)  # Request ID for troubleshooting
```

### What is a Request ID?
Every API call to AgentBay gets a unique **Request ID** - a special identifier like `"ABC12345-XXXX-YYYY-ZZZZ-123456789ABC"`.

**Why Request IDs matter:**
- **Troubleshooting**: If something goes wrong, you can provide this ID to support for faster problem resolution
- **Tracking**: Helps track individual operations in logs
- **Debugging**: Makes it easier to identify which specific API call had issues

**When you might need it:**
- API calls fail unexpectedly
- Performance issues with specific operations
- When contacting support about problems

**Example troubleshooting:**
```python
result = session.code.run_code("print('hello')", "python")
if not result.success:
    print(f"Code execution failed! Request ID: {result.request_id}")
    # Share this Request ID with support for faster help
```

Don't worry about Request IDs for normal usage - they're just there when you need them for debugging!

**Learn more**: [Common Features Guide](../guides/common-features/README.md)

## 🚀 Quick Start

Now you understand the essentials:

1. **AgentBay** = Cloud computing platform
2. **Session** = Your temporary connection to a cloud computer
3. **Image** = The type of environment (Linux/Windows/Browser/Code/Mobile)
4. **Data** = Temporary by default, use Context for persistence

Ready to create your first session? Check out the [First Session Guide](first-session.md) - a 5-minute hands-on tutorial!




# Create Your First Session

Now let's experience the core features of AgentBay through actual code.

## 🚀 Before You Start (2-minute setup)

If you haven't completed the setup yet, please complete the quick setup steps:

👉 **[Installation and API Key Setup Guide](installation.md)** - Complete SDK installation and API key configuration in 2 minutes

Already done? Great! Let's verify everything works with a quick test.

## 💡 30-Second Quick Verification

Let's first verify everything works with the simplest possible example:

```python
import os
from agentbay import AgentBay

api_key = os.getenv("AGENTBAY_API_KEY")
agent_bay = AgentBay(api_key=api_key)

result = agent_bay.create()
if result.success:
    session = result.session
    cmd_result = session.command.execute_command("echo 'Hello from the cloud!'")
    print(f"✅ Cloud says: {cmd_result.output.strip()}")
    agent_bay.delete(session)
else:
    print(f"❌ Failed: {result.error_message}")

# Expected output:
# ✅ Cloud says: Hello from the cloud!
```

If this works, you're ready to explore more! 🎉

## 🌟 A Practical Example: Cloud Data Processing

Let's do something more useful - process a data file in the cloud:

```python
import os
from agentbay import AgentBay

agent_bay = AgentBay(api_key=os.getenv("AGENTBAY_API_KEY"))
result = agent_bay.create()
session = result.session

try:
    # 1. Create a Python script for data processing
    script_content = '''
import json
import sys

data = {
    "students": [
        {"name": "Alice", "scores": [85, 92, 88]},
        {"name": "Bob", "scores": [78, 85, 80]},
        {"name": "Charlie", "scores": [92, 95, 98]}
    ]
}

results = []
for student in data["students"]:
    avg = sum(student["scores"]) / len(student["scores"])
    results.append({
        "name": student["name"],
        "average": round(avg, 2),
        "grade": "A" if avg >= 90 else "B" if avg >= 80 else "C"
    })

print(json.dumps(results, indent=2))
'''
    
    # 2. Upload script to cloud
    session.file_system.write_file("/tmp/process_data.py", script_content)
    print("✅ Script uploaded to cloud")
    
    # 3. Execute the script in cloud environment
    result = session.command.execute_command("python3 /tmp/process_data.py")
    print(f"\n📊 Processing results:\n{result.output}")
    
    # Expected output:
    # [
    #   {"name": "Alice", "average": 88.33, "grade": "B"},
    #   {"name": "Bob", "average": 81.0, "grade": "B"},
    #   {"name": "Charlie", "average": 95.0, "grade": "A"}
    # ]
    
    print("\n💡 What happened:")
    print("  1. Uploaded Python script to cloud environment")
    print("  2. Executed script with pre-installed Python")
    print("  3. Got results back - all without local setup!")
    
finally:
    agent_bay.delete(session)
    print("\n✅ Session cleaned up")

# Expected output includes JSON formatted student grades
```

## 💡 What You Learned

**The AgentBay Workflow:**
1. **Create** - Get a fresh cloud environment
2. **Use** - Execute commands, upload/download files
3. **Cleanup** - Delete session to free resources

**Key Concepts:**
- `agent_bay.create()` - Creates a new cloud session
- `session.command.execute_command()` - Runs commands in the cloud
- `session.file_system.write_file()` - Uploads files to cloud
- `agent_bay.delete(session)` - Cleans up when done

## 🚀 Next Steps

Now that you've created your first session, explore more capabilities:

**Learn Core Features:**
- 📝 **[Command Execution](../guides/codespace/code-execution.md)** - Run shell commands and code
- 📁 **[File Operations](../guides/common-features/basics/file-operations.md)** - Upload, download, and manage files
- 🔧 **[Session Management](../guides/common-features/basics/session-management.md)** - Advanced session patterns and best practices

**Explore Use Cases:**
- 🌐 **[Browser Automation](../guides/computer-use/computer-ui-automation.md)** - Web scraping and testing
- 📱 **[Mobile Testing](../guides/mobile-use/mobile-ui-automation.md)** - Android app automation
- 💻 **[Code Development](../guides/codespace/code-execution.md)** - Cloud development environment

**Ready to build something amazing?** Check out the [Feature Guides](../guides/README.md) to explore all capabilities! 🚀




# Installation and Configuration

## 📋 System Requirements

### Python
- Python 3.10+
- pip or poetry

### TypeScript/JavaScript
- Node.js 14+
- npm or yarn

### Golang
- Go 1.24.4+

## 🚀 Quick Installation

### Python

**✅ Recommended: Using Virtual Environment**
```bash
# Create and activate virtual environment
python3 -m venv agentbay-env
source agentbay-env/bin/activate  # Linux/macOS
# agentbay-env\Scripts\activate   # Windows

# Install the package
pip install wuying-agentbay-sdk

# Verify installation
python -c "import agentbay; print('✅ Installation successful')"
```

**Alternative: Using System Python (if allowed)**
```bash
# Install with user flag (if system allows)
pip install --user wuying-agentbay-sdk

# Verify installation  
python -c "import agentbay; print('✅ Installation successful')"
```

### TypeScript/JavaScript

```bash
# Initialize project (if new project)
mkdir my-agentbay-project && cd my-agentbay-project
npm init -y

# Install the package
npm install wuying-agentbay-sdk

# Verify installation
node -e "const {AgentBay} = require('wuying-agentbay-sdk'); console.log('✅ Installation successful')"
```

### Golang

```bash
# Initialize module (if new project)
mkdir my-agentbay-project && cd my-agentbay-project  
go mod init my-agentbay-project

# Install the package
GOPROXY=direct go get github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay

# Verify installation
go list -m github.com/aliyun/wuying-agentbay-sdk/golang && echo "✅ Installation successful"
```

## 🔑 API Key Setup

### Step 1: Get API Key
1. Register at [https://aliyun.com](https://aliyun.com)
2. Visit [AgentBay Console](https://agentbay.console.aliyun.com/service-management)  
3. Create and copy your API key

### Step 2: Set Environment Variable

**Linux/macOS:**
```bash
export AGENTBAY_API_KEY=your_api_key_here
```

**Windows:**
```cmd
setx AGENTBAY_API_KEY your_api_key_here
```

## ✅ Installation Verification

Create a simple test to verify everything works with your API key:

### Python Test
```python
import os
from agentbay import AgentBay

# Get API key from environment
api_key = os.getenv("AGENTBAY_API_KEY")
if not api_key:
    print("⚠️  Please set AGENTBAY_API_KEY environment variable")
    exit(1)

try:
    # Initialize SDK
    agent_bay = AgentBay(api_key=api_key)
    print("✅ SDK initialized successfully")
    
    # Create a session (requires valid API key and network)
    session_result = agent_bay.create()
    if session_result.success:
        session = session_result.session
        print(f"✅ Session created: {session.session_id}")
        
        # Clean up
        agent_bay.delete(session)
        print("✅ Test completed successfully")
    else:
        print(f"⚠️  Session creation failed: {session_result.error_message}")
        
except Exception as e:
    print(f"❌ Error: {e}")
```

### TypeScript Test
```typescript
import { AgentBay } from 'wuying-agentbay-sdk';

const apiKey = process.env.AGENTBAY_API_KEY;
if (!apiKey) {
    console.log("⚠️  Please set AGENTBAY_API_KEY environment variable");
    process.exit(1);
}

async function test() {
    try {
        // Initialize SDK
        const agentBay = new AgentBay({ apiKey });
        console.log("✅ SDK initialized successfully");
        
        // Create a session (requires valid API key and network)
        const sessionResult = await agentBay.create();
        if (sessionResult.success) {
            const session = sessionResult.session;
            console.log(`✅ Session created: ${session.sessionId}`);
            
            // Clean up
            await agentBay.delete(session);
            console.log("✅ Test completed successfully");
        } else {
            console.log(`⚠️  Session creation failed: ${sessionResult.errorMessage}`);
        }
    } catch (error) {
        console.log(`❌ Error: ${error}`);
    }
}

test();
```

### Golang Test
```go
package main

import (
    "fmt"
    "os"
    "github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
)

func main() {
    // Get API key from environment
    apiKey := os.Getenv("AGENTBAY_API_KEY")
    if apiKey == "" {
        fmt.Println("⚠️  Please set AGENTBAY_API_KEY environment variable")
        return
    }

    // Initialize SDK
    client, err := agentbay.NewAgentBay(apiKey, nil)
    if err != nil {
        fmt.Printf("❌ Failed to initialize SDK: %v\n", err)
        return
    }
    fmt.Println("✅ SDK initialized successfully")

    // Create a session (requires valid API key and network)
    sessionResult, err := client.Create(nil)
    if err != nil {
        fmt.Printf("⚠️  Session creation failed: %v\n", err)
        return
    }
    
    if sessionResult.Session != nil {
        fmt.Printf("✅ Session created: %s\n", sessionResult.Session.SessionID)
        
        // Clean up
        _, err = client.Delete(sessionResult.Session, false)
        if err != nil {
            fmt.Printf("⚠️  Session cleanup failed: %v\n", err)
        } else {
            fmt.Println("✅ Test completed successfully")
        }
    }
}
```

## 🔧 Advanced Configuration (Optional)

> **Note:** The SDK uses the Shanghai API gateway by default. You only need to configure a different gateway if you want to connect through other regions, such as Singapore, for better network performance.

### Supported API Gateway Regions

The SDK configuration specifies which **API Gateway** to connect to. Choose the gateway closest to your users for optimal network performance:

| Gateway Location | Endpoint |
|-----------------|----------|
| Shanghai (Default) | `wuyingai.cn-shanghai.aliyuncs.com` |
| Singapore | `wuyingai.ap-southeast-1.aliyuncs.com` |

### Switching to Singapore Gateway

**Linux/macOS:**
```bash
export AGENTBAY_ENDPOINT=wuyingai.ap-southeast-1.aliyuncs.com
```

**Windows:**
```cmd
set AGENTBAY_ENDPOINT=wuyingai.ap-southeast-1.aliyuncs.com
```

For more configuration options, see the [SDK Configuration Guide](../guides/common-features/configuration/sdk-configuration.md).

## 🆘 Troubleshooting

### Python Issues

**`externally-managed-environment` error:**
```bash
# Solution: Use virtual environment
python3 -m venv agentbay-env
source agentbay-env/bin/activate
pip install wuying-agentbay-sdk
```

**`ModuleNotFoundError: No module named 'agentbay'`:**
```bash
# Check if virtual environment is activated
which python  # Should show venv path
# Re-install if needed
pip install --force-reinstall wuying-agentbay-sdk
```

**Permission denied errors:**
```bash
# Use user installation
pip install --user wuying-agentbay-sdk
```

### TypeScript Issues

**`Cannot find module 'wuying-agentbay-sdk'`:**
```bash
# Ensure you're in the project directory with package.json
pwd
ls package.json  # Should exist
# Re-install if needed
npm install wuying-agentbay-sdk
```

**`require() is not defined`:**
```bash
# Check Node.js version (requires 14+)
node --version
# Ensure you're using CommonJS (default) or update to ES modules
```

### Golang Issues

**`checksum mismatch` error (Most Common):**
```bash
# Always use direct proxy for this package
GOPROXY=direct go get github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay
```

**Import path errors:**
```bash
# Check Go version (requires 1.24.4+)
go version
# Ensure module is initialized
go mod init your-project-name
```

**Build failures:**
```bash
# Clean module cache and retry
go clean -modcache
go mod tidy
go get github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay
```

### Network and API Issues

**Connection timeouts:**
- Check your network connection
- Verify the API gateway endpoint is appropriate for your location
- Try different gateway endpoints if available for better connectivity

**API key errors:**
- Verify API key is correct and active
- Check API key permissions in console
- Ensure environment variable is properly set

**Session creation failures:**
- Verify account has sufficient quota
- Check service status at console
- Try again after a few minutes

## 🎉 Installation Complete!

If all the above tests pass, congratulations! You have successfully installed and configured the AgentBay SDK.

**Next Steps:**
- [Understanding Basic Concepts](basic-concepts.md)
- [Creating Your First Session](first-session.md) - 5-minute hands-on tutorial





# Python SDK Documentation


# AgentBay SDK for Python

> Execute commands, operate files, and run code in cloud environments

## 📦 Installation

```bash
pip install wuying-agentbay-sdk
```

## 🚀 Prerequisites

Before using the SDK, you need to:

1. Register an Alibaba Cloud account: [https://aliyun.com](https://aliyun.com)
2. Get API credentials: [AgentBay Console](https://agentbay.console.aliyun.com/service-management)
3. Set environment variable: `export AGENTBAY_API_KEY=your_api_key`

## 🚀 Quick Start
```python
from agentbay import AgentBay

# Create session
agent_bay = AgentBay()
result = agent_bay.create()
# Verified: ✓ Client initialized and session created successfully

if result.success:
    session = result.session

    # Execute command
    cmd_result = session.command.execute_command("ls -la")
    print(cmd_result.output)
    # Verified: ✓ Command executed successfully
    # Sample output: "总计 100\ndrwxr-x--- 16 wuying wuying 4096..."

    # File operations
    session.file_system.write_file("/tmp/test.txt", "Hello World")
    content = session.file_system.read_file("/tmp/test.txt")
    print(content.content)
    # Verified: ✓ File written and read successfully
    # Output: "Hello World"
```

## 📖 Complete Documentation

### 🆕 New Users
- [📚 Quick Start Tutorial](https://github.com/aliyun/wuying-agentbay-sdk/tree/main/docs/quickstart/README.md) - Get started in 5 minutes
- [🎯 Core Concepts](https://github.com/aliyun/wuying-agentbay-sdk/tree/main/docs/quickstart/basic-concepts.md) - Understand cloud environments and sessions

### 🚀 Experienced Users
**Choose Your Cloud Environment:**
- 🌐 [Browser Use](https://github.com/aliyun/wuying-agentbay-sdk/tree/main/docs/guides/browser-use/README.md) - Web scraping, browser testing, form automation
- 🖥️ [Computer Use](https://github.com/aliyun/wuying-agentbay-sdk/tree/main/docs/guides/computer-use/README.md) - Windows desktop automation, UI testing
- 📱 [Mobile Use](https://github.com/aliyun/wuying-agentbay-sdk/tree/main/docs/guides/mobile-use/README.md) - Android UI testing, mobile app automation
- 💻 [CodeSpace](https://github.com/aliyun/wuying-agentbay-sdk/tree/main/docs/guides/codespace/README.md) - Code execution, development environments

**Additional Resources:**
- [📖 Feature Guides](https://github.com/aliyun/wuying-agentbay-sdk/tree/main/docs/guides/README.md) - Complete feature introduction
- [🔧 Python API Reference](docs/api/README.md) - Detailed API documentation
- [💻 Python Examples](docs/examples/README.md) - Complete example code
- [📋 Logging Configuration](https://github.com/aliyun/wuying-agentbay-sdk/tree/main/docs/guides/common-features/configuration/logging.md) - Configure logging levels and output

### 🆘 Need Help

## 🔧 Core Features Quick Reference

### Session Management
```python
# Create session
result = agent_bay.create()
if result.success:
    session = result.session
# Verified: ✓ Session created successfully

# List sessions by labels with pagination
result = agent_bay.list(labels={"environment": "production"}, limit=10)
if result.success:
    session_ids = result.session_ids
# Verified: ✓ Sessions listed successfully with pagination support

# Delete session
delete_result = agent_bay.delete(session)
# Verified: ✓ Session deleted successfully
```

### File Operations
```python
# Read/write files
session.file_system.write_file("/path/file.txt", "content")
content = session.file_system.read_file("/path/file.txt")
# Verified: ✓ File operations work correctly
# content.content contains the file's text content

# List directory
files = session.file_system.list_directory("/path")
# Verified: ✓ Returns list of file/directory information
```

### Command Execution
```python
# Execute command
result = session.command.execute_command("python script.py")
print(result.output)
# Verified: ✓ Command executed successfully
# result.output contains the command's stdout
```

### Data Persistence
```python
# Create context
context = agent_bay.context.get("my-project", create=True).context
# Verified: ✓ Context created or retrieved successfully

# Create session with context
from agentbay.session_params import CreateSessionParams
from agentbay.context_sync import ContextSync, SyncPolicy
context_sync = ContextSync.new(context.id, "/tmp/data", SyncPolicy.default())
session = agent_bay.create(CreateSessionParams(context_syncs=[context_sync])).session
# Verified: ✓ Session created with context synchronization
# Data in /tmp/data will be synchronized to the context
```

## 🆘 Get Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Documentation](https://github.com/aliyun/wuying-agentbay-sdk/tree/main/docs/README.md)

## 📄 License

This project is licensed under the Apache License 2.0 - see the [LICENSE](../LICENSE) file for details.




# AgentBay Python SDK API Reference

Complete API reference documentation for the AgentBay Python SDK.

## 📚 Common Features

APIs available across all environments:

### Basics
- [**AgentBay**](common-features/basics/agentbay.md) - Main client for creating and managing sessions
- [**Session**](common-features/basics/session.md) - Session lifecycle and operations management
- [**Command**](common-features/basics/command.md) - Execute shell commands in cloud environments
- [**FileSystem**](common-features/basics/filesystem.md) - File and directory operations
- [**Context**](common-features/basics/context.md) - Data persistence and context management
- [**ContextManager**](common-features/basics/context-manager.md) - Context operations and file synchronization
- [**Logging**](common-features/basics/logging.md) - Logging configuration and management

### Advanced
- [**Agent**](common-features/advanced/agent.md) - AI agent integration and MCP tools
- [**OSS**](common-features/advanced/oss.md) - Object Storage Service integration

## 🚀 Environment-Specific Features

### Browser Use (`browser_latest`)
- [**Browser**](browser-use/browser.md) - Browser initialization and CDP connection
  - `initialize()` / `initialize_async()` - Initialize browser with configuration options
  - `get_endpoint_url()` - Get CDP WebSocket endpoint for Playwright/Puppeteer connection
  - Options: Stealth mode, proxy (custom/wuying), fingerprint, viewport, CAPTCHA solving
  - AI Agent: `agent.act()`, `agent.observe()`, `agent.extract()` for natural language automation
- [**Extension**](browser-use/extension.md) - Browser extension management and deployment

### Computer Use (`windows_latest`, `linux_latest`)
- [**Computer**](computer-use/computer.md) - Desktop automation operations
  - Mouse: `click_mouse()`, `move_mouse()`, `drag_mouse()`, `scroll()`, `get_cursor_position()`
  - Keyboard: `input_text()`, `press_keys()`, `release_keys()`
  - Screen: `screenshot()`, `get_screen_size()`
  - Window: `list_root_windows()`, `get_active_window()`, `activate_window()`, `close_window()`, `maximize_window()`, `minimize_window()`, `restore_window()`, `resize_window()`, `fullscreen_window()`, `focus_mode()`
  - Application: `get_installed_apps()`, `start_app()`, `list_visible_apps()`, `stop_app_by_pname()`, `stop_app_by_pid()`, `stop_app_by_cmd()`
- [**UI**](computer-use/ui.md) - ⚠️ Deprecated, use Computer or Mobile APIs instead
- [**Window**](computer-use/window.md) - ⚠️ Deprecated, use Computer API instead
- [**Application**](computer-use/application.md) - ⚠️ Deprecated, use Computer or Mobile APIs instead

### Mobile Use (`mobile_latest`)
- [**Mobile**](mobile-use/mobile.md) - Android mobile device automation
  - Touch: `tap()`, `swipe()`
  - Input: `input_text()`, `send_key()` (with KeyCode constants)
  - UI Elements: `get_clickable_ui_elements()`, `get_all_ui_elements()`
  - Application: `get_installed_apps()`, `start_app()`, `stop_app_by_cmd()`
  - Screen: `screenshot()`

### CodeSpace (`code_latest`)
- [**Code**](codespace/code.md) - Execute code in cloud environment
  - `run_code()` - Run Python or JavaScript code with timeout control
  - Supports: Python, JavaScript
  - Maximum execution time: 60 seconds (gateway limitation)

## 📘 Related Documentation

- [Feature Guides](../../../docs/guides/README.md) - Detailed usage guides and tutorials
- [Code Examples](../examples/README.md) - Complete example implementations
- [Quick Start](../../../docs/quickstart/README.md) - Get started in 5 minutes

---

**Need help?** Check out the [complete documentation](../../../docs/README.md) or [open an issue](https://github.com/aliyun/wuying-agentbay-sdk/issues).




# Browser API Reference

The Browser API provides methods for initializing and managing browser instances in the AgentBay cloud environment. It supports both headless and non-headless browsers with extensive configuration options including stealth mode, custom viewports, fingerprinting, proxies, and more.

## Overview

The Browser API is accessed through a session instance and provides methods for browser lifecycle management and connection to automation frameworks via Chrome DevTools Protocol (CDP).

```python
from agentbay import AgentBay
from agentbay.browser.browser import BrowserOption

# Access browser through session
session = result.session
browser_api = session.browser
```

## Classes

### BrowserOption

Configuration options for initializing a browser instance.

```python
class BrowserOption:
    def __init__(
        self,
        use_stealth: bool = False,
        user_agent: str = None,
        viewport: BrowserViewport = None,
        screen: BrowserScreen = None,
        fingerprint: BrowserFingerprint = None,
        solve_captchas: bool = False,
        proxies: Optional[list[BrowserProxy]] = None,
        extension_path: Optional[str] = "/tmp/extensions/",
        browser_type: Optional[Literal["chrome", "chromium"]] = None,
        cmd_args: Optional[list[str]] = None,
        default_navigate_url: Optional[str] = None,
    )
```

**Parameters:**

- `use_stealth` (bool): Enable stealth mode to avoid detection by anti-bot systems. Default: `False`
- `user_agent` (str | None): Custom user agent string for the browser. Default: `None`
- `viewport` (BrowserViewport | None): Browser viewport dimensions. Default: `None`
- `screen` (BrowserScreen | None): Screen dimensions. Default: `None`
- `fingerprint` (BrowserFingerprint | None): Browser fingerprint configuration. Default: `None`
- `solve_captchas` (bool): Automatically solve captchas during browsing. Default: `False`
- `proxies` (list[BrowserProxy] | None): List of proxy configurations (max 1). Default: `None`
- `extension_path` (str | None): Path to directory containing browser extensions. Default: `"/tmp/extensions/"`
- `browser_type` (Literal["chrome", "chromium"] | None): Browser type selection (computer use images only). Default: `None`
- `cmd_args` (list[str] | None): List of Chrome/Chromium command-line arguments to customize browser behavior. Default: `None`
- `default_navigate_url` (str | None): URL that the browser automatically navigates to after initialization. Recommended to use Chrome internal pages (e.g., `chrome://version/`) to avoid timeout issues. Default: `None`

**Methods:**

#### to_map()

Converts BrowserOption to a dictionary for API requests.

```python
def to_map(self) -> dict
```

**Returns:**
- `dict`: Dictionary representation of the browser options

**Example:**
```python
option = BrowserOption(use_stealth=True)
option_map = option.to_map()
```

#### from_map()

Creates BrowserOption from a dictionary.

```python
def from_map(self, m: dict = None) -> BrowserOption
```

**Parameters:**
- `m` (dict): Dictionary containing browser option data

**Returns:**
- `BrowserOption`: Self (for method chaining)

**Example:**
```python
option = BrowserOption()
option.from_map({"useStealth": True, "browserType": "chrome"})
```

### BrowserViewport

Defines the browser viewport dimensions.

```python
class BrowserViewport:
    def __init__(self, width: int, height: int):
        self.width = width
        self.height = height
```

**Parameters:**
- `width` (int): Viewport width in pixels
- `height` (int): Viewport height in pixels

**Common Viewport Sizes:**
```python
# Desktop
BrowserViewport(1920, 1080)
BrowserViewport(1366, 768)

# Laptop
BrowserViewport(1440, 900)

# Tablet
BrowserViewport(1024, 768)

# Mobile
BrowserViewport(375, 667)
BrowserViewport(414, 896)
```

### BrowserScreen

Defines the screen dimensions (usually same or larger than viewport).

```python
class BrowserScreen:
    def __init__(self, width: int, height: int):
        self.width = width
        self.height = height
```

**Parameters:**
- `width` (int): Screen width in pixels
- `height` (int): Screen height in pixels

### BrowserFingerprint

Configuration for browser fingerprint randomization.

```python
class BrowserFingerprint:
    def __init__(
        self,
        devices: list[str] = None,
        operating_systems: list[str] = None,
        locales: list[str] = None,
    ):
        self.devices = devices
        self.operating_systems = operating_systems
        self.locales = locales
```

**Parameters:**
- `devices` (list[str]): Device types - `["desktop", "mobile"]`
- `operating_systems` (list[str]): OS types - `["windows", "macos", "linux", "android", "ios"]`
- `locales` (list[str]): Locale strings - e.g., `["en-US", "zh-CN", "ja-JP"]`

**Example:**
```python
fingerprint = BrowserFingerprint(
    devices=["desktop"],
    operating_systems=["windows", "macos"],
    locales=["en-US", "en-GB"]
)
```

### BrowserProxy

Configuration for browser proxy settings.

```python
class BrowserProxy:
    def __init__(
        self,
        proxy_type: str,
        server: str = None,
        username: str = None,
        password: str = None,
        strategy: str = None,
        poll_size: int = None,
    ):
        self.proxy_type = proxy_type
        self.server = server
        self.username = username
        self.password = password
        self.strategy = strategy
        self.poll_size = poll_size
```

**Proxy Types:**

1. **Custom Proxy** (`proxy_type="custom"`):
   ```python
   proxy = BrowserProxy(
       proxy_type="custom",
       server="proxy.example.com:8080",
       username="user",
       password="pass"
   )
   ```

2. **WuYing Proxy** (`proxy_type="wuying"`):
   - **Restricted Strategy**: Single dedicated IP
     ```python
     proxy = BrowserProxy(
         proxy_type="wuying",
         strategy="restricted"
     )
     ```
   
   - **Polling Strategy**: Rotating IP pool
     ```python
     proxy = BrowserProxy(
         proxy_type="wuying",
         strategy="polling",
         poll_size=10
     )
     ```

**Validation Rules:**
- Maximum 1 proxy allowed in the `proxies` list
- `server` is required for `custom` type
- `strategy` is required for `wuying` type
- `poll_size` must be > 0 for `polling` strategy

## Browser Class

### Methods

#### initialize(option: BrowserOption) -> bool

Initializes the browser with the given options (synchronous).

```python
def initialize(self, option: BrowserOption) -> bool
```

**Parameters:**
- `option` (BrowserOption): Browser configuration options

**Returns:**
- `bool`: `True` if initialization was successful, `False` otherwise

**Raises:**
- `ValueError`: If browser option validation fails

**Example:**
```python
option = BrowserOption(
    use_stealth=True,
    user_agent="Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)",
    viewport=BrowserViewport(1920, 1080)
)

success = session.browser.initialize(option)
if not success:
    raise RuntimeError("Browser initialization failed")
```

#### initialize_async(option: BrowserOption) -> bool

Initializes the browser with the given options (asynchronous).

```python
async def initialize_async(self, option: BrowserOption) -> bool
```

**Parameters:**
- `option` (BrowserOption): Browser configuration options

**Returns:**
- `bool`: `True` if initialization was successful, `False` otherwise

**Raises:**
- `ValueError`: If browser option validation fails

**Example:**
```python
import asyncio

async def main():
    option = BrowserOption(browser_type="chrome")
    success = await session.browser.initialize_async(option)
    if not success:
        raise RuntimeError("Browser initialization failed")

asyncio.run(main())
```

#### get_endpoint_url() -> str

Retrieves the CDP (Chrome DevTools Protocol) endpoint URL for connecting automation tools.

```python
def get_endpoint_url(self) -> str
```

**Returns:**
- `str`: The CDP WebSocket endpoint URL (e.g., `ws://host:port/devtools/browser/...`)

**Raises:**
- `RuntimeError`: If browser is not initialized

**Example:**
```python
endpoint_url = session.browser.get_endpoint_url()

# Use with Playwright
from playwright.async_api import async_playwright

async with async_playwright() as p:
    browser = await p.chromium.connect_over_cdp(endpoint_url)
```

#### is_initialized() -> bool

Checks if the browser has been initialized.

```python
def is_initialized(self) -> bool
```

**Returns:**
- `bool`: `True` if the browser is initialized, `False` otherwise

**Example:**
```python
if session.browser.is_initialized():
    print("Browser is ready")
else:
    print("Browser needs initialization")
```

#### get_option() -> BrowserOption

Retrieves the current browser configuration.

```python
def get_option(self) -> BrowserOption | None
```

**Returns:**
- `BrowserOption | None`: The current browser configuration, or `None` if not initialized

**Example:**
```python
option = session.browser.get_option()
if option:
    print(f"Browser type: {option.browser_type}")
```

## Complete Usage Example

### Basic Usage

```python
import os
import asyncio
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams
from agentbay.browser.browser import BrowserOption
from playwright.async_api import async_playwright

async def main():
    # Initialize AgentBay
    api_key = os.getenv("AGENTBAY_API_KEY")
    agent_bay = AgentBay(api_key=api_key)

    # Create session
    params = CreateSessionParams(image_id="browser_latest")
    result = agent_bay.create(params)
    if not result.success:
        raise RuntimeError(f"Failed to create session: {result.error_message}")

    session = result.session

    try:
        # Initialize browser with default options
        option = BrowserOption()
        ok = await session.browser.initialize_async(option)
        if not ok:
            raise RuntimeError("Browser initialization failed")

        # Get CDP endpoint
        endpoint_url = session.browser.get_endpoint_url()

        # Connect with Playwright
        async with async_playwright() as p:
            browser = await p.chromium.connect_over_cdp(endpoint_url)
            context = browser.contexts[0]
            page = await context.new_page()

            # Navigate and interact
            await page.goto("https://example.com")
            title = await page.title()
            print(f"Page title: {title}")

            await browser.close()

    finally:
        session.delete()

if __name__ == "__main__":
    asyncio.run(main())
```

### Advanced Configuration

```python
from agentbay.browser.browser import (
    BrowserOption,
    BrowserViewport,
    BrowserScreen,
    BrowserFingerprint,
    BrowserProxy
)

# Create custom browser configuration
option = BrowserOption(
    # Custom user agent
    user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.0.0",
    
    # Viewport and screen
    viewport=BrowserViewport(width=1920, height=1080),
    screen=BrowserScreen(width=1920, height=1080),
    
    # Browser type (for computer use images)
    browser_type="chrome",
    
    # Stealth mode
    use_stealth=True,
    
    # Command-line arguments
    cmd_args=[
        "--disable-features=PrivacySandboxSettings4",
        "--disable-background-timer-throttling",
    ],
    
    # Default navigation URL (recommended: Chrome internal pages)
    default_navigate_url="chrome://version/",
    
    # Fingerprint randomization
    fingerprint=BrowserFingerprint(
        devices=["desktop"],
        operating_systems=["windows", "macos"],
        locales=["en-US"]
    ),
    
    # Proxy configuration
    proxies=[BrowserProxy(
        proxy_type="custom",
        server="proxy.example.com:8080",
        username="username",
        password="password"
    )]
)

# Initialize with custom options
success = await session.browser.initialize_async(option)
if not success:
    raise RuntimeError("Failed to initialize browser")
```

## Error Handling

### Common Errors

1. **Browser Not Initialized**
   ```python
   try:
       endpoint = session.browser.get_endpoint_url()
   except RuntimeError as e:
       # Error: "Browser not initialized"
       print("Initialize browser before getting endpoint")
   ```

2. **Invalid Configuration**
   ```python
   try:
       option = BrowserOption(browser_type="firefox")  # Invalid
       await session.browser.initialize_async(option)
   except ValueError as e:
       # Error: "browser_type must be 'chrome' or 'chromium'"
       print(f"Configuration error: {e}")
   ```

3. **Multiple Proxies**
   ```python
   try:
       option = BrowserOption(proxies=[proxy1, proxy2])
   except ValueError as e:
       # Error: "proxies list length must be limited to 1"
       print(f"Too many proxies: {e}")
   ```

### Best Practices

```python
# Check initialization status
if not session.browser.is_initialized():
    print("Browser not initialized")

# Always use try-finally for cleanup
try:
    ok = await session.browser.initialize_async(option)
    if not ok:
        raise RuntimeError("Initialization failed")
    
    # Use the browser...
    
finally:
    session.delete()

# Validate options if needed
try:
    option = BrowserOption(browser_type="chrome")
    # Validation happens in __init__
except ValueError as e:
    print(f"Invalid option: {e}")
```

## Browser Type Selection

> **Note:** The `browser_type` parameter is only available for **computer use images**. For standard browser images, the browser type is determined by the image.

### Choosing Browser Type

```python
# Use Chrome (Google Chrome)
option = BrowserOption(browser_type="chrome")

# Use Chromium (open-source)
option = BrowserOption(browser_type="chromium")

# Use default (None - let browser image decide)
option = BrowserOption()  # browser_type is None by default
```

### When to Use Each Type

**Chrome** (`"chrome"`):
- Need specific Chrome-only features
- Testing against actual Chrome browser
- Matching production Chrome environment

**Chromium** (`"chromium"`):
- Open-source preference
- Lighter resource usage
- Standard web automation

**Default** (`None`):
- Let the platform choose optimal browser
- Maximum compatibility
- Recommended for most use cases

## Integration with Automation Tools

### Playwright (Async)

```python
from playwright.async_api import async_playwright

# Get endpoint
endpoint_url = session.browser.get_endpoint_url()

# Connect Playwright
async with async_playwright() as p:
    browser = await p.chromium.connect_over_cdp(endpoint_url)
    context = browser.contexts[0]
    page = await context.new_page()
    
    # Use page...
    
    await browser.close()
```

### Playwright (Sync)

```python
from playwright.sync_api import sync_playwright

# Get endpoint
endpoint_url = session.browser.get_endpoint_url()

# Connect Playwright
with sync_playwright() as p:
    browser = p.chromium.connect_over_cdp(endpoint_url)
    context = browser.contexts[0]
    page = context.new_page()
    
    # Use page...
    
    browser.close()
```

### Puppeteer (via Node.js)

```python
# Get endpoint in Python
endpoint_url = session.browser.get_endpoint_url()
print(f"Use this endpoint in Node.js: {endpoint_url}")
```

```javascript
// In Node.js
const puppeteer = require('puppeteer-core');
const browser = await puppeteer.connect({
    browserWSEndpoint: 'ws://...' // endpoint from Python
});
```

## PageUseAgent Integration

The Browser class includes an `agent` property for AI-powered browser automation.

```python
from agentbay.browser.browser_agent import ActOptions

# Use PageUseAgent for natural language actions
act_result = await session.browser.agent.act_async(
    ActOptions(action="Click the sign in button"),
    page
)

if act_result.success:
    print(f"Action completed: {act_result.message}")
else:
    print(f"Action failed: {act_result.message}")
```

See the [PageUseAgent documentation](../../../../docs/guides/browser-use/advance-features/page-use-agent.md) for more details.

## Performance Considerations

### Resource Usage

- **Stealth Mode**: Adds overhead for anti-detection measures
- **Fingerprinting**: Randomization has minimal performance impact
- **Proxies**: May add latency depending on proxy location
- **Extensions**: Each extension increases memory usage

### Optimization Tips

1. **Reuse Sessions**: Keep sessions alive for multiple operations
2. **Appropriate Viewport**: Use actual target viewport size
3. **Minimal Extensions**: Only load necessary extensions
4. **Async Operations**: Use `initialize_async` for better concurrency

## Troubleshooting

### Browser Won't Initialize

```python
# Check session status
if not result.success:
    print(f"Session creation failed: {result.error_message}")

# Verify image supports browser
params = CreateSessionParams(image_id="browser_latest")

# Check initialization
success = await session.browser.initialize_async(option)
print(f"Initialization success: {success}")
```

### CDP Connection Fails

```python
# Ensure browser is initialized
if not session.browser.is_initialized():
    raise RuntimeError("Browser not initialized")

# Get and verify endpoint
endpoint_url = session.browser.get_endpoint_url()
print(f"Endpoint: {endpoint_url}")
```

### Configuration Issues

```python
# Check option values
option = BrowserOption(browser_type="chrome")
print(f"Browser type: {option.browser_type}")
print(f"Use stealth: {option.use_stealth}")

# Validate through initialization (validation happens in __init__)
try:
    option = BrowserOption(browser_type="firefox")  # Will raise ValueError
except ValueError as e:
    print(f"Invalid configuration: {e}")
```

## See Also

- [Browser Use Guide](../../../../docs/guides/browser-use/README.md) - Complete guide with examples
- [Core Features](../../../../docs/guides/browser-use/core-features.md) - Essential browser features
- [Advanced Features](../../../../docs/guides/browser-use/advance-features.md) - Advanced configuration
- [Browser Examples](../../examples/browser-use/browser/README.md) - Runnable example code
- [PageUseAgent API](../../../../docs/guides/browser-use/advance-features/page-use-agent.md) - AI-powered browser automation
- [Session Management](../common-features/basics/session.md) - Session lifecycle and management





# Extension API Reference

The Extension API provides functionality for managing browser extensions in the AgentBay cloud environment. This enables uploading, managing, and integrating browser extensions with cloud browser sessions for automated testing and development workflows.

## Import

```python
from agentbay import AgentBay
from agentbay.extension import ExtensionsService, ExtensionOption, Extension
from agentbay.session_params import CreateSessionParams, BrowserContext
```

## Extension Class

The `Extension` class represents a browser extension in the AgentBay cloud environment.

### Properties

```python
id          # The unique identifier of the extension (auto-generated)
name        # The name of the extension (typically filename)
created_at  # Date and time when the extension was uploaded (optional)
```

### Constructor

```python
Extension(id: str, name: str, created_at: Optional[str] = None)
```

**Parameters:**
- `id` (str): Unique extension identifier
- `name` (str): Extension name
- `created_at` (str, optional): Creation timestamp

## ExtensionOption Class

The `ExtensionOption` class encapsulates extension configuration for browser sessions.

### Properties

```python
context_id     # The context ID where extensions are stored
extension_ids  # List of extension IDs to include in browser sessions
```

### Constructor

```python
ExtensionOption(context_id: str, extension_ids: List[str])
```

**Parameters:**
- `context_id` (str): ID of the extension context
- `extension_ids` (List[str]): List of extension IDs to synchronize

**Raises:**
- `ValueError`: If context_id is empty or extension_ids is empty

### Methods

#### validate

Validates the extension option configuration.

```python
validate() -> bool
```

**Returns:**
- `bool`: True if configuration is valid, False otherwise

**Example:**
```python
ext_option = ExtensionOption("ctx_123", ["ext_1", "ext_2"])
if ext_option.validate():
    print("Configuration is valid")
else:
    print("Invalid configuration")
```

## ExtensionsService Class

The `ExtensionsService` class provides methods for managing browser extensions in the AgentBay cloud environment.

### Constructor

```python
ExtensionsService(agent_bay: AgentBay, context_id: str = "")
```

**Parameters:**
- `agent_bay` (AgentBay): The AgentBay client instance
- `context_id` (str, optional): Context ID or name. If empty, auto-generates a unique name

**Auto-Context Management:**
- If `context_id` is empty → generates `extensions-{timestamp}` automatically
- If `context_id` exists → uses existing context
- If `context_id` doesn't exist → creates new context with the provided name

### Properties

```python
context_id     # The actual context ID used for extension storage
context_name   # The context name (may be auto-generated)
auto_created   # Whether the context was auto-created by this service
```

### Methods

#### create

Uploads a new browser extension to the cloud context.

```python
create(local_path: str) -> Extension
```

**Parameters:**
- `local_path` (str): Path to the local extension ZIP file

**Returns:**
- `Extension`: Extension object with generated ID and metadata

**Raises:**
- `FileNotFoundError`: If the local file doesn't exist
- `ValueError`: If the file format is not supported (only ZIP files allowed)
- `AgentBayError`: If upload fails

**Example:**
```python
from agentbay import AgentBay
from agentbay.extension import ExtensionsService

# Initialize the SDK
agent_bay = AgentBay(api_key="your_api_key")

# Create extensions service
extensions_service = ExtensionsService(agent_bay)

# Upload extension
extension = extensions_service.create("/path/to/my-extension.zip")
print(f"Extension uploaded: {extension.name} (ID: {extension.id})")
```

#### list

Lists all extensions in the current context.

```python
list() -> List[Extension]
```

**Returns:**
- `List[Extension]`: List of all extensions in the context

**Raises:**
- `AgentBayError`: If listing fails

**Example:**
```python
# List all extensions
extensions = extensions_service.list()
for ext in extensions:
    print(f"Extension: {ext.name} (ID: {ext.id})")
```

#### update

Updates an existing extension with a new file.

```python
update(extension_id: str, new_local_path: str) -> Extension
```

**Parameters:**
- `extension_id` (str): ID of the extension to update
- `new_local_path` (str): Path to the new extension ZIP file

**Returns:**
- `Extension`: Updated extension object

**Raises:**
- `FileNotFoundError`: If the new local file doesn't exist
- `ValueError`: If the extension ID doesn't exist in the context
- `AgentBayError`: If update fails

**Example:**
```python
# Update existing extension
updated_ext = extensions_service.update("ext_123", "/path/to/updated-extension.zip")
print(f"Extension updated: {updated_ext.name}")
```

#### delete

Deletes an extension from the context.

```python
delete(extension_id: str) -> bool
```

**Parameters:**
- `extension_id` (str): ID of the extension to delete

**Returns:**
- `bool`: True if deletion was successful, False otherwise

**Example:**
```python
# Delete extension
success = extensions_service.delete("ext_123")
if success:
    print("Extension deleted successfully")
else:
    print("Failed to delete extension")
```

#### create_extension_option

**🎯 Recommended Method** - Creates an ExtensionOption without exposing context_id to users.

```python
create_extension_option(extension_ids: List[str]) -> ExtensionOption
```

**Parameters:**
- `extension_ids` (List[str]): List of extension IDs to include

**Returns:**
- `ExtensionOption`: Configuration object for browser extension integration

**Raises:**
- `ValueError`: If extension_ids is empty

**Key Benefits:**
- ✅ **No context_id needed**: Users only provide extension IDs
- ✅ **Automatic context handling**: Context ID is handled internally
- ✅ **Clean API**: Decouples users from internal context management

**Example:**
```python
from agentbay.session_params import CreateSessionParams, BrowserContext

# Create extensions
ext1 = extensions_service.create("/path/to/ext1.zip")
ext2 = extensions_service.create("/path/to/ext2.zip")

# Create extension option (no context_id needed!)
ext_option = extensions_service.create_extension_option([ext1.id, ext2.id])

# Use with BrowserContext for session creation
session_params = CreateSessionParams(
    browser_context=BrowserContext(
        context_id="browser_session",
        auto_upload=True,
        extension_option=ext_option
    )
)

session_result = agent_bay.create(session_params)
session = session_result.session
```

#### cleanup

Cleans up auto-created context if it was created by this service.

```python
cleanup() -> bool
```

**Returns:**
- `bool`: True if cleanup was successful or not needed, False if cleanup failed

**Note:** Only cleans up contexts that were auto-created by this service instance.

**Example:**
```python
try:
    # Use extensions service
    extensions_service = ExtensionsService(agent_bay)
    # ... extension operations
finally:
    # Always cleanup resources
    extensions_service.cleanup()
```

## BrowserContext Integration

Browser extensions are integrated with sessions through the `BrowserContext` class from `agentbay.session_params`.

### BrowserContext Constructor

```python
BrowserContext(
    context_id: str, 
    auto_upload: bool = True, 
    extension_option: Optional[ExtensionOption] = None
)
```

**Parameters:**
- `context_id` (str): ID of the browser context for the session
- `auto_upload` (bool): Whether to automatically upload browser data when session ends
- `extension_option` (Optional[ExtensionOption]): Extension configuration object

**Auto-Generated Properties:**

When `extension_option` is provided:
- `extension_context_id` (str): Extracted from ExtensionOption
- `extension_ids` (List[str]): Extracted from ExtensionOption
- `extension_context_syncs` (List[ContextSync]): Auto-generated context syncs

When `extension_option` is None:
- `extension_context_id` = None
- `extension_ids` = []
- `extension_context_syncs` = None

## Usage Patterns

### Basic Extension Management

```python
from agentbay import AgentBay
from agentbay.extension import ExtensionsService

# Initialize service
agent_bay = AgentBay(api_key="your_api_key")
extensions_service = ExtensionsService(agent_bay)

try:
    # Upload extensions
    ext1 = extensions_service.create("/path/to/extension1.zip")
    ext2 = extensions_service.create("/path/to/extension2.zip")
    
    # List extensions
    extensions = extensions_service.list()
    print(f"Total extensions: {len(extensions)}")
    
finally:
    # Clean up when done
    extensions_service.cleanup()
```

### Browser Session with Extensions

```python
from agentbay import AgentBay
from agentbay.extension import ExtensionsService
from agentbay.session_params import CreateSessionParams, BrowserContext

# Initialize and upload extensions
agent_bay = AgentBay(api_key="your_api_key")
extensions_service = ExtensionsService(agent_bay)

try:
    ext1 = extensions_service.create("/path/to/ext1.zip")
    ext2 = extensions_service.create("/path/to/ext2.zip")
    
    # Create extension option (simplified - no context_id needed!)
    extension_option = extensions_service.create_extension_option([ext1.id, ext2.id])
    
    # Create browser session with extensions
    session_params = CreateSessionParams(
        labels={"purpose": "extension_testing"},
        browser_context=BrowserContext(
            context_id="my_browser_session",
            auto_upload=True,
            extension_option=extension_option  # All extension config here
        )
    )
    
    # Create session
    session_result = agent_bay.create(session_params)
    session = session_result.session
    
    # Extensions are automatically synchronized to /tmp/extensions/ in the session
    print("Session created with extensions!")
    
finally:
    extensions_service.cleanup()
```

### Error Handling

```python
from agentbay import AgentBay
from agentbay.extension import ExtensionsService
from agentbay.exceptions import AgentBayError

try:
    agent_bay = AgentBay(api_key="your_api_key")
    extensions_service = ExtensionsService(agent_bay, "my_extensions")
    
    # Upload extension with validation
    extension_path = "/path/to/my-extension.zip"
    if not os.path.exists(extension_path):
        raise FileNotFoundError(f"Extension file not found: {extension_path}")
    
    extension = extensions_service.create(extension_path)
    print(f"✅ Extension uploaded successfully: {extension.id}")
    
    # Create extension option
    ext_option = extensions_service.create_extension_option([extension.id])
    
    if not ext_option.validate():
        raise ValueError("Invalid extension configuration")
    
    print(f"✅ Extension option created: {ext_option}")
    
except FileNotFoundError as e:
    print(f"❌ File error: {e}")
except ValueError as e:
    print(f"❌ Validation error: {e}")
except AgentBayError as e:
    print(f"❌ AgentBay error: {e}")
except Exception as e:
    print(f"❌ Unexpected error: {e}")
finally:
    if 'extensions_service' in locals():
        extensions_service.cleanup()
```

## File Location in Sessions

In browser sessions, extensions are automatically synchronized to:
```
/tmp/extensions/{extension_id}/
```

Each extension gets its own directory containing all extension files, including `manifest.json` and other extension assets.

## Related Resources

- [Session API Reference](../common-features/basics/session.md)
- [Context API Reference](../common-features/basics/context.md) 
- [AgentBay API Reference](../common-features/basics/agentbay.md)
- [Extension Examples](../../examples/browser-use/extension/README.md) - Practical usage examples
- [Browser Extensions Guide](../../../../docs/guides/browser-use/browser-extensions.md) - Complete tutorial



# Code Module - Python

The Code module handles code execution operations in the AgentBay cloud environment.

## 📖 Related Tutorial

- [Code Execution Guide](../../../../docs/guides/codespace/code-execution.md) - Detailed tutorial on executing code in cloud environments

## Methods

### run_code

Executes code in a specified programming language with a timeout.

```python
run_code(code: str, language: str, timeout_s: int = 60) -> CodeExecutionResult
```

**Parameters:**
- `code` (str): The code to execute.
- `language` (str): The programming language of the code. Must be either 'python' or 'javascript'.
- `timeout_s` (int, optional): The timeout for the code execution in seconds. Default is 60s. Note: Due to gateway limitations, each request cannot exceed 60 seconds.

**Returns:**
- `CodeExecutionResult`: A result object containing success status, execution result, error message if any, and request ID.

**Important Note:**
The `run_code` method requires a session created with the `code_latest` image to function properly. If you encounter errors indicating that the tool is not found, make sure to create your session with `image_id="code_latest"` in the `CreateSessionParams`.

**Usage Example:**

```python
import os
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams

# Initialize AgentBay with API key
api_key = os.getenv("AGENTBAY_API_KEY")
agent_bay = AgentBay(api_key=api_key)

# Create a session with code_latest image
params = CreateSessionParams(image_id="code_latest")
session_result = agent_bay.create(params)
if session_result.success:
    session = session_result.session
else:
    print(f"Failed to create session: {session_result.error_message}")
    exit(1)

# Execute Python code
python_code = """
print("Hello from Python!")
result = 2 + 3
print(f"Result: {result}")
"""

code_result = session.code.run_code(python_code, "python")
if code_result.success:
    print(f"Python code output:\n{code_result.result}")
    # Expected output:
    # Hello from Python!
    # Result: 5
    print(f"Request ID: {code_result.request_id}")
    # Expected: A valid UUID-format request ID
else:
    print(f"Code execution failed: {code_result.error_message}")

# Execute JavaScript code
js_code = """
console.log("Hello from JavaScript!");
const result = 2 + 3;
console.log("Result:", result);
"""

js_result = session.code.run_code(js_code, "javascript", timeout_s=30)
if js_result.success:
    print(f"JavaScript code output:\n{js_result.result}")
    # Expected output:
    # Hello from JavaScript!
    # Result: 5
    print(f"Request ID: {js_result.request_id}")
    # Expected: A valid UUID-format request ID
else:
    print(f"Code execution failed: {js_result.error_message}")
```

## Error Handling

The run_code method returns a CodeExecutionResult with `success=False` if:
- The specified language is not supported (only 'python' and 'javascript' are supported)
- The code execution fails in the cloud environment
- Network or API communication errors occur

In these cases, the `error_message` field will contain details about the failure.

## Types

### CodeExecutionResult

```python
class CodeExecutionResult(ApiResponse):
    def __init__(
        self,
        request_id: str = "",
        success: bool = False,
        result: str = "",
        error_message: str = "",
    ):
        # Inherits request_id from ApiResponse
        self.success = success        # Whether the operation was successful
        self.result = result          # The execution result/output
        self.error_message = error_message  # Error message if failed
``` 



# Agent Class API Reference

The `Agent` class provides AI-powered capabilities for executing tasks, checking task status, and terminating tasks within a session. It enables natural language task execution and monitoring.

**⚠️ Important Note**: The Agent functionality is verified on the `windows_latest` system image.

## 📖 Related Tutorial

- [Agent Modules Guide](../../../../../docs/guides/common-features/advanced/agent-modules.md) - Detailed tutorial on AI-powered automation with Agent modules

## Constructor

### Agent

```python
Agent(session)
```

**Parameters:**
- `session` (Session): The Session instance that this Agent belongs to.

## Methods

### execute_task

Executes a specific task described in human language.
This is a synchronous interface that blocks until the task is completed or an error occurs, or timeout happens.
There is a timeout mechanism to prevent infinite loops by setting the `max_try_times` parameter. The default polling interval is 3 seconds, so set a proper `max_try_times` according to your task complexity.

```python
execute_task(task: str, max_try_times: int) -> ExecutionResult
```

**Parameters:**
- `task` (str): Task description in human language.
- `max_try_times` (int): Maximum number of retry attempts.

**Returns:**
- `ExecutionResult`: Result object containing success status, task ID, task status, and error message if any.

**Example:**
```python
from agentbay import AgentBay

# Initialize the SDK
agent_bay = AgentBay(api_key="your_api_key")

# Create a session with windows_latest image
from agentbay.session_params import CreateSessionParams
params = CreateSessionParams(image_id="windows_latest")
session_result = agent_bay.create(params)
if session_result.success:
    session = session_result.session
    
    # Execute a task using the Agent
    task_description = "Find the current weather in New York City"
    execution_result = session.agent.execute_task(task_description, max_try_times=10)
    
    if execution_result.success:
        print(f"Task completed successfully with status: {execution_result.task_status}")
        print(f"Task completed successfully with result: {execution_result.task_result}")
        print(f"Task ID: {execution_result.task_id}")
    else:
        print(f"Task failed: {execution_result.error_message}")
```

### async_execute_task

Executes a specific task described in human language.
This is a asynchronous interface that returns immediately with a task ID. Call `get_task_status` to check the task status.
You can control the timeout of the task execution in your own code by setting the frequence of calling get_task_status and the max_try_times.

```python
async_execute_task(task: str) -> ExecutionResult
```

**Parameters:**
- `task` (str): Task description in human language.

**Returns:**
- `ExecutionResult`: Result object containing success status, task ID, task status, and error message if any.

**Example:**
```python
import time
from agentbay import AgentBay


# Initialize the SDK
agent_bay = AgentBay(api_key="your_api_key")

# Create a session with windows_latest image
from agentbay.session_params import CreateSessionParams
params = CreateSessionParams(image_id="windows_latest")
session_result = agent_bay.create(params)
if session_result.success:
    session = session_result.session
    
    # Execute a task using the Agent
    task_description = "Find the current weather in New York City"
    execution_result = session.agent.async_execute_task(task_description)
    max_retry_times = 50  # Set your own max retry times
    if execution_result.success:
        retry_times = 0
        while retry_times < max_retry_times:
            query_result = session.agent.get_task_status(execution_result.task_id)
            print(
                f"⏳ Task {query_result.task_id} running 🚀: {query_result.task_action}."
            )
            if query_result.task_status == "finished":
                break
            retry_times += 1
            time.sleep(3)
        # Check if task completed within max retry times
        if retry_times < max_retry_times:
            print(
                f"Task completed successfully with status: {query_result.task_status}"
            )
            print(
                f"Task completed successfully with result: {query_result.task_result}"
            )
        else:
            print(f"Task execution timeout!")
    else:
        print(f"Task failed: {execution_result.error_message}")
```

### get_task_status

Gets the status of the task with the given task ID.

```python
get_task_status(task_id: str) -> QueryResult
```

**Parameters:**
- `task_id` (str): Task ID

**Returns:**
- `QueryResult`: Result object containing success status, output, and error message if any.

**Example:**
```python
# Get the status of a specific task
task_id = "task_12345"
status_result = session.agent.get_task_status(task_id)

if status_result.success:
    print(f"Task output: {status_result.task_status}")
    print(f"Task output: {status_result.task_product}")
    print(f"Task output: {status_result.task_action}")
else:
    print(f"Failed to get task status: {status_result.error_message}")
```

### terminate_task

Terminates a task with a specified task ID.

```python
terminate_task(task_id: str) -> ExecutionResult
```

**Parameters:**
- `task_id` (str): The ID of the running task.

**Returns:**
- `ExecutionResult`: Result object containing success status, task ID, task status, and error message if any.

**Example:**
```python
# Terminate a running task
task_id = "task_12345"
terminate_result = session.agent.terminate_task(task_id)

if terminate_result.success:
    print(f"Task terminated successfully with status: {terminate_result.task_status}")
else:
    print(f"Failed to terminate task: {terminate_result.error_message}")
```



# OSS API Reference

The OSS (Object Storage Service) module provides functionality for interacting with cloud storage services.

## 📖 Related Tutorial

- [OSS Integration Guide](../../../../../docs/guides/common-features/advanced/oss-integration.md) - Detailed tutorial on integrating with Object Storage Service

## OSS Class

The `OSS` class provides methods for OSS operations.

### env_init

Creates and initializes OSS environment variables with the specified credentials.

```python
def env_init(self, access_key_id: str, access_key_secret: str, securityToken: Optional[str] = None,
                 endpoint: Optional[str] = None, region: Optional[str] = None) -> OSSClientResult
```

**Parameters:**
- `access_key_id`: The Access Key ID for OSS authentication.
- `access_key_secret`: The Access Key Secret for OSS authentication.
- `securityToken`: The security token for OSS authentication. Optional.
- `endpoint`: The OSS service endpoint. If not specified, the default is used.
- `region`: The OSS region. If not specified, the default is used.

**Returns:**
- `OSSClientResult`: Result object containing client configuration, request ID, success status, and error message if any.

**OSSClientResult Structure:**
```python
class OSSClientResult(ApiResponse):
    def __init__(self, request_id: str = "", success: bool = False,
                 client_config: Optional[Dict[str, Any]] = None, error_message: str = "")
```

**Example:**
```python
from agentbay import AgentBay

# Initialize the SDK
agent_bay = AgentBay(api_key="your_api_key")

# Initialize OSS environment
result = agent_bay.oss.env_init(
    access_key_id="your_access_key_id",
    access_key_secret="your_access_key_secret",
    securityToken="your_security_token",
    endpoint="oss-cn-hangzhou.aliyuncs.com",
    region="cn-hangzhou"
)

if result.success:
    print(f"OSS environment initialized successfully, request ID: {result.request_id}")
else:
    print(f"Failed to initialize OSS environment: {result.error_message}")
```

### upload

**Note: Before calling this API, you must first call `env_init` to initialize the OSS environment.**

Uploads a local file or directory to OSS.

```python
def upload(self, bucket: str, object: str, path: str) -> OSSUploadResult
```

**Parameters:**
- `bucket`: OSS bucket name.
- `object`: Object key in OSS.
- `path`: Local file or directory path to upload.

**Returns:**
- `OSSUploadResult`: Result object containing upload result, request ID, success status, and error message if any.

**OSSUploadResult Structure:**
```python
class OSSUploadResult(ApiResponse):
    def __init__(self, request_id: str = "", success: bool = False,
                 content: str = "", error_message: str = "")
```

**Example:**
```python
from agentbay import AgentBay

# Initialize SDK
agent_bay = AgentBay(api_key="your_api_key")

# Step 1: Initialize OSS environment
agent_bay.oss.env_init(
    access_key_id="your_access_key_id",
    access_key_secret="your_access_key_secret",
    securityToken="your_security_token",
    endpoint="oss-cn-hangzhou.aliyuncs.com",
    region="cn-hangzhou"
)

# Step 2: Upload file
result = agent_bay.oss.upload("my-bucket", "my-object", "/path/to/local/file")
print("File uploaded successfully:", result)
```

### upload_anonymous

**Note: Before calling this API, you must first call `env_init` to initialize the OSS environment.**

Uploads a local file or directory to a URL anonymously.

```python
def upload_anonymous(self, url: str, path: str) -> OSSUploadResult
```

**Parameters:**
- `url`: The HTTP/HTTPS URL to upload the file to.
- `path`: Local file or directory path to upload.

**Returns:**
- `OSSUploadResult`: Result object containing upload result, request ID, success status, and error message if any.

**Example:**
```python
from agentbay import AgentBay

# Initialize the SDK
agent_bay = AgentBay(api_key="your_api_key")

# Upload file anonymously
result = agent_bay.oss.upload_anonymous("https://example.com/upload", "/path/to/local/file")

if result.success:
    print(f"File uploaded anonymously successfully, content: {result.content}")
    print(f"Request ID: {result.request_id}")
else:
    print(f"Failed to upload file anonymously: {result.error_message}")
```

**Example:**
```python
from agentbay import AgentBay

# Initialize SDK
agent_bay = AgentBay(api_key="your_api_key")

# Step 1: Initialize OSS environment
agent_bay.oss.env_init(
    access_key_id="your_access_key_id",
    access_key_secret="your_access_key_secret",
    securityToken="your_security_token",
    endpoint="oss-cn-hangzhou.aliyuncs.com",
    region="cn-hangzhou"
)

# Step 2: Upload file anonymously
result = agent_bay.oss.upload_anonymous("https://example.com/upload", "/path/to/local/file")
print("File uploaded anonymously:", result)
```

### download

**Note: Before calling this API, you must first call `env_init` to initialize the OSS environment.**

Downloads an object from OSS to a local file or directory.

```python
def download(self, bucket: str, object: str, path: str) -> OSSDownloadResult
```

**Parameters:**
- `bucket`: OSS bucket name.
- `object`: Object key in OSS.
- `path`: Local path to save the downloaded file.

**Returns:**
- `OSSDownloadResult`: Result object containing download result, request ID, success status, and error message if any.

**OSSDownloadResult Structure:**
```python
class OSSDownloadResult(ApiResponse):
    def __init__(self, request_id: str = "", success: bool = False,
                 content: str = "", error_message: str = "")
```

**Example:**
```python
from agentbay import AgentBay

# Initialize SDK
agent_bay = AgentBay(api_key="your_api_key")

# Step 1: Initialize OSS environment
agent_bay.oss.env_init(
    access_key_id="your_access_key_id",
    access_key_secret="your_access_key_secret",
    securityToken="your_security_token",
    endpoint="oss-cn-hangzhou.aliyuncs.com",
    region="cn-hangzhou"
)

# Step 2: Download file
result = agent_bay.oss.download("my-bucket", "my-object", "/path/to/local/file")
print("File downloaded successfully:", result)
```

### download_anonymous

**Note: Before calling this API, you must first call `env_init` to initialize the OSS environment.**

Downloads a file from a URL anonymously to a local file path.

```python
def download_anonymous(self, url: str, path: str) -> OSSDownloadResult
```

**Parameters:**
- `url`: The HTTP/HTTPS URL to download the file from.
- `path`: Local file or directory path to download to.

**Returns:**
- `OSSDownloadResult`: Result object containing download content, request ID, success status, and error message if any.

**Example:**
```python
from agentbay import AgentBay

# Initialize the SDK
agent_bay = AgentBay(api_key="your_api_key")

# Download file anonymously
result = agent_bay.oss.download_anonymous("https://example.com/file.txt", "/path/to/local/file.txt")

if result.success:
    print(f"File downloaded anonymously successfully, content: {result.content}")
    print(f"Request ID: {result.request_id}")
else:
    print(f"Failed to download file anonymously: {result.error_message}")
```

**Example:**
```python
from agentbay import AgentBay

# Initialize SDK
agent_bay = AgentBay(api_key="your_api_key")

# Step 1: Initialize OSS environment
agent_bay.oss.env_init(
    access_key_id="your_access_key_id",
    access_key_secret="your_access_key_secret",
    securityToken="your_security_token",
    endpoint="oss-cn-hangzhou.aliyuncs.com",
    region="cn-hangzhou"
)

# Step 2: Download file anonymously
result = agent_bay.oss.download_anonymous("https://example.com/file.txt", "/path/to/local/file.txt")
print("File downloaded anonymously:", result)
```

## Related Resources

- [Filesystem API Reference](../basics/filesystem.md)
- [Session API Reference](../basics/session.md)





# AgentBay Class API Reference

The `AgentBay` class is the main entry point for interacting with the AgentBay cloud environment. It provides methods for creating, retrieving, listing, and deleting sessions.

## 📖 Related Tutorials

- [SDK Configuration Guide](../../../../../docs/guides/common-features/configuration/sdk-configuration.md) - Detailed tutorial on configuring the SDK
- [VPC Sessions Guide](../../../../../docs/guides/common-features/advanced/vpc-sessions.md) - Tutorial on creating sessions in VPC environments
- [Session Link Access Guide](../../../../../docs/guides/common-features/advanced/session-link-access.md) - Tutorial on accessing sessions via links

## Constructor

### AgentBay

```python
AgentBay(api_key=None, cfg=None)
```

**Parameters:**
- `api_key` (str, optional): The API key for authentication. If not provided, the SDK will look for the `AGENTBAY_API_KEY` environment variable.
- `cfg` (Config, optional): Configuration object containing endpoint and timeout_ms. If not provided, default configuration is used.

**Raises:**
- `ValueError`: If no API key is provided and `AGENTBAY_API_KEY` environment variable is not set.

## Properties

###

```python
context
```
A `ContextService` instance for managing persistent contexts. See the [Context API Reference](context.md) for more details.

## Methods

Creates a new session in the AgentBay cloud environment.

```python
create(params: Optional[CreateSessionParams] = None) -> SessionResult
```

**Parameters:**
- `params` (CreateSessionParams, optional): Parameters for session creation. If None, default parameters will be used.

**Returns:**
- `SessionResult`: A result object containing the new Session instance, success status, request ID, and error message if any.

**Behavior:**
- When `params` includes valid `persistence_data_list`, after creating the session, the API will internally wait for context synchronization to complete.
- It will retrieve ContextStatusData via `session.context.info` and continuously monitor all data items' Status until all items show either "Success" or "Failed" status, or until the maximum retry limit (150 times with 2-second intervals) is reached.
- Any "Failed" status items will have their error messages printed.
- The create operation only returns after context status checking completes.

**Raises:**
- `AgentBayError`: If the session creation fails due to API errors or other issues.

**Example:**
```python
from agentbay import AgentBay, Config
from agentbay.session_params import CreateSessionParams
from agentbay.context_sync import ContextSync, SyncPolicy

# Initialize the SDK with default configuration
agent_bay = AgentBay(api_key="your_api_key")

# Or initialize with custom configuration
config = Config(
    endpoint="https://agentbay.example.com",
    timeout_ms=30000
)
agent_bay_with_config = AgentBay(api_key="your_api_key", cfg=config)

# Create a session with default parameters
default_result = agent_bay.create()
if default_result.success:
    default_session = default_result.session
    print(f"Created session with ID: {default_session.session_id}")

# Create a session with custom parameters
params = CreateSessionParams(
    image_id="linux_latest",
    labels={"project": "demo", "environment": "testing"},
    enable_browser_replay=True  # Enable browser replay for browser sessions
)
custom_result = agent_bay.create(params)
if custom_result.success:
    custom_session = custom_result.session
    print(f"Created custom session with ID: {custom_session.session_id}")

# Create a session with context synchronization
context_sync = ContextSync.new(
    context_id="your_context_id",
    path="/mnt/persistent",
    policy=SyncPolicy.default()
)
sync_params = CreateSessionParams(
    image_id="linux_latest",
    context_syncs=[context_sync]
)
sync_result = agent_bay.create(sync_params)
if sync_result.success:
    sync_session = sync_result.session
    print(f"Created session with context sync: {sync_session.session_id}")

# Create a browser session with browser replay enabled
browser_params = CreateSessionParams(
    image_id="browser_latest",
    enable_browser_replay=True,  # Enable browser replay
)
browser_result = agent_bay.create(browser_params)
if browser_result.success:
    browser_session = browser_result.session
    print(f"Created browser session with replay: {browser_session.session_id}")
    # Browser replay files are automatically generated for internal processing

# Create a mobile session with configuration
from agentbay.api.models import ExtraConfigs, MobileExtraConfig, AppManagerRule

app_whitelist_rule = AppManagerRule(
    rule_type="White",
    app_package_name_list=[
        "com.android.settings",
        "com.example.trusted.app",
        "com.system.essential.service"
    ]
)
mobile_config = MobileExtraConfig(
    lock_resolution=True,  # Lock screen resolution for consistent testing
    app_manager_rule=app_whitelist_rule,
    hide_navigation_bar=True,  # Hide navigation bar for immersive experience
    uninstall_blacklist=[  # Protect critical apps from uninstallation
        "com.android.systemui",
        "com.android.settings",
        "com.google.android.gms"
    ]
)
extra_configs = ExtraConfigs(mobile=mobile_config)

mobile_params = CreateSessionParams(
    image_id="mobile_latest",
    labels={"project": "mobile-testing", "config_type": "whitelist"},
    extra_configs=extra_configs
)
mobile_result = agent_bay.create(mobile_params)
if mobile_result.success:
    mobile_session = mobile_result.session
    print(f"Created mobile session with whitelist: {mobile_session.session_id}")

# Create a mobile session with blacklist configuration
app_blacklist_rule = AppManagerRule(
    rule_type="Black",
    app_package_name_list=[
        "com.malware.suspicious",
        "com.unwanted.adware",
        "com.social.distraction"
    ]
)
mobile_security_config = MobileExtraConfig(
    lock_resolution=False,  # Allow adaptive resolution
    app_manager_rule=app_blacklist_rule,
    hide_navigation_bar=False,  # Show navigation bar (default behavior)
    uninstall_blacklist=["com.android.systemui"]  # Protect system UI from uninstallation
)
security_extra_configs = ExtraConfigs(mobile=mobile_security_config)

mobile_security_params = CreateSessionParams(
    image_id="mobile_latest",
    labels={"project": "mobile-security", "config_type": "blacklist", "security": "enabled"},
    extra_configs=security_extra_configs
)
security_result = agent_bay.create(mobile_security_params)
if security_result.success:
    security_session = security_result.session
    print(f"Created secure mobile session with blacklist: {security_session.session_id}")
```

### get

Retrieves a session by its ID.

```python
get(session_id: str) -> SessionResult
```

**Parameters:**
- `session_id` (str): The ID of the session to retrieve.

**Returns:**
- `SessionResult`: A result object containing the Session instance, request ID, success status, and error message if any.

**Example:**
```python
from agentbay import AgentBay

agentbay = AgentBay(api_key="your_api_key")

create_result = agentbay.create()
if not create_result.success:
    print(f"Failed to create session: {create_result.error_message}")
    exit(1)

session_id = create_result.session.session_id
print(f"Created session with ID: {session_id}")
# Output: Created session with ID: session-xxxxxxxxxxxxxx

result = agentbay.get(session_id)
if result.success:
    print(f"Successfully retrieved session: {result.session.session_id}")
    # Output: Successfully retrieved session: session-xxxxxxxxxxxxxx
    print(f"Request ID: {result.request_id}")
    # Output: Request ID: XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
    
    delete_result = result.session.delete()
    if delete_result.success:
        print(f"Session {session_id} deleted successfully")
        # Output: Session session-xxxxxxxxxxxxxx deleted successfully
else:
    print(f"Failed to get session: {result.error_message}")
```



```python
list_by_labels(params: Optional[Union[ListSessionParams, Dict[str, str]]] = None) -> SessionListResult
```

**Parameters:**
- `params` (ListSessionParams or Dict[str, str], optional): Parameters for filtering sessions by labels. If a dictionary is provided, it will be treated as labels. If None, all sessions will be returned.

**Returns:**
- `SessionListResult`: A result object containing the filtered sessions, pagination information, and request ID.

**Raises:**
- `AgentBayError`: If the session listing fails.

**Example:**
```python
from agentbay import AgentBay
from agentbay.session_params import ListSessionParams

# Initialize the SDK
agent_bay = AgentBay(api_key="your_api_key")

# Create pagination parameters
params = ListSessionParams(
    max_results=10,  # Maximum results per page
    next_token="",   # Token for the next page, empty for the first page
    labels={"environment": "production", "project": "demo"}  # Filter labels
)

# Get the first page of results
result = agent_bay.list_by_labels(params)

# Process the results
if result.success:
    # Print the current page sessions
    for session in result.sessions:
        print(f"Session ID: {session.session_id}")

    # Print pagination information
    print(f"Total count: {result.total_count}")
    print(f"Max results per page: {result.max_results}")
    print(f"Next token: {result.next_token}")

    # If there is a next page, retrieve it
    if result.next_token:
        params.next_token = result.next_token
        next_page_result = agent_bay.list_by_labels(params)
        # Process the next page...
```

### list

Returns paginated list of Sessions filtered by labels.

```python
list(labels: Optional[Dict[str, str]] = None, page: Optional[int] = None, limit: Optional[int] = None) -> SessionListResult
```

**Parameters:**
- `labels` (Optional[Dict[str, str]], optional): Labels to filter Sessions. Defaults to None (empty dict, returns all sessions).
- `page` (Optional[int], optional): Page number for pagination (starting from 1). Defaults to None (returns first page).
- `limit` (Optional[int], optional): Maximum number of items per page. Defaults to None (uses default of 10).

**Returns:**
- `SessionListResult`: Paginated list of session IDs that match the labels, including request_id, success status, and pagination information.

**Key Features:**
- **Simple Interface**: Pass labels directly as a dictionary parameter
- **Pagination Support**: Use `page` and `limit` parameters for easy pagination
- **Request ID**: All responses include a `request_id` for tracking and debugging
- **Flexible Filtering**: Filter by any combination of labels or list all sessions

**Example:**
```python
from agentbay import AgentBay

agent_bay = AgentBay(api_key="your_api_key")

# List all sessions
result = agent_bay.list()

# List sessions with specific labels
result = agent_bay.list(labels={"project": "demo"})

# List sessions with pagination (page 2, 10 items per page)
result = agent_bay.list(labels={"my-label": "my-value"}, page=2, limit=10)

if result.success:
    for session_id in result.session_ids:
        print(f"Session ID: {session_id}")
    print(f"Total count: {result.total_count}")
    print(f"Request ID: {result.request_id}")
else:
    print(f"Error: {result.error_message}")
```

### delete

```python
delete(session: Session, sync_context: bool = False) -> DeleteResult
```

**Parameters:**
- `session` (Session): The session to delete.
- `sync_context` (bool, optional): If True, the API will trigger a file upload via `session.context.sync` before actually releasing the session. Default is False.

**Returns:**
- `DeleteResult`: A result object containing success status, request ID, and error message if any.

**Behavior:**
- When `sync_context` is True, the API will first call `session.context.sync` to trigger file upload.
- It will then check `session.context.info` to retrieve ContextStatusData and monitor all data items' Status.
- The API waits until all items show either "Success" or "Failed" status, or until the maximum retry limit (150 times with 2-second intervals) is reached.
- Any "Failed" status items will have their error messages printed.
- The session deletion only proceeds after context sync status checking completes.

**Raises:**
- `AgentBayError`: If the session deletion fails.

**Example:**
```python
from agentbay import AgentBay

# Initialize the SDK
agent_bay = AgentBay(api_key="your_api_key")

# Create a session
result = agent_bay.create()
if result.success:
    session = result.session
    print(f"Created session with ID: {session.session_id}")

    # Use the session for operations...

    # Delete the session when done
    delete_result = agent_bay.delete(session)
    if delete_result.success:
        print("Session deleted successfully")
    else:
        print(f"Failed to delete session: {delete_result.error_message}")
```




# Command Class API Reference

The `Command` class provides methods for executing commands within a session in the AgentBay cloud environment.

## 📖 Related Tutorial

- [Command Execution Guide](../../../../../docs/guides/common-features/basics/command-execution.md) - Detailed tutorial on executing shell commands

## Methods

### execute_command

Executes a shell command in the cloud environment.

```python
execute_command(command: str, timeout_ms: int = 1000) -> CommandResult
```

**Parameters:**
- `command` (str): The command to execute.
- `timeout_ms` (int, optional): The timeout for the command execution in milliseconds. Default is 1000ms.

**Returns:**
- `CommandResult`: A result object containing the command output, success status, request ID, and error message if any.

**Usage Example:**

```python
import os
from agentbay import AgentBay

# Initialize AgentBay with API key
api_key = os.getenv("AGENTBAY_API_KEY")
ab = AgentBay(api_key=api_key)

# Create a session
session_result = ab.create()
session = session_result.session

# Execute a command with default timeout (1000ms)
result = session.command.execute_command("ls -la")
if result.success:
    print(f"Command output:\n{result.output}")
    # Expected output: Directory listing showing files and folders
    print(f"Request ID: {result.request_id}")
    # Expected: A valid UUID-format request ID
else:
    print(f"Command execution failed: {result.error_message}")

# Execute a command with custom timeout (5000ms)
result_with_timeout = session.command.execute_command("sleep 2 && echo 'Done'", timeout_ms=5000)
if result_with_timeout.success:
    print(f"Command output: {result_with_timeout.output}")
    # Expected output: "Done\n"
    # The command waits 2 seconds then outputs "Done"
else:
    print(f"Command execution failed: {result_with_timeout.error_message}")

# Note: If a command exceeds its timeout, it will return an error
# Example: session.command.execute_command("sleep 3", timeout_ms=1000)
# Returns error: "Error in response: Execution failed. Error code:-1 Error message: [timeout]"
```

## Related Resources

- [Session Class](session.md): The session class that provides access to the Command class.
- [Code Class](../../codespace/code.md): For executing Python and JavaScript code.
- [FileSystem Class](filesystem.md): Provides methods for file operations within a session.




# ContextManager API Reference

The `ContextManager` class provides functionality for managing contexts within a session. It enables you to interact with the contexts that are synchronized to the session, including reading and writing data, and managing file operations.

## 📖 Related Tutorial

- [Data Persistence Guide](../../../../../docs/guides/common-features/basics/data-persistence.md) - Detailed tutorial on context management and data persistence

## Overview

The `ContextManager` is accessed through a session instance (`session.context`) and provides functionality for managing contexts within that session.

## Properties

```python
session  # The Session instance that this ContextManager belongs to
```

## Data Types

```python
class ContextStatusData:
    context_id: str     # The ID of the context
    path: str           # The path where the context is mounted
    error_message: str  # Error message if the operation failed
    status: str         # Status of the synchronization task
    start_time: int     # Start time of the task (Unix timestamp)
    finish_time: int    # Finish time of the task (Unix timestamp)
    task_type: str      # Type of the task (e.g., "upload", "download")
```

## Result Types

```python
class ContextInfoResult(ApiResponse):
    request_id: str  # The request ID
    context_status_data: List[ContextStatusData]  # Array of context status data objects
```

```python
class ContextSyncResult(ApiResponse):
    request_id: str  # The request ID
    success: bool    # Indicates whether the synchronization was successful
```

## Methods

### info

Gets information about context synchronization status.

```python
info(context_id: Optional[str] = None, path: Optional[str] = None, task_type: Optional[str] = None) -> ContextInfoResult
```

**Parameters:**
- `context_id` (str, optional): The ID of the context to get information for.
- `path` (str, optional): The path where the context is mounted.
- `task_type` (str, optional): The type of task to get information for (e.g., "upload", "download").

**Returns:**
- `ContextInfoResult`: A result object containing the context status data and request ID.
  - `context_status_data` (List[ContextStatusData]): A list of context status data objects.

**Example:**
```python
from agentbay import AgentBay

# Initialize the SDK
agent_bay = AgentBay(api_key="your_api_key")

# Create a session
result = agent_bay.create()
if result.success:
    session = result.session
    
    try:
        # Get context synchronization information
        info_result = session.context.info()
        print(f"Request ID: {info_result.request_id}")
        print(f"Context status data count: {len(info_result.context_status_data)}")
        
        if info_result.context_status_data:
            for item in info_result.context_status_data:
                print(f"  Context {item.context_id}: Status={item.status}, "
                      f"Path={item.path}, TaskType={item.task_type}")
        else:
            print("No context synchronization tasks found")
    finally:
        session.delete()

# Expected output:
# Request ID: 41FC3D61-4AFB-1D2E-A08E-5737B2313234
# Context status data count: 0
# No context synchronization tasks found
```

### sync

Synchronizes a context with the session. This method is asynchronous and supports two modes:
- **Async mode (default)**: When called with `await`, it waits for the sync operation to complete.
- **Callback mode**: When a callback is provided, it returns immediately and calls the callback when complete.

```python
async sync(
    context_id: Optional[str] = None, 
    path: Optional[str] = None, 
    mode: Optional[str] = None,
    callback: Optional[Callable[[bool], None]] = None,
    max_retries: int = 150,
    retry_interval: int = 1500
) -> ContextSyncResult
```

**Parameters:**
- `context_id` (str, optional): The ID of the context to synchronize.
- `path` (str, optional): The path where the context should be mounted.
- `mode` (str, optional): The synchronization mode (e.g., "upload", "download").
- `callback` (Callable[[bool], None], optional): Optional callback function that receives success status. If provided, the method runs in background and calls callback when complete.
- `max_retries` (int): Maximum number of retries for polling completion status. Default: 150.
- `retry_interval` (int): Milliseconds to wait between retries. Default: 1500.

**Returns:**
- `ContextSyncResult`: A result object containing success status and request ID.
  - `success` (bool): Indicates whether the synchronization was successful.

**Example (Async mode - waits for completion):**
```python
import asyncio
from agentbay import AgentBay

async def sync_context_example():
    # Initialize the SDK
    agent_bay = AgentBay(api_key="your_api_key")

    # Create a session
    result = agent_bay.create()
    if result.success:
        session = result.session
        
        try:
            # Get or create a context
            context_result = agent_bay.context.get('my-context', True)
            if context_result.context:
                # Trigger context synchronization and wait for completion
                sync_result = await session.context.sync(
                    context_id=context_result.context_id,
                    path="/mnt/persistent",
                    mode="upload"
                )
                
                print(f"Sync completed - Success: {sync_result.success}")
                print(f"Request ID: {sync_result.request_id}")
        finally:
            session.delete()

asyncio.run(sync_context_example())

# Expected output:
# Sync completed - Success: True
# Request ID: 39B00280-B9DA-17D1-BCBB-9C577E057F0A
```

**Example (Callback mode - returns immediately):**
```python
import asyncio
from agentbay import AgentBay

async def sync_with_callback_example():
    agent_bay = AgentBay(api_key="your_api_key")
    result = agent_bay.create()
    
    if result.success:
        session = result.session
        
        try:
            context_result = agent_bay.context.get('my-context', True)
            
            # Define a callback function
            def on_sync_complete(success: bool):
                if success:
                    print("Context sync completed successfully")
                else:
                    print("Context sync failed or timed out")
            
            # Trigger sync with callback - returns immediately
            sync_result = await session.context.sync(
                context_id=context_result.context_id,
                path="/mnt/persistent",
                mode="upload",
                callback=on_sync_complete,  # Callback mode
                max_retries=10,
                retry_interval=1000
            )
            
            print(f"Sync triggered - Success: {sync_result.success}")
            print(f"Request ID: {sync_result.request_id}")
            
            # Wait a bit for callback to be called
            await asyncio.sleep(3)
        finally:
            session.delete()

asyncio.run(sync_with_callback_example())

# Expected output:
# Sync triggered - Success: True
# Request ID: 39B00280-B9DA-17D1-BCBB-9C577E057F0A
# Context sync completed successfully  (printed by callback after completion)
```

## Complete Usage Example

```python
import asyncio
from agentbay import AgentBay

async def complete_context_manager_example():
    # Initialize the SDK
    agent_bay = AgentBay(api_key="your_api_key")

    # Create a session
    result = agent_bay.create()
    if not result.success:
        print(f"Failed to create session: {result.error_message}")
        return

    session = result.session
    print(f"Session created: {session.get_session_id()}")

    try:
        # Get or create a context
        context_result = agent_bay.context.get('my-persistent-context', True)
        if not context_result.context:
            print("Failed to get context")
            return

        print(f"Context ID: {context_result.context_id}")

        # Check initial context status
        info_result = session.context.info()
        print(f"\nInitial context status data count: {len(info_result.context_status_data)}")

        # Synchronize context and wait for completion
        sync_result = await session.context.sync(
            context_id=context_result.context_id,
            path="/mnt/persistent",
            mode="upload"
        )

        print(f"\nSync completed - Success: {sync_result.success}")
        print(f"Request ID: {sync_result.request_id}")

        # Check final context status
        final_info = session.context.info(
            context_id=context_result.context_id,
            path="/mnt/persistent"
        )

        print(f"\nFinal context status data count: {len(final_info.context_status_data)}")
        for item in final_info.context_status_data:
            print(f"  Context {item.context_id}: Status={item.status}, TaskType={item.task_type}")

    finally:
        # Cleanup
        session.delete()
        print("\nSession deleted")

asyncio.run(complete_context_manager_example())

# Expected output:
# Session created: session-04bdwfj7u1sew7t4f
# Context ID: SdkCtx-04bdw8o39bq47rv1t
#
# Initial context status data count: 0
#
# Sync completed - Success: True
# Request ID: 39B00280-B9DA-17D1-BCBB-9C577E057F0A
#
# Final context status data count: 0
#
# Session deleted
```

## Notes

- The `ContextManager` is designed to work with contexts synchronized to a session. It is different from the `ContextService` (accessible via `agent_bay.context`) which manages contexts globally.
- `info()` returns information about the current synchronization tasks for contexts in the session.
- `sync()` is an async method. When called without a callback, it waits for synchronization to complete. When called with a callback, it returns immediately and calls the callback when complete.
- Synchronization polling checks the status every `retry_interval` milliseconds for up to `max_retries` attempts.
- Empty `context_status_data` arrays are normal when there are no active sync tasks.
- The `sync()` method must be called with `await` in async context, or the callback parameter can be used for background execution.




# Context API Reference

The Context API provides functionality for managing persistent storage contexts in the AgentBay cloud environment. Contexts allow you to persist data across sessions and reuse it in future sessions.

## Context Class

The `Context` class represents a persistent storage context in the AgentBay cloud environment.

### Properties

```python
id  # The unique identifier of the context
name  # The name of the context
created_at  # Date and time when the Context was created
last_used_at  # Date and time when the Context was last used
```

## ContextService Class

The `ContextService` class provides methods for managing persistent contexts in the AgentBay cloud environment.

### list

Lists all available contexts with pagination support.

```python
list(params: Optional[ContextListParams] = None) -> ContextListResult
```

**Parameters:**
- `params` (ContextListParams, optional): Pagination parameters. If None, default values are used (max_results=10).

**Returns:**
- `ContextListResult`: A result object containing the list of Context objects, pagination info, and request ID.

**Example:**
```python
from agentbay import AgentBay

# Initialize the SDK
agent_bay = AgentBay(api_key="your_api_key")

# List all contexts (using default pagination)
result = agent_bay.context.list()
if result.success:
    print(f"Found {len(result.contexts)} contexts:")
    # Expected: Found X contexts (where X is the number of contexts, max 10 by default)
    print(f"Request ID: {result.request_id}")
    # Expected: A valid UUID-format request ID
    for i, context in enumerate(result.contexts):
        if i < 3:  # Show first 3 contexts
            print(f"Context ID: {context.id}, Name: {context.name}")
            # Expected output: Context ID: SdkCtx-xxx, Name: xxx
else:
    print("Failed to list contexts")
```

### get

Gets a context by name. Optionally creates it if it doesn't exist.

```python
get(name: str, create: bool = False) -> ContextResult
```

**Parameters:**
- `name` (str): The name of the context to get.
- `create` (bool, optional): Whether to create the context if it doesn't exist. Defaults to False.

**Returns:**
- `ContextResult`: A result object containing the Context object and request ID.

**Example:**
```python
from agentbay import AgentBay

# Initialize the SDK
agent_bay = AgentBay(api_key="your_api_key")

# Get a context, creating it if it doesn't exist
result = agent_bay.context.get("my-persistent-context", create=True)
if result.success:
    context = result.context
    print(f"Context ID: {context.id}, Name: {context.name}")
    # Expected output: Context ID: SdkCtx-xxx, Name: my-persistent-context
    print(f"Request ID: {result.request_id}")
    # Expected: A valid UUID-format request ID
else:
    print(f"Failed to get context: {result.error_message}")
```

### create

Creates a new context.

```python
create(name: str) -> ContextResult
```

**Parameters:**
- `name` (str): The name of the context to create.

**Returns:**
- `ContextResult`: A result object containing the created Context object and request ID.

**Example:**
```python
from agentbay import AgentBay

# Initialize the SDK
agent_bay = AgentBay(api_key="your_api_key")

# Create a new context
result = agent_bay.context.create("my-new-context")
if result.success:
    context = result.context
    print(f"Created context with ID: {context.id}, Name: {context.name}")
    # Expected output: Created context with ID: SdkCtx-xxx, Name: my-new-context
    print(f"Request ID: {result.request_id}")
    # Expected: A valid UUID-format request ID
else:
    print(f"Failed to create context: {result.error_message}")
```

### delete

Deletes a context.

```python
delete(context: Context) -> OperationResult
```

**Parameters:**
- `context` (Context): The Context object to delete.

**Returns:**
- `OperationResult`: A result object containing success status and request ID.

**Example:**
```python
from agentbay import AgentBay

# Initialize the SDK
agent_bay = AgentBay(api_key="your_api_key")

# Get a context first
result = agent_bay.context.get("my-context")
if result.success and result.context:
    # Delete the context
    delete_result = agent_bay.context.delete(result.context)
    if delete_result.success:
        print(f"Context deleted successfully, Success: {delete_result.success}")
        # Expected output: Context deleted successfully, Success: True
        print(f"Request ID: {delete_result.request_id}")
        # Expected: A valid UUID-format request ID
    else:
        print(f"Failed to delete context: {delete_result.error_message}")
else:
    print(f"Failed to get context: {result.error_message}")
```

### update

Updates a context's properties.

```python
update(context: Context) -> OperationResult
```

**Parameters:**
- `context` (Context): The Context object with updated properties.

**Returns:**
- `OperationResult`: A result object containing success status and request ID.

**Example:**
```python
from agentbay import AgentBay

# Initialize the SDK
agent_bay = AgentBay(api_key="your_api_key")

# Get a context first
result = agent_bay.context.get("my-context")
if result.success and result.context:
    # Update the context name
    context = result.context
    context.name = "my-renamed-context"

    # Save the changes
    update_result = agent_bay.context.update(context)
    if update_result.success:
        print(f"Context updated successfully, Success: {update_result.success}")
        # Expected output: Context updated successfully, Success: True
        print(f"Request ID: {update_result.request_id}")
        # Expected: A valid UUID-format request ID
    else:
        print(f"Failed to update context: {update_result.error_message}")
else:
    print(f"Failed to get context: {result.error_message}")
```

### get_file_download_url

Gets a presigned download URL for a file in a context.

```python
get_file_download_url(context_id: str, file_path: str) -> FileUrlResult
```

**Parameters:**
- `context_id` (str): The ID of the context.
- `file_path` (str): The path to the file in the context.

**Returns:**
- `FileUrlResult`: A result object containing the presigned URL, expire time, and request ID.

### get_file_upload_url

Gets a presigned upload URL for a file in a context.

```python
get_file_upload_url(context_id: str, file_path: str) -> FileUrlResult
```

**Parameters:**
- `context_id` (str): The ID of the context.
- `file_path` (str): The path to the file in the context.

**Returns:**
- `FileUrlResult`: A result object containing the presigned URL, expire time, and request ID.

### list_files

Lists files under a specific folder path in a context.

```python
list_files(context_id: str, parent_folder_path: str, page_number: int, page_size: int) -> FileListResult
```

**Parameters:**
- `context_id` (str): The ID of the context.
- `parent_folder_path` (str): The parent folder path to list files from.
- `page_number` (int): The page number for pagination.
- `page_size` (int): The number of items per page.

**Returns:**
- `FileListResult`: A result object containing the list of files and request ID.

### delete_file

Deletes a file in a context.

```python
delete_file(context_id: str, file_path: str) -> OperationResult
```

**Parameters:**
- `context_id` (str): The ID of the context.
- `file_path` (str): The path to the file to delete.

**Returns:**
- `OperationResult`: A result object containing success status and request ID.

### clear

Clears the context's persistent data.

```python
clear(context_id: str, timeout: int = 60, poll_interval: float = 2.0) -> ClearContextResult
```

**Parameters:**
- `context_id` (str): The unique identifier of the context to clear.
- `timeout` (int, optional): Timeout in seconds to wait for task completion. Default is 60 seconds.
- `poll_interval` (float, optional): Interval in seconds between status polls. Default is 2.0 seconds.

**Returns:**
- `ClearContextResult`: A result object containing the final task result. The status field will be "available" on success.

**State Transitions:**
- "clearing": Data clearing is in progress
- "available": Clearing completed successfully (final success state)
- "in-use": Context is being used
- "pre-available": Context is being prepared

**Example:**
```python
from agentbay import AgentBay

# Initialize the SDK
agent_bay = AgentBay(api_key="your_api_key")

# Get a context first
result = agent_bay.context.get("my-context")
if result.success and result.context:
    context = result.context

    # Clear context data synchronously (wait for completion)
    clear_result = agent_bay.context.clear(context.id)
    if clear_result.success:
        print(f"Context data cleared successfully")
        print(f"Final Status: {clear_result.status}")
        # Expected output: Final Status: available
        print(f"Request ID: {clear_result.request_id}")
        # Expected: A valid UUID-format request ID
    else:
        print(f"Failed to clear context: {clear_result.error_message}")
else:
    print(f"Failed to get context: {result.error_message}")
```

### clear_async

Asynchronously initiates a task to clear the context's persistent data.

```python
clear_async(context_id: str) -> ClearContextResult
```

**Parameters:**
- `context_id` (str): The unique identifier of the context to clear.

**Returns:**
- `ClearContextResult`: A result object indicating the task has been successfully started, with status field set to "clearing".

**Example:**
```python
from agentbay import AgentBay

# Initialize the SDK
agent_bay = AgentBay(api_key="your_api_key")

# Get a context first
result = agent_bay.context.get("my-context")
if result.success and result.context:
    context = result.context

    # Start clearing context data asynchronously (non-blocking)
    clear_result = agent_bay.context.clear_async(context.id)
    if clear_result.success:
        print(f"Clear task started: Success={clear_result.success}, Status={clear_result.status}")
        # Expected output: Clear task started: Success=True, Status=clearing
        print(f"Request ID: {clear_result.request_id}")
        # Expected: A valid UUID-format request ID
    else:
        print(f"Failed to start clear: {clear_result.error_message}")
else:
    print(f"Failed to get context: {result.error_message}")
```

### get_clear_status

Queries the status of the clearing task.

```python
get_clear_status(context_id: str) -> ClearContextResult
```

**Parameters:**
- `context_id` (str): The unique identifier of the context to check.

**Returns:**
- `ClearContextResult`: A result object containing the current task status.

**State Transitions:**
- "clearing": Data clearing is in progress
- "available": Clearing completed successfully (final success state)
- "in-use": Context is being used
- "pre-available": Context is being prepared

**Example:**
```python
from agentbay import AgentBay

# Initialize the SDK
agent_bay = AgentBay(api_key="your_api_key")

# Get a context first
result = agent_bay.context.get("my-context")
if result.success and result.context:
    context = result.context

    # Check clearing status
    status_result = agent_bay.context.get_clear_status(context.id)
    if status_result.success:
        print(f"Current status: {status_result.status}")
        print(f"Request ID: {status_result.request_id}")
        # Expected: Current status: clearing/available/in-use/pre-available
    else:
        print(f"Failed to get status: {status_result.error_message}")
else:
    print(f"Failed to get context: {result.error_message}")
```

## Related Resources

- [Session API Reference](session.md)
- [ContextManager API Reference](context-manager.md)



# FileSystem Class API Reference

The `FileSystem` class provides methods for file operations within a session in the AgentBay cloud environment. This includes reading, writing, editing, and searching files, as well as directory operations, real-time directory monitoring, and file transfer capabilities.

## 📖 Related Tutorial

- [Complete Guide to File Operations](../../../../../docs/guides/common-features/basics/file-operations.md) - Detailed tutorial covering all file operation features

## Methods

### create_directory / createDirectory / CreateDirectory

Creates a new directory at the specified path.


```python
create_directory(path: str) -> BoolResult
```

**Parameters:**
- `path` (str): The path of the directory to create.

**Returns:**
- `BoolResult`: A result object containing success status, boolean data (True if successful), request ID, and error message if any.

**Note:**
The return type has been updated from boolean to a structured `BoolResult` object, which provides more detailed information about the operation result.

### edit_file

Edits a file by replacing occurrences of oldText with newText.


```python
edit_file(path: str, edits: List[Dict[str, str]], dry_run: bool = False) -> BoolResult
```

**Parameters:**
- `path` (str): The path of the file to edit.
- `edits` (List[Dict[str, str]]): List of edit operations, each containing oldText and newText.
- `dry_run` (bool, optional): If true, preview changes without applying them. Default is False.

**Returns:**
- `BoolResult`: A result object containing success status, boolean data (True if successful), request ID, and error message if any.

### get_file_info

Gets information about a file or directory.

```python
get_file_info(path: str) -> FileInfoResult
```

**Parameters:**
- `path` (str): The path of the file or directory to inspect.

**Returns:**
- `FileInfoResult`: A result object containing file information, success status, request ID, and error message if any.

### list_directory

Lists the contents of a directory.

```python
list_directory(path: str) -> DirectoryListResult
```

**Parameters:**
- `path` (str): The path of the directory to list.

**Returns:**
- `DirectoryListResult`: A result object containing a list of directory entries, success status, request ID, and error message if any.

### move_file

Moves a file or directory from source to destination.


```python
move_file(source: str, destination: str) -> BoolResult
```

**Parameters:**
- `source` (str): The path of the source file or directory.
- `destination` (str): The path of the destination file or directory.

**Returns:**
- `BoolResult`: A result object containing success status, boolean data (True if successful), request ID, and error message if any.

### read_file

Reads the contents of a file. Automatically handles large files by chunking.


```python
read_file(path: str) -> FileContentResult
```

**Parameters:**
- `path` (str): The path of the file to read.

**Returns:**
- `FileContentResult`: A result object containing file content, success status, request ID, and error message if any.

**Note:**
This method automatically handles both small and large files. For large files, it uses internal chunking with a default chunk size of 50KB to overcome API size limitations. No manual chunk size configuration is needed.

### read_multiple_files

```python
read_multiple_files(paths: List[str]) -> MultipleFileContentResult
```

**Parameters:**
- `paths` (List[str]): List of file paths to read.

**Returns:**
- `MultipleFileContentResult`: A result object containing a dictionary mapping file paths to their contents, success status, request ID, and error message if any.

### search_files

Searches for files matching a pattern in a directory.


```python
search_files(path: str, pattern: str, exclude_patterns: Optional[List[str]] = None) -> FileSearchResult
```

**Parameters:**
- `path` (str): The path of the directory to start the search.
- `pattern` (str): The pattern to match.
- `exclude_patterns` (List[str], optional): Patterns to exclude. Default is None.

**Returns:**
- `FileSearchResult`: A result object containing search results (in the `matches` attribute), success status, request ID, and error message if any.

### write_file

Writes content to a file. Automatically handles large files by chunking.


```python
write_file(path: str, content: str, mode: str = "overwrite") -> BoolResult
```

**Parameters:**
- `path` (str): The path of the file to write.
- `content` (str): Content to write to the file.
- `mode` (str, optional): "overwrite" (default) or "append".

**Returns:**
- `BoolResult`: A result object containing success status, boolean data (True if successful), request ID, and error message if any.

**Note:**
This method automatically handles both small and large content. For large content, it uses internal chunking with a default chunk size of 50KB to overcome API size limitations. No manual chunk size configuration is needed.

### upload_file

Uploads a file from local storage to the cloud environment.

```python
upload_file(
    local_path: str,
    remote_path: str,
    *,
    content_type: Optional[str] = None,
    wait: bool = True,
    wait_timeout: float = 30.0,
    poll_interval: float = 1.5,
    progress_cb: Optional[Callable[[int], None]] = None
) -> UploadResult
```

**Parameters:**
- `local_path` (str): Path to the local file to upload
- `remote_path` (str): Path where the file should be stored in the cloud
- `content_type` (str, optional): Content-Type header for the upload
- `wait` (bool, optional): Whether to wait for synchronization to complete (default: True)
- `wait_timeout` (float, optional): Maximum time to wait for synchronization (default: 30.0 seconds)
- `poll_interval` (float, optional): Interval between synchronization status checks (default: 1.5 seconds)
- `progress_cb` (Callable, optional): Callback function to track upload progress

**Returns:**
- `UploadResult`: Result object containing upload status and metadata

**Example:**
```python
# Upload a file
upload_result = session.file_system.upload_file(
    local_path="/path/to/local/file.txt",
    remote_path="/remote/path/file.txt"
)

if upload_result.success:
    print(f"Uploaded {upload_result.bytes_sent} bytes")
else:
    print(f"Upload failed: {upload_result.error}")
```

### download_file

Downloads a file from the cloud environment to local storage.

```python
download_file(
    remote_path: str,
    local_path: str,
    *,
    overwrite: bool = True,
    wait: bool = True,
    wait_timeout: float = 300.0,
    poll_interval: float = 1.5,
    progress_cb: Optional[Callable[[int], None]] = None
) -> DownloadResult
```

**Parameters:**
- `remote_path` (str): Path to the file in the cloud environment
- `local_path` (str): Path where the file should be saved locally
- `overwrite` (bool, optional): Whether to overwrite existing local files (default: True)
- `wait` (bool, optional): Whether to wait for synchronization to complete (default: True)
- `wait_timeout` (float, optional): Maximum time to wait for synchronization (default: 300.0 seconds)
- `poll_interval` (float, optional): Interval between synchronization status checks (default: 1.5 seconds)
- `progress_cb` (Callable, optional): Callback function to track download progress

**Returns:**
- `DownloadResult`: Result object containing download status and metadata

**Example:**
```python
# Download a file
download_result = session.file_system.download_file(
    remote_path="/remote/path/file.txt",
    local_path="/path/to/local/file.txt"
)

if download_result.success:
    print(f"Downloaded {download_result.bytes_received} bytes")
else:
    print(f"Download failed: {download_result.error}")
```

## Directory Monitoring

### watch_directory

Watches a directory for file changes and calls a callback function when changes occur.

```python
watch_directory(
    path: str,
    callback: Callable[[List[FileChangeEvent]], None],
    interval: float = 0.5,
    stop_event: Optional[threading.Event] = None
) -> threading.Thread
```

**Parameters:**
- `path` (str): The directory path to monitor for file changes.
- `callback` (Callable): Callback function that will be called with a list of FileChangeEvent objects when changes are detected.
- `interval` (float, optional): Polling interval in seconds. Default is 0.5.
- `stop_event` (threading.Event, optional): Optional threading.Event to stop the monitoring. If not provided, a new Event will be created and attached to the returned thread.

**Returns:**
- `threading.Thread`: The monitoring thread. Call `thread.start()` to begin monitoring. Use `thread.stop_event.set()` to stop monitoring.

**Example:**
```python
import threading
import time

def on_file_change(events):
    for event in events:
        print(f"{event.event_type}: {event.path} ({event.path_type})")

# Start monitoring
monitor_thread = session.file_system.watch_directory(
    path="/tmp/my_directory",
    callback=on_file_change,
    interval=0.5  # Check every 0.5 seconds
)
monitor_thread.start()

# Do some work...
time.sleep(10)

# Stop monitoring
monitor_thread.stop_event.set()
monitor_thread.join()
```

### FileChangeEvent

Represents a single file change event.

**Attributes:**
- `event_type` (str): Type of the file change event ("create", "modify", "delete").
- `path` (str): Path of the file or directory that changed.
- `path_type` (str): Type of the path ("file" or "directory").

**Methods:**
- `to_dict()`: Convert to dictionary representation.
- `from_dict(data)`: Create FileChangeEvent from dictionary (class method).

### FileChangeResult

Result of file change detection operations.

**Attributes:**
- `success` (bool): Whether the operation was successful.
- `events` (List[FileChangeEvent]): List of file change events.
- `raw_data` (str): Raw response data for debugging.
- `error_message` (str): Error message if the operation failed.

**Methods:**
- `has_changes()`: Check if there are any file changes.
- `get_modified_files()`: Get list of modified file paths.
- `get_created_files()`: Get list of created file paths.
- `get_deleted_files()`: Get list of deleted file paths.

## File Transfer Result Classes

### UploadResult

Result structure for file upload operations.

**Properties:**
```python
success: bool                    # Whether the upload was successful
request_id_upload_url: str       # Request ID for the upload URL
request_id_sync: str             # Request ID for the synchronization
http_status: int                 # HTTP status code from the upload
etag: str                        # ETag of the uploaded file
bytes_sent: int                  # Number of bytes sent
path: str                        # Remote path of the file
error: str                       # Error message if upload failed
```

### DownloadResult

Result structure for file download operations.

**Properties:**
```python
success: bool                    # Whether the download was successful
request_id_download_url: str     # Request ID for the download URL
request_id_sync: str             # Request ID for the synchronization
http_status: int                 # HTTP status code from the download
bytes_received: int              # Number of bytes received
path: str                        # Remote path of the file
local_path: str                  # Local path where file was saved
error: str                       # Error message if download failed
```



# Python Logging Configuration

## Overview

The Python SDK uses `loguru` for comprehensive logging with support for console output, file logging, and automatic sensitive data masking.

## Setting Log Level

### Priority System (Highest to Lowest)

1. **setup() method** - Most reliable way to set log level
2. **Environment variables** - `AGENTBAY_LOG_LEVEL`
3. **.env file** - Automatically loaded from current directory or parent directories
4. **Default values** - INFO level

### Method 1: Using setup() (Recommended)

Use the `setup()` method to configure logging:

```python
from agentbay.logger import AgentBayLogger, get_logger

# Configure logging level
AgentBayLogger.setup(level="DEBUG")

logger = get_logger("my_app")
logger.debug("Now in debug mode")  # This will appear
```

### Method 2: Environment Variable

**Option A: Using .env File (Recommended)**

Create a `.env` file in your project root:

```
# .env file
AGENTBAY_LOG_LEVEL=DEBUG
```

The SDK automatically searches for and loads `.env` files from:
- Current working directory
- Parent directories (recursive search up to root)
- Git repository root (if found)

**Option B: Command Line Environment Variable**

Set before running your script:

```bash
export AGENTBAY_LOG_LEVEL=DEBUG
python your_script.py
```

### Method 3: Change Level During Runtime

Use `set_level()` to change level while program is running:

```python
from agentbay.logger import AgentBayLogger

# Change level at runtime
AgentBayLogger.set_level("WARNING")
```

**Note**: `set_level()` automatically reinitializes the logger with the new level.

## Log Levels

| Level | Use Case |
|-------|----------|
| **DEBUG** | Development - see everything |
| **INFO** | Default - important events |
| **WARNING** | Issues but not failures |
| **ERROR** | Only failures |

Filter rule: **Only logs at your level or HIGHER severity are shown**.

## File Logging

Python SDK logs to a file by default.

### Default Log File

```
python/agentbay.log
```

### Custom Log File Location

```python
from agentbay.logger import AgentBayLogger, get_logger

# Configure custom log file location
AgentBayLogger.setup(
    level="DEBUG",
    log_file="/custom/path/app.log"
)

logger = get_logger("app")
```

### File Rotation and Retention

Configure automatic log file rotation:

```python
from agentbay.logger import AgentBayLogger

AgentBayLogger.setup(
    level="DEBUG",
    log_file="/var/log/myapp.log",
    rotation="100 MB",     # Rotate when file reaches 100 MB
    retention="30 days"    # Keep logs for 30 days
)
```

## Sensitive Data Masking

The SDK automatically masks sensitive information:

```python
from agentbay.logger import mask_sensitive_data

data = {
    "api_key": "sk_live_1234567890",
    "password": "secret123",
    "auth_token": "Bearer xyz"
}

masked = mask_sensitive_data(data)
# Result: api_key masked, password masked, auth_token masked
```

Automatically masked fields:
- api_key, apikey, api-key
- password, passwd, pwd
- token, access_token, auth_token
- secret, private_key
- authorization

Custom fields can also be masked by passing them as parameters.

## Quick Reference

**Development (see everything)**:
```bash
export AGENTBAY_LOG_LEVEL=DEBUG
python main.py
```

**Testing (important events only)**:
```bash
python test_suite.py
# Uses default INFO level
```

**Production (problems only)**:
```bash
export AGENTBAY_LOG_LEVEL=WARNING
python app.py
```

**Debugging with file output**:
```python
from agentbay.logger import AgentBayLogger, get_logger

AgentBayLogger.setup(
    level="DEBUG",
    log_file="/var/log/debug.log",
    enable_console=False
)
logger = get_logger("app")
```




# Session Class

The `Session` class represents a session in the AgentBay cloud environment. It provides methods for managing file systems, executing commands, and more.

## 📖 Related Tutorial

- [Session Management Guide](../../../../../docs/guides/common-features/basics/session-management.md) - Detailed tutorial on session lifecycle and management

## Properties

```python
agent_bay  # The AgentBay instance that created this session
session_id  # The ID of this session
file_system  # The FileSystem instance for this session
command  # The Command instance for this session
code  # The Code instance for this session
oss  # The Oss instance for this session
application  # The ApplicationManager instance for this session
window  # The WindowManager instance for this session
computer  # The Computer instance for this session
mobile  # The Mobile instance for this session
ui  # The UI instance for this session
context  # The ContextManager instance for this session
browser  # The Browser instance for this session
agent  # The Agent instance for this session
is_vpc  # Whether this session uses VPC resources
network_interface_ip  # Network interface IP for VPC sessions
http_port  # HTTP port for VPC sessions
token  # Token for VPC sessions
resource_url  # Resource URL for accessing the session
mcp_tools  # MCP tools available for this session
image_id  # The image ID used for this session
```

## Methods

### delete

Deletes this session.

```python
delete(sync_context: bool = False) -> DeleteResult
```

**Parameters:**
- `sync_context` (bool, optional): If True, the API will trigger a file upload via `self.context.sync` before actually releasing the session. Default is False.

**Returns:**
- `DeleteResult`: A result object containing success status, request ID, and error message if any.

**Behavior:**
- When `sync_context` is True, the API will first call `context.sync` to trigger file upload.
- It will then retrieve ContextStatusData via `context.info` and monitor only upload task items' Status.
- The API waits until all upload tasks show either "Success" or "Failed" status, or until the maximum retry limit (150 times with 2-second intervals) is reached.
- Any "Failed" status upload tasks will have their error messages printed.
- The session deletion only proceeds after context sync status checking for upload tasks completes.

**Example:**
```python
from agentbay import AgentBay

# Initialize the SDK
agent_bay = AgentBay(api_key="your_api_key")

# Create a session
result = agent_bay.create()
if result.success:
    session = result.session
    print(f"Session created with ID: {session.session_id}")
    # Output: Session created with ID: session-04bdwfj7u22a1s30g

    # Use the session...

    # Delete the session with context synchronization
    delete_result = session.delete(sync_context=True)
    if delete_result.success:
        print(f"Session deleted successfully with synchronized context")
        # Output: Session deleted successfully with synchronized context
        print(f"Request ID: {delete_result.request_id}")
        # Output: Request ID: D9E69976-9DE0-107D-8047-EE4B4D63AA5D
    else:
        print(f"Failed to delete session: {delete_result.error_message}")
```

### set_labels

Sets labels for this session.

```python
set_labels(labels: Dict[str, str]) -> OperationResult
```

**Parameters:**
- `labels` (Dict[str, str]): Key-value pairs representing the labels to set.

**Returns:**
- `OperationResult`: A result object containing success status, request ID, and error message if any.

**Raises:**
- `AgentBayError`: If setting labels fails due to API errors or other issues.

**Example:**
```python
# Set session labels
labels = {
    "project": "demo",
    "environment": "testing",
    "version": "1.0.0"
}
result = session.set_labels(labels)
if result.success:
    print("Labels set successfully")
    # Output: Labels set successfully
    print(f"Request ID: {result.request_id}")
    # Output: Request ID: B1F98082-52F0-17F7-A149-7722D6205AD6
else:
    print(f"Failed to set labels: {result.error_message}")
```

### get_labels

Gets the labels for this session.

```python
get_labels() -> OperationResult
```

**Returns:**
- `OperationResult`: A result object containing success status, request ID, and error message if any, and the labels data.

**Raises:**
- `AgentBayError`: If getting labels fails due to API errors or other issues.

**Example:**
```python
# Get session labels
try:
    result = session.get_labels()
    if result.success:
        print(f"Session labels: {result.data}")
        # Output: Session labels: {'environment': 'testing', 'project': 'demo', 'version': '1.0.0'}
    else:
        print(f"Failed to get labels: {result.error_message}")
except AgentBayError as e:
    print(f"Failed to get labels: {e}")
```

### info

Gets information about this session.

```python
info() -> OperationResult
```

**Returns:**
- `OperationResult`: A result object containing success status, request ID, and the session information as data.

**Raises:**
- `AgentBayError`: If getting session information fails due to API errors or other issues.

**Example:**
```python
# Get session information
try:
    result = session.info()
    if result.success:
        info = result.data
        print(f"Session ID: {info.session_id}")
        # Output: Session ID: session-04bdwfj7u22a1s30k
        print(f"Resource URL: {info.resource_url[:80]}...")
        # Output: Resource URL: https://pre-myspace-wuying.aliyun.com/app/InnoArchClub/mcp_container/mcp.html?au...
        print(f"App ID: {info.app_id}")
        # Output: App ID: mcp-server-ubuntu
    else:
        print(f"Failed to get session info: {result.error_message}")
except AgentBayError as e:
    print(f"Failed to get session info: {e}")
```

### get_link

Gets a link for this session.

```python
get_link(protocol_type: Optional[str] = None, port: Optional[int] = None, options: Optional[str] = None) -> OperationResult
```

**Parameters:**
- `protocol_type` (str, optional): The protocol type for the link.
- `port` (int, optional): The port for the link. Must be an integer in the range [30100, 30199]. If not specified, the default port will be used.
- `options` (str, optional): Additional options as a JSON string (e.g., for adb configuration). Defaults to None.

**Returns:**
- `OperationResult`: A result object containing success status, request ID, and the link URL as data.

**Raises:**
- `SessionError`: If the port value is invalid (not an integer or outside the valid range [30100, 30199]).
- `AgentBayError`: If getting the link fails due to API errors or other issues.

**Example:**
```python
# Get link with specific protocol and valid port
# Note: For ComputerUse images, port must be explicitly specified
try:
    result = session.get_link("https", 30150)
    if result.success:
        link = result.data
        print(f"Session link: {link[:80]}...")
        # Output: Session link: https://gw-cn-hangzhou-i-ai-test0-linux.wuyinggw.com:8008/request_ai/00Lw4a5HtJ9...
        print(f"Request ID: {result.request_id}")
        # Output: Request ID: 5CA891B8-1E45-13B0-9975-0258228008CB
    else:
        print(f"Failed to get link: {result.error_message}")

    # Example with invalid port (will raise SessionError)
    try:
        invalid_result = session.get_link(port=8080)  # Invalid: outside [30100, 30199]
    except SessionError as e:
        print(f"Port validation error: {e}")
        # Output: Port validation error: Invalid port value: 8080. Port must be an integer in the range [30100, 30199].

except AgentBayError as e:
    print(f"Failed to get link: {e}")
```

### get_link_async

Asynchronously gets a link for this session.

```python
async get_link_async(protocol_type: Optional[str] = None, port: Optional[int] = None, options: Optional[str] = None) -> OperationResult
```

**Parameters:**
- `protocol_type` (str, optional): The protocol type for the link.
- `port` (int, optional): The port for the link. Must be an integer in the range [30100, 30199]. If not specified, the default port will be used.
- `options` (str, optional): Additional options as a JSON string (e.g., for adb configuration). Defaults to None.

**Returns:**
- `OperationResult`: A result object containing success status, request ID, and the link URL as data.

**Raises:**
- `SessionError`: If the port value is invalid (not an integer or outside the valid range [30100, 30199]).
- `AgentBayError`: If getting the link fails due to API errors or other issues.

**Example:**
```python
import asyncio

async def get_session_link():
    try:
        # Get session link with default settings
        result = await session.get_link_async()
        if result.success:
            link = result.data
            print(f"Session link: {link}")
        else:
            print(f"Failed to get link: {result.error_message}")

        # Get link with specific protocol and valid port
        custom_result = await session.get_link_async("wss", 30199)
        if custom_result.success:
            custom_link = custom_result.data
            print(f"Custom WebSocket link: {custom_link}")
        else:
            print(f"Failed to get custom link: {custom_result.error_message}")

    except SessionError as e:
        print(f"Port validation error: {e}")
    except AgentBayError as e:
        print(f"Failed to get link: {e}")

# Run the async function
asyncio.run(get_session_link())
```

### list_mcp_tools

Lists MCP tools available for this session.

```python
list_mcp_tools(image_id: Optional[str] = None) -> McpToolsResult
```

**Parameters:**
- `image_id` (str, optional): The image ID to list tools for. Defaults to the session's image_id or "linux_latest".

**Returns:**
- `McpToolsResult`: A result object containing success status, request ID, and the list of MCP tools.

**Raises:**
- `AgentBayError`: If listing MCP tools fails due to API errors or other issues.

## Related Resources

- [FileSystem API Reference](filesystem.md)
- [Command API Reference](command.md)
- [UI API Reference](../../computer-use/ui.md)
- [Window API Reference](../../computer-use/window.md)
- [OSS API Reference](../advanced/oss.md)
- [Application API Reference](../../computer-use/application.md)
- [Context API Reference](context-manager.md)




# ApplicationManager Class

> **⚠️ DEPRECATED**: This API is deprecated. Please use the [Computer API](computer.md) instead for application management functionality.

The ApplicationManager class provides methods for managing applications in the AgentBay cloud environment, including listing installed applications, starting applications, and stopping running processes.

## Class Properties

###

```python
class ApplicationManager:
    def __init__(self, session):
        self.session = session
```

## Data Types


Represents an installed application.


```python
class InstalledApp:
    name: str          # The name of the application
    start_cmd: str     # The command used to start the application
    stop_cmd: str      # The command used to stop the application (optional)
    work_directory: str # The working directory for the application (optional)
```


```python
class Process:
    pname: str    # The name of the process
    pid: int      # The process ID
    cmdline: Optional[str]  # The command line used to start the process (optional)
```

## Result Types

```python
class ProcessListResult(ApiResponse):
    success: bool
    data: List[Process]
    error_message: str
```

```python
class InstalledAppListResult(ApiResponse):
    success: bool
    data: List[InstalledApp]
    error_message: str
```

```python
class AppInfoResult(ApiResponse):
    success: bool
    app_info: Dict[str, Any]
    error_message: str
```

```python
class AppListResult(ApiResponse):
    success: bool
    apps: List[Dict[str, Any]]
    error_message: str
```

```python
class AppOperationResult(ApiResponse):
    success: bool
    error_message: str
```

```python
class AppInstallResult(ApiResponse):
    success: bool
    message: str
```


```python
def get_installed_apps(self, start_menu: bool, desktop: bool, ignore_system_apps: bool) -> InstalledAppListResult:
```

**Parameters:**
- `start_menu` (bool): Whether to include start menu applications.
- `desktop` (bool): Whether to include desktop applications.
- `ignore_system_apps` (bool): Whether to ignore system applications.

**Returns:**
- `InstalledAppListResult`: The result containing the list of installed applications.

**Raises:**
- `ApplicationError`: If there's an error retrieving the installed applications.


```python
def start_app(self, start_cmd: str, work_directory: str = "", activity: str = "") -> ProcessListResult:
```

**Parameters:**
- `start_cmd` (str): The command to start the application.
- `work_directory` (str, optional): The working directory for the application.
- `activity` (str, optional): Activity name to launch (e.g. ".SettingsActivity" or "com.package/.Activity").

**Returns:**
- `ProcessListResult`: The result containing the list of processes started.

**Raises:**
- `ApplicationError`: If there's an error starting the application.


```python
def stop_app_by_pname(self, pname: str) -> AppOperationResult:
```

**Parameters:**
- `pname` (str): The name of the process to stop.

**Returns:**
- `AppOperationResult`: The result of the operation.

**Raises:**
- `ApplicationError`: If there's an error stopping the application.


```python
def stop_app_by_pid(self, pid: int) -> AppOperationResult:
```

**Parameters:**
- `pid` (int): The process ID to stop.

**Returns:**
- `AppOperationResult`: The result of the operation.

**Raises:**
- `ApplicationError`: If there's an error stopping the application.


```python
def stop_app_by_cmd(self, stop_cmd: str) -> AppOperationResult:
```

**Parameters:**
- `stop_cmd` (str): The command to stop the application.

**Returns:**
- `AppOperationResult`: The result of the operation.

**Raises:**
- `ApplicationError`: If there's an error stopping the application.


```python
def list_visible_apps(self) -> ProcessListResult:
```

**Returns:**
- `ProcessListResult`: The result containing the list of visible applications/processes.

**Raises:**
- `ApplicationError`: If there's an error listing the visible applications.




# Computer Class API Reference

The `Computer` class provides comprehensive desktop UI automation operations in the AgentBay cloud environment. It offers mouse operations, keyboard operations, window management, application management, and screen operations for Windows desktop automation.

## 📖 Related Tutorials

- [Computer UI Automation Guide](../../../../docs/guides/computer-use/computer-ui-automation.md) - Detailed tutorial on desktop UI automation
- [Window Management Guide](../../../../docs/guides/computer-use/window-management.md) - Tutorial on managing application windows

## Overview

The `Computer` class is available through `session.computer` and is designed for use with Windows desktop environments (use `image_id="windows_latest"` when creating sessions).

## Constructor

The `Computer` class is automatically instantiated when creating a session. Access it via:

```python
session.computer
```

## Enum Types

### MouseButton

Mouse button types for click and drag operations.

```python
from agentbay.computer import MouseButton

MouseButton.LEFT         # Left mouse button
MouseButton.RIGHT        # Right mouse button
MouseButton.MIDDLE       # Middle mouse button
MouseButton.DOUBLE_LEFT  # Double-click with left button
```

### ScrollDirection

Scroll direction for scroll operations.

```python
from agentbay.computer import ScrollDirection

ScrollDirection.UP     # Scroll up
ScrollDirection.DOWN   # Scroll down
ScrollDirection.LEFT   # Scroll left
ScrollDirection.RIGHT  # Scroll right
```

## Mouse Operations

### click_mouse()

Clicks the mouse at the specified coordinates.

```python
click_mouse(x: int, y: int, button: Union[MouseButton, str] = MouseButton.LEFT) -> BoolResult
```

**Parameters:**
- `x` (int): X coordinate
- `y` (int): Y coordinate
- `button` (Union[MouseButton, str], optional): Button type. Can be `MouseButton` enum or string ("left", "right", "middle", "double_left"). Defaults to `MouseButton.LEFT`.

**Returns:**
- `BoolResult`: Result object containing success status and error message if any.

**Raises:**
- `ValueError`: If button is not a valid option.

**Example:**
```python
from agentbay import AgentBay, CreateSessionParams

# Create session with Windows image
agent_bay = AgentBay(api_key="your_api_key")
params = CreateSessionParams(image_id="windows_latest")
session_result = agent_bay.create(params)
session = session_result.session

# Click at coordinates (100, 200)
result = session.computer.click_mouse(100, 200)
# Verified: ✓ success=True, default LEFT button works

# Right-click
from agentbay.computer import MouseButton
result = session.computer.click_mouse(100, 200, MouseButton.RIGHT)
# Verified: ✓ success=True, RIGHT button works

# Double-click
result = session.computer.click_mouse(100, 200, MouseButton.DOUBLE_LEFT)
# Verified: ✓ success=True, DOUBLE_LEFT button works

agent_bay.delete(session)
```

### move_mouse()

Moves the mouse to the specified coordinates.

```python
move_mouse(x: int, y: int) -> BoolResult
```

**Parameters:**
- `x` (int): X coordinate
- `y` (int): Y coordinate

**Returns:**
- `BoolResult`: Result object containing success status and error message if any.

**Example:**
```python
# Move mouse to (300, 400)
result = session.computer.move_mouse(300, 400)
# Verified: ✓ success=True
```

### drag_mouse()

Drags the mouse from one point to another.

```python
drag_mouse(from_x: int, from_y: int, to_x: int, to_y: int, button: Union[MouseButton, str] = MouseButton.LEFT) -> BoolResult
```

**Parameters:**
- `from_x` (int): Starting X coordinate
- `from_y` (int): Starting Y coordinate
- `to_x` (int): Ending X coordinate
- `to_y` (int): Ending Y coordinate
- `button` (Union[MouseButton, str], optional): Button type ("left", "right", "middle"). Defaults to `MouseButton.LEFT`. Note: DOUBLE_LEFT is not supported for drag operations.

**Returns:**
- `BoolResult`: Result object containing success status and error message if any.

**Raises:**
- `ValueError`: If button is not a valid option.

**Example:**
```python
# Drag from (100, 100) to (200, 200)
result = session.computer.drag_mouse(100, 100, 200, 200)
# Verified: ✓ success=True, default LEFT button works for drag
```

### scroll()

Scrolls the mouse wheel at the specified coordinates.

```python
scroll(x: int, y: int, direction: Union[ScrollDirection, str] = ScrollDirection.UP, amount: int = 1) -> BoolResult
```

**Parameters:**
- `x` (int): X coordinate
- `y` (int): Y coordinate
- `direction` (Union[ScrollDirection, str], optional): Scroll direction. Can be `ScrollDirection` enum or string ("up", "down", "left", "right"). Defaults to `ScrollDirection.UP`.
- `amount` (int, optional): Scroll amount. Defaults to 1.

**Returns:**
- `BoolResult`: Result object containing success status and error message if any.

**Raises:**
- `ValueError`: If direction is not a valid option.

**Example:**
```python
from agentbay.computer import ScrollDirection

# Scroll down at (500, 500)
result = session.computer.scroll(500, 500, ScrollDirection.DOWN, 3)
# Verified: ✓ success=True, DOWN direction works

# Scroll up (default direction)
result = session.computer.scroll(500, 500, amount=2)
# Verified: ✓ success=True, default UP direction works
```

### get_cursor_position()

Gets the current cursor position.

```python
get_cursor_position() -> OperationResult
```

**Returns:**
- `OperationResult`: Result object containing cursor position data with keys `x` and `y`, and error message if any.

**Example:**
```python
# Get current cursor position
result = session.computer.get_cursor_position()
# Verified: ✓ success=True, data={"x":512,"y":384}

if result.success:
    print(f"Cursor at ({result.data['x']}, {result.data['y']})")
```

## Keyboard Operations

### input_text()

Inputs text into the active field.

```python
input_text(text: str) -> BoolResult
```

**Parameters:**
- `text` (str): The text to input

**Returns:**
- `BoolResult`: Result object containing success status and error message if any.

**Example:**
```python
# Type text
result = session.computer.input_text("Hello World")
# Verified: ✓ success=True
```

### press_keys()

Presses the specified keys.

```python
press_keys(keys: List[str], hold: bool = False) -> BoolResult
```

**Parameters:**
- `keys` (List[str]): List of keys to press (e.g., ["Ctrl", "a"])
- `hold` (bool, optional): Whether to hold the keys. Defaults to False.

**Returns:**
- `BoolResult`: Result object containing success status and error message if any.

**Example:**
```python
# Press Ctrl+A to select all
result = session.computer.press_keys(["Ctrl", "a"])
# Verified: ✓ success=True

# Press and hold Shift
result = session.computer.press_keys(["Shift"], hold=True)
# Verified: ✓ success=True, hold parameter works
```

### release_keys()

Releases the specified keys.

```python
release_keys(keys: List[str]) -> BoolResult
```

**Parameters:**
- `keys` (List[str]): List of keys to release (e.g., ["Ctrl", "a"])

**Returns:**
- `BoolResult`: Result object containing success status and error message if any.

**Example:**
```python
# Release Shift key
result = session.computer.release_keys(["Shift"])
# Verified: ✓ success=True
```

## Screen Operations

### get_screen_size()

Gets the screen size and DPI scaling factor.

```python
get_screen_size() -> OperationResult
```

**Returns:**
- `OperationResult`: Result object containing screen size data with keys `width`, `height`, and `dpiScalingFactor`, and error message if any.

**Example:**
```python
# Get screen information
result = session.computer.get_screen_size()
# Verified: ✓ success=True, data={"dpiScalingFactor":1.0,"height":768,"width":1024}

if result.success:
    screen_info = result.data
    print(f"Screen: {screen_info['width']}x{screen_info['height']}")
    print(f"DPI Scaling: {screen_info['dpiScalingFactor']}")
```

### screenshot()

Takes a screenshot of the current screen.

```python
screenshot() -> OperationResult
```

**Returns:**
- `OperationResult`: Result object containing the screenshot URL and error message if any.

**Example:**
```python
# Take a screenshot
result = session.computer.screenshot()
# Verified: ✓ success=True, returns OSS URL (1039 bytes)
# Example URL: https://wuying-intelligence-service-cn-hangzhou.oss-cn-hangzhou.aliyuncs.com/...

if result.success:
    print(f"Screenshot URL: {result.data}")
```

## Window Management Operations

The `Computer` class provides window management operations by delegating to the `WindowManager` class.

### list_root_windows()

Lists all root windows.

```python
list_root_windows(timeout_ms: int = 3000) -> WindowListResult
```

**Parameters:**
- `timeout_ms` (int, optional): Timeout in milliseconds. Defaults to 3000.

**Returns:**
- `WindowListResult`: Result object containing list of windows and error message if any.

### get_active_window()

Gets the currently active window.

```python
get_active_window(timeout_ms: int = 3000) -> WindowInfoResult
```

**Parameters:**
- `timeout_ms` (int, optional): Timeout in milliseconds. Defaults to 3000.

**Returns:**
- `WindowInfoResult`: Result object containing active window info and error message if any.

### activate_window()

Activates the specified window.

```python
activate_window(window_id: int) -> BoolResult
```

**Parameters:**
- `window_id` (int): The ID of the window to activate

**Returns:**
- `BoolResult`: Result object containing success status and error message if any.

### close_window()

Closes the specified window.

```python
close_window(window_id: int) -> BoolResult
```

**Parameters:**
- `window_id` (int): The ID of the window to close

**Returns:**
- `BoolResult`: Result object containing success status and error message if any.

### maximize_window()

Maximizes the specified window.

```python
maximize_window(window_id: int) -> BoolResult
```

**Parameters:**
- `window_id` (int): The ID of the window to maximize

**Returns:**
- `BoolResult`: Result object containing success status and error message if any.

### minimize_window()

Minimizes the specified window.

```python
minimize_window(window_id: int) -> BoolResult
```

**Parameters:**
- `window_id` (int): The ID of the window to minimize

**Returns:**
- `BoolResult`: Result object containing success status and error message if any.

### restore_window()

Restores the specified window.

```python
restore_window(window_id: int) -> BoolResult
```

**Parameters:**
- `window_id` (int): The ID of the window to restore

**Returns:**
- `BoolResult`: Result object containing success status and error message if any.

### resize_window()

Resizes the specified window.

```python
resize_window(window_id: int, width: int, height: int) -> BoolResult
```

**Parameters:**
- `window_id` (int): The ID of the window to resize
- `width` (int): New width of the window
- `height` (int): New height of the window

**Returns:**
- `BoolResult`: Result object containing success status and error message if any.

### fullscreen_window()

Makes the specified window fullscreen.

```python
fullscreen_window(window_id: int) -> BoolResult
```

**Parameters:**
- `window_id` (int): The ID of the window to make fullscreen

**Returns:**
- `BoolResult`: Result object containing success status and error message if any.

### focus_mode()

Toggles focus mode on or off.

```python
focus_mode(on: bool) -> BoolResult
```

**Parameters:**
- `on` (bool): True to enable focus mode, False to disable it

**Returns:**
- `BoolResult`: Result object containing success status and error message if any.

## Application Management Operations

The `Computer` class provides application management operations by delegating to the `ApplicationManager` class.

### get_installed_apps()

Gets the list of installed applications.

```python
get_installed_apps(start_menu: bool = True, desktop: bool = False, ignore_system_apps: bool = True) -> InstalledAppListResult
```

**Parameters:**
- `start_menu` (bool, optional): Whether to include start menu applications. Defaults to True.
- `desktop` (bool, optional): Whether to include desktop applications. Defaults to False.
- `ignore_system_apps` (bool, optional): Whether to ignore system applications. Defaults to True.

**Returns:**
- `InstalledAppListResult`: Result object containing list of installed apps and error message if any.

### start_app()

Starts the specified application.

```python
start_app(start_cmd: str, work_directory: str = "", activity: str = "") -> ProcessListResult
```

**Parameters:**
- `start_cmd` (str): The command to start the application
- `work_directory` (str, optional): Working directory for the application. Defaults to ""
- `activity` (str, optional): Activity name to launch (for mobile apps). Defaults to ""

**Returns:**
- `ProcessListResult`: Result object containing list of processes started and error message if any.

### list_visible_apps()

Lists all applications with visible windows.

```python
list_visible_apps() -> ProcessListResult
```

**Returns:**
- `ProcessListResult`: Result object containing list of visible applications with detailed process information.

### stop_app_by_pname()

Stops an application by process name.

```python
stop_app_by_pname(pname: str) -> AppOperationResult
```

**Parameters:**
- `pname` (str): The process name of the application to stop

**Returns:**
- `AppOperationResult`: Result object containing success status and error message if any.

### stop_app_by_pid()

Stops an application by process ID.

```python
stop_app_by_pid(pid: int) -> AppOperationResult
```

**Parameters:**
- `pid` (int): The process ID of the application to stop

**Returns:**
- `AppOperationResult`: Result object containing success status and error message if any.

### stop_app_by_cmd()

Stops an application by stop command.

```python
stop_app_by_cmd(stop_cmd: str) -> AppOperationResult
```

**Parameters:**
- `stop_cmd` (str): The command to stop the application

**Returns:**
- `AppOperationResult`: Result object containing success status and error message if any.

## Complete Example

```python
from agentbay import AgentBay, CreateSessionParams
from agentbay.computer import MouseButton, ScrollDirection
import os

# Initialize SDK
api_key = os.getenv("AGENTBAY_API_KEY")
agent_bay = AgentBay(api_key=api_key)

# Create Windows session
params = CreateSessionParams(image_id="windows_latest")
session_result = agent_bay.create(params)

if session_result.success:
    session = session_result.session
    
    # Get screen size
    screen_info = session.computer.get_screen_size()
    # Verified: ✓ Returns {"dpiScalingFactor":1.0,"height":768,"width":1024}
    
    # Mouse operations
    session.computer.click_mouse(100, 200)
    # Verified: ✓ Left click works
    
    session.computer.move_mouse(300, 400)
    # Verified: ✓ Move mouse works
    
    session.computer.scroll(500, 500, ScrollDirection.DOWN, 3)
    # Verified: ✓ Scroll works
    
    # Keyboard operations
    session.computer.input_text("Hello World")
    # Verified: ✓ Text input works
    
    session.computer.press_keys(["Ctrl", "a"])
    # Verified: ✓ Key press works
    
    # Take screenshot
    screenshot = session.computer.screenshot()
    # Verified: ✓ Returns OSS URL (1039 bytes)
    
    # Clean up
    agent_bay.delete(session)

```

## Related Documentation

- [Window Management API](./window.md) - Detailed window management operations
- [Application Management API](./application.md) - Detailed application management operations
- [Session API](../common-features/basics/session.md) - Session management




# UI Class API Reference

> **⚠️ DEPRECATED**: This API is deprecated. Please use the [Computer API](computer.md) or [Mobile API](../mobile-use/mobile.md) instead for UI automation functionality.

The `UI` class provides methods for interacting with UI elements in the AgentBay cloud environment. This includes retrieving UI elements, sending key events, inputting text, performing gestures, and taking screenshots.

## Properties

###

- `KeyCode`: Constants for key codes that can be used with the `send_key` method.
  - `HOME`: Home key (3)
  - `BACK`: Back key (4)
  - `VOLUME_UP`: Volume up key (24)
  - `VOLUME_DOWN`: Volume down key (25)
  - `POWER`: Power key (26)
  - `MENU`: Menu key (82)

## Methods


Retrieves all clickable UI elements within the specified timeout.


```python
get_clickable_ui_elements(timeout_ms: int = 2000) -> List[Dict[str, Any]]
```

**Parameters:**
- `timeout_ms` (int, optional): The timeout in milliseconds. Default is 2000ms.

**Returns:**
- `List[Dict[str, Any]]`: A list of clickable UI elements.

**Raises:**
- `AgentBayError`: If the operation fails.


```python
get_all_ui_elements(timeout_ms: int = 2000) -> List[Dict[str, Any]]
```

**Parameters:**
- `timeout_ms` (int, optional): The timeout in milliseconds. Default is 2000ms.

**Returns:**
- `List[Dict[str, Any]]`: A list of all UI elements with parsed details.

**Raises:**
- `AgentBayError`: If the operation fails.


```python
send_key(key: int) -> bool
```

**Parameters:**
- `key` (int): The key code to send. Use the `KeyCode` constants.

**Returns:**
- `bool`: True if the key press was successful.

**Raises:**
- `AgentBayError`: If the operation fails.


```python
input_text(text: str) -> None
```

**Parameters:**
- `text` (string): The text to input.

**Raises:**
- `AgentBayError`: If the operation fails.


```python
swipe(start_x: int, start_y: int, end_x: int, end_y: int, duration_ms: int = 300) -> None
```

**Parameters:**
- `start_x` (int): The starting X coordinate.
- `start_y` (int): The starting Y coordinate.
- `end_x` (int): The ending X coordinate.
- `end_y` (int): The ending Y coordinate.
- `duration_ms` (int, optional): The duration of the swipe in milliseconds. Default is 300ms.

**Raises:**
- `AgentBayError`: If the operation fails.


```python
click(x: int, y: int, button: str = "left") -> None
```

**Parameters:**
- `x` (int): The X coordinate.
- `y` (int): The Y coordinate.
- `button` (str, optional): The mouse button to use. Default is 'left'.

**Raises:**
- `AgentBayError`: If the operation fails.


```python
screenshot() -> str
```

**Returns:**
- `str`: The screenshot data.

**Raises:**
- `AgentBayError`: If the operation fails.




# Window Class

> **⚠️ DEPRECATED**: This API is deprecated. Please use the [Computer API](computer.md) instead for window management functionality.

The Window class provides methods for managing windows in the AgentBay cloud environment, including listing windows, getting the active window, and manipulating window states.

## Class Properties

Represents a window in the system.

```python
class Window:
    window_id: int            # The unique identifier of the window
    title: str                # The title of the window
    absolute_upper_left_x: int # The X coordinate of the upper left corner (optional)
    absolute_upper_left_y: int # The Y coordinate of the upper left corner (optional)
    width: int                # The width of the window (optional)
    height: int               # The height of the window (optional)
    pid: int                  # The process ID of the process that owns the window (optional)
    pname: str                # The name of the process that owns the window (optional)
    child_windows: List[Window] # The child windows of this window (optional)
```

## Data Types


Represents a window in the system.


```python
class Window:
    window_id: int            # The unique identifier of the window
    title: str                # The title of the window
    absolute_upper_left_x: int # The X coordinate of the upper left corner (optional)
    absolute_upper_left_y: int # The Y coordinate of the upper left corner (optional)
    width: int                # The width of the window (optional)
    height: int               # The height of the window (optional)
    pid: int                  # The process ID of the process that owns the window (optional)
    pname: str                # The name of the process that owns the window (optional)
    child_windows: List[Window] # The child windows of this window (optional)
```


```python
def list_root_windows(self) -> WindowListResult:
```

**Returns:**
- `WindowListResult`: Result object containing list of windows and error message if any.

**Note:**
- Check the `success` attribute of the result to determine if the operation was successful.
- Access the list of windows through the `windows` attribute of the result.


```python
def get_active_window(self) -> WindowInfoResult:
```

**Returns:**
- `WindowInfoResult`: Result object containing window information and error message if any.

**Note:**
- Check the `success` attribute of the result to determine if the operation was successful.
- Access the window object through the `window` attribute of the result.


```python
def activate_window(self, window_id: int) -> BoolResult:
```

**Parameters:**
- `window_id` (int): The ID of the window to activate.

**Returns:**
- `BoolResult`: Result object containing success status and error message if any.

**Note:**
- Check the `success` attribute of the result to determine if the operation was successful.


```python
def minimize_window(self, window_id: int) -> BoolResult:
```

**Parameters:**
- `window_id` (int): The ID of the window to minimize.

**Returns:**
- `BoolResult`: Result object containing success status and error message if any.

**Note:**
- Check the `success` attribute of the result to determine if the operation was successful.


```python
def maximize_window(self, window_id: int) -> BoolResult:
```

**Parameters:**
- `window_id` (int): The ID of the window to maximize.

**Returns:**
- `BoolResult`: Result object containing success status and error message if any.

**Note:**
- Check the `success` attribute of the result to determine if the operation was successful.


```python
def restore_window(self, window_id: int) -> BoolResult:
```

**Parameters:**
- `window_id` (int): The ID of the window to restore.

**Returns:**
- `BoolResult`: Result object containing success status and error message if any.

**Note:**
- Check the `success` attribute of the result to determine if the operation was successful.


```python
def fullscreen_window(self, window_id: int) -> BoolResult:
```

**Parameters:**
- `window_id` (int): The ID of the window to make fullscreen.

**Returns:**
- `BoolResult`: Result object containing success status and error message if any.

**Note:**
- Check the `success` attribute of the result to determine if the operation was successful.


```python
def resize_window(self, window_id: int, width: int, height: int) -> BoolResult:
```

**Parameters:**
- `window_id` (int): The ID of the window to resize.
- `width` (int): The new width of the window.
- `height` (int): The new height of the window.

**Returns:**
- `BoolResult`: Result object containing success status and error message if any.

**Note:**
- Check the `success` attribute of the result to determine if the operation was successful.


```python
def close_window(self, window_id: int) -> BoolResult:
```

**Parameters:**
- `window_id` (int): The ID of the window to close.

**Returns:**
- `BoolResult`: Result object containing success status and error message if any.

**Note:**
- Check the `success` attribute of the result to determine if the operation was successful.


```python
def focus_mode(self, on: bool) -> BoolResult:
```

**Parameters:**
- `on` (bool): True to enable focus mode, False to disable it.

**Returns:**
- `BoolResult`: Result object containing success status and error message if any.

**Note:**
- Check the `success` attribute of the result to determine if the operation was successful.




# Mobile Class API Reference

The `Mobile` class provides comprehensive mobile device UI automation operations in the AgentBay cloud environment. It offers touch operations, UI element interactions, application management, and screenshot capabilities for Android mobile device automation.

## 📖 Related Tutorials

- [Mobile UI Automation Guide](../../../../docs/guides/mobile-use/mobile-ui-automation.md) - Detailed tutorial on mobile UI automation
- [Mobile Application Management Guide](../../../../docs/guides/mobile-use/mobile-application-management.md) - Tutorial on managing mobile applications

## Overview

The `Mobile` class is available through `session.mobile` and is designed for use with Android mobile environments (use a mobile environment image such as `mobile_latest` when creating sessions).

## Constructor

The `Mobile` class is automatically instantiated when creating a session. Access it via:

```python
session.mobile
```

## KeyCode Class

Key codes for mobile device input.

```python
from agentbay.mobile.mobile import KeyCode

KeyCode.HOME        # 3  - Home button
KeyCode.BACK        # 4  - Back button
KeyCode.VOLUME_UP   # 24 - Volume up button
KeyCode.VOLUME_DOWN # 25 - Volume down button
KeyCode.POWER       # 26 - Power button
KeyCode.MENU        # 82 - Menu button
```

## Touch Operations

### tap()

Taps on the screen at the specified coordinates.

```python
tap(x: int, y: int) -> BoolResult
```

**Parameters:**
- `x` (int): X coordinate
- `y` (int): Y coordinate

**Returns:**
- `BoolResult`: Result object containing success status and error message if any.

**Example:**
```python
from agentbay import AgentBay, CreateSessionParams

# Create session with mobile image
agent_bay = AgentBay(api_key="your_api_key")
params = CreateSessionParams(image_id="mobile_latest")
session_result = agent_bay.create(params)
session = session_result.session

# Tap at coordinates (500, 500)
result = session.mobile.tap(500, 500)
# Verified: success=True

agent_bay.delete(session)
```

### swipe()

Performs a swipe gesture from one point to another.

```python
swipe(start_x: int, start_y: int, end_x: int, end_y: int, duration_ms: int = 300) -> BoolResult
```

**Parameters:**
- `start_x` (int): Starting X coordinate
- `start_y` (int): Starting Y coordinate
- `end_x` (int): Ending X coordinate
- `end_y` (int): Ending Y coordinate
- `duration_ms` (int, optional): Duration of the swipe in milliseconds. Defaults to 300.

**Returns:**
- `BoolResult`: Result object containing success status and error message if any.

**Example:**
```python
# Swipe up (from bottom to top)
result = session.mobile.swipe(540, 1500, 540, 500, duration_ms=300)
# Verified: success=True

# Swipe left (from right to left)
result = session.mobile.swipe(900, 500, 100, 500, duration_ms=200)
# Verified: success=True

# Swipe right (from left to right)
result = session.mobile.swipe(100, 500, 900, 500, duration_ms=200)
# Verified: success=True
```

### input_text()

Inputs text into the active field.

```python
input_text(text: str) -> BoolResult
```

**Parameters:**
- `text` (str): The text to input

**Returns:**
- `BoolResult`: Result object containing success status and error message if any.

**Example:**
```python
# Type text into active field
result = session.mobile.input_text("Hello Mobile")
# Verified: success=True
```

### send_key()

Sends a key press event.

```python
send_key(key: int) -> BoolResult
```

**Parameters:**
- `key` (int): The key code to send. Supported key codes:
  - 3  : HOME
  - 4  : BACK
  - 24 : VOLUME UP
  - 25 : VOLUME DOWN
  - 26 : POWER
  - 82 : MENU

**Returns:**
- `BoolResult`: Result object containing success status and error message if any.

**Example:**
```python
from agentbay.mobile.mobile import KeyCode

# Press HOME button
result = session.mobile.send_key(KeyCode.HOME)
# Verified: success=True

# Press BACK button
result = session.mobile.send_key(KeyCode.BACK)
# Verified: success=True

# Press MENU button
result = session.mobile.send_key(KeyCode.MENU)
# Verified: success=True
```

## UI Element Operations

### get_clickable_ui_elements()

Retrieves all clickable UI elements within the specified timeout.

```python
get_clickable_ui_elements(timeout_ms: int = 2000) -> UIElementListResult
```

**Parameters:**
- `timeout_ms` (int, optional): Timeout in milliseconds. Defaults to 2000.

**Returns:**
- `UIElementListResult`: Result object containing clickable UI elements and error message if any.

**Example:**
```python
# Get all clickable elements
result = session.mobile.get_clickable_ui_elements(timeout_ms=2000)
# Verified: success=True, returns list of clickable elements

if result.success:
    print(f"Found {len(result.elements)} clickable elements")
    for element in result.elements:
        print(f"Element: {element}")
```

### get_all_ui_elements()

Retrieves all UI elements within the specified timeout.

```python
get_all_ui_elements(timeout_ms: int = 2000) -> UIElementListResult
```

**Parameters:**
- `timeout_ms` (int, optional): Timeout in milliseconds. Defaults to 2000.

**Returns:**
- `UIElementListResult`: Result object containing all UI elements and error message if any.

**Example:**
```python
# Get all UI elements
result = session.mobile.get_all_ui_elements(timeout_ms=2000)
# Verified: success=True, returns list of all UI elements

if result.success:
    print(f"Found {len(result.elements)} total elements")
    for element in result.elements:
        print(f"Element: {element}")
```

## Application Management Operations

### get_installed_apps()

Retrieves a list of installed applications.

```python
get_installed_apps(start_menu: bool, desktop: bool, ignore_system_apps: bool) -> InstalledAppListResult
```

**Parameters:**
- `start_menu` (bool): Whether to include start menu applications
- `desktop` (bool): Whether to include desktop applications
- `ignore_system_apps` (bool): Whether to ignore system applications

**Returns:**
- `InstalledAppListResult`: The result containing the list of installed applications.

**Example:**
```python
# Get installed apps (excluding system apps)
result = session.mobile.get_installed_apps(
    start_menu=False,
    desktop=False,
    ignore_system_apps=True
)
# Verified: success=True, returns list of installed apps

if result.success:
    for app in result.data:
        print(f"App: {app.name}, Command: {app.start_cmd}")
```

### start_app()

Starts an application with the given command, optional working directory and optional activity.

```python
start_app(start_cmd: str, work_directory: str = "", activity: str = "") -> ProcessListResult
```

**Parameters:**
- `start_cmd` (str): The command to start the application. For Android apps, this should be in the format required by the system (e.g., using monkey command).
- `work_directory` (str, optional): The working directory for the application. Defaults to "".
- `activity` (str, optional): Activity name to launch (e.g., ".SettingsActivity" or "com.package/.Activity"). Defaults to "".

**Returns:**
- `ProcessListResult`: The result containing the list of processes started.

**Example:**
```python
# Start Settings app
# Note: start_cmd format is specific to the mobile automation system
result = session.mobile.start_app(
    "com.android.settings",
    activity=".Settings"
)
# Note: Requires specific command format. Check with system documentation.

if result.success:
    print(f"Started {len(result.data)} processes")
```

### stop_app_by_cmd()

Stops an application by stop command.

```python
stop_app_by_cmd(stop_cmd: str) -> AppOperationResult
```

**Parameters:**
- `stop_cmd` (str): The command to stop the application

**Returns:**
- `AppOperationResult`: The result of the operation.

**Example:**
```python
# Stop an application
result = session.mobile.stop_app_by_cmd("am force-stop com.example.app")

if result.success:
    print("App stopped successfully")
```

## Screenshot Operations

### screenshot()

Takes a screenshot of the current screen.

```python
screenshot() -> OperationResult
```

**Returns:**
- `OperationResult`: Result object containing the screenshot URL and error message if any.

**Example:**
```python
# Take a screenshot
result = session.mobile.screenshot()
# Verified: success=True, returns OSS URL to screenshot image

if result.success:
    print(f"Screenshot URL: {result.data}")
```

## Complete Example

```python
from agentbay import AgentBay, CreateSessionParams
from agentbay.mobile.mobile import KeyCode
import os

# Initialize SDK
api_key = os.getenv("AGENTBAY_API_KEY")
agent_bay = AgentBay(api_key=api_key)

# Create mobile session
params = CreateSessionParams(image_id="mobile_latest")
session_result = agent_bay.create(params)

if session_result.success:
    session = session_result.session
    
    # Touch operations
    session.mobile.tap(500, 500)
    # Verified: success=True
    
    session.mobile.swipe(540, 1500, 540, 500, duration_ms=300)
    # Verified: success=True
    
    session.mobile.input_text("Hello Mobile")
    # Verified: success=True
    
    # Key operations
    session.mobile.send_key(KeyCode.HOME)
    # Verified: success=True
    
    session.mobile.send_key(KeyCode.BACK)
    # Verified: success=True
    
    # Get UI elements
    clickable_elements = session.mobile.get_clickable_ui_elements(timeout_ms=2000)
    # Verified: success=True
    
    if clickable_elements.success:
        print(f"Found {len(clickable_elements.elements)} clickable elements")
    
    all_elements = session.mobile.get_all_ui_elements(timeout_ms=2000)
    # Verified: success=True
    
    if all_elements.success:
        print(f"Found {len(all_elements.elements)} total elements")
    
    # Get installed apps
    apps = session.mobile.get_installed_apps(
        start_menu=False,
        desktop=False,
        ignore_system_apps=True
    )
    # Verified: success=True
    
    if apps.success:
        print(f"Installed apps: {len(apps.data)}")
    
    # Take screenshot
    screenshot = session.mobile.screenshot()
    # Verified: success=True, returns screenshot URL
    
    if screenshot.success:
        print(f"Screenshot: {screenshot.data}")
    
    # Clean up
    agent_bay.delete(session)

```

## Mobile Configuration and Connectivity

### get_adb_url()

Retrieves the ADB connection URL for the mobile environment. This method is only supported in mobile environments.

The method requires an ADB public key for authentication and returns the ADB connection URL that can be used with the `adb connect` command.

```python
get_adb_url(adbkey_pub: str) -> AdbUrlResult
```

**Parameters:**
- `adbkey_pub` (str): The ADB public key for connection authentication. This is typically a base64-encoded string obtained from your ADB setup.

**Returns:**
- `AdbUrlResult`: Result object containing:
  - `success` (bool): Whether the operation was successful
  - `data` (str): The ADB connection URL in format "adb connect <IP>:<Port>" on success, None on failure
  - `request_id` (str): Unique identifier for the API request
  - `error_message` (str): Error message if the operation failed

**Raises:**
- `SessionError`: May be raised for unexpected errors during the operation

**Environment Requirements:**
- This method **only works** with mobile environment images
- Calling on other environments (e.g., browser or Linux environments) will return an error

**Example:**
```python
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams

# Create a mobile session
agent_bay = AgentBay(api_key="your_api_key")
params = CreateSessionParams(image_id="mobile_latest")
session_result = agent_bay.create(params)
session = session_result.session

# Get ADB URL with public key
adbkey_pub = "QAAAAM0muSn7yQCY...your_adb_public_key...EAAQAA="

result = session.mobile.get_adb_url(adbkey_pub)
# Verified: success=True, returns ADB connection URL

if result.success:
    print(f"ADB URL: {result.data}")
    # Example output: "adb connect xx.xx.xx.xx:xxxxx"
    print(f"Request ID: {result.request_id}")
else:
    print(f"Error: {result.error_message}")

# Clean up
agent_bay.delete(session)
```

**Notes:**
1. The `adbkey_pub` parameter should be a valid ADB public key from your setup
2. The returned URL can be used directly with the `adb connect` command
3. This method is exclusive to mobile environments; using other images will result in an error
4. Each call includes a `request_id` for tracking and debugging purposes

## Usage Notes

1. **Session Image**: Always use a mobile environment image (e.g., `mobile_latest`) when creating sessions for mobile automation.

2. **Coordinates**: Mobile screen coordinates typically range based on the device resolution. Common Android emulator resolutions:
   - 1080x1920 (Full HD)
   - 720x1280 (HD)
   - Check screen size using UI elements or emulator settings.

3. **Swipe Duration**: The `duration_ms` parameter in `swipe()` affects the speed of the gesture. Shorter durations (100-200ms) create faster swipes, while longer durations (500-1000ms) create slower, more deliberate gestures.

4. **Key Codes**: Only the predefined key codes in the `KeyCode` class are supported. Custom key codes may not work as expected.

5. **App Management**: The `start_app()` command format is specific to the mobile automation system. Verify the correct format with system documentation.

6. **UI Elements**: UI element detection may take time. Adjust the `timeout_ms` parameter based on your application's loading speed.

## Related Documentation

- [Application Management API](../computer-use/application.md) - Detailed application management operations
- [UI Automation API](../computer-use/ui.md) - UI automation operations
- [Session API](../common-features/basics/session.md) - Session management




# Python SDK Examples

This directory contains Python examples demonstrating various features and capabilities of the AgentBay SDK.

## 📁 Directory Structure

The examples are organized by feature categories:

```
examples/
├── basic_usage.py                 # Quick start single-file example
├── common-features/               # Features available across all environments
│   ├── basics/                    # Essential features
│   │   ├── session_creation/      # Session lifecycle management
│   │   ├── file_system/           # File operations
│   │   ├── filesystem_example/    # Practical filesystem use cases
│   │   ├── context_management/    # Context creation and management
│   │   ├── data_persistence/      # Data persistence across sessions
│   │   ├── label_management/      # Session organization with labels
│   │   ├── list_sessions/         # Session listing and filtering
│   │   └── get/                   # Session retrieval
│   └── advanced/                  # Advanced features
│       ├── agent_module/          # AI-powered automation
│       ├── oss_management/        # Object Storage Service integration
│       ├── vpc_session/           # Secure isolated network environments
│       └── screenshot_download/   # Screenshot capture and download
├── browser-use/                   # Browser automation (browser_latest)
│   ├── browser/                   # Browser automation examples
│   └── extension/                 # Browser extension management
├── computer-use/                  # Windows desktop automation (windows_latest)
│   └── computer/                  # Application and window management
├── mobile-use/                    # Mobile UI automation (mobile_latest)
│   ├── mobile_system/             # Mobile automation examples
│   └── mobile_get_adb_url_example.py  # ADB URL retrieval
└── codespace/                     # Code execution (code_latest)
    └── code_execution_example.py  # Python/JavaScript code execution
```

## 🚀 Quick Start

### Single-File Example

The fastest way to get started:

```bash
# Set your API key
export AGENTBAY_API_KEY=your_api_key_here

# Run the quick start example
python basic_usage.py
```

This example demonstrates:
- Initializing the AgentBay client
- Creating sessions
- Basic operations (commands, file operations)
- Session cleanup

## 📚 Feature Categories

### [Common Features](common-features/)

Features available across all environment types (browser, computer, mobile, codespace).

**Basics:**
- **Session Management**: Create, configure, and manage cloud sessions
- **File Operations**: Read, write, and manage files in cloud environments
- **Context Management**: Persistent data storage across sessions
- **Data Persistence**: Cross-session data sharing and synchronization
- **Label Management**: Organize and filter sessions with labels

**Advanced:**
- **Agent Module**: AI-powered task automation with natural language
- **OSS Integration**: Object Storage Service for file management
- **VPC Sessions**: Secure isolated network environments
- **Screenshot Download**: Capture and download screenshots

### [Browser Use](browser-use/)

Cloud-based browser automation with Playwright integration.

**Key Features:**
- Cookie and session persistence
- Stealth mode to avoid detection
- CAPTCHA handling capabilities
- Browser extension support
- AI-powered automation
- Proxy configuration

**Use Cases:**
- Web scraping and data extraction
- Automated testing
- Form filling and submission
- Game automation
- E-commerce automation

### [Computer Use](computer-use/)

Windows desktop automation for application control and window management.

**Key Features:**
- Application management (start, stop, list)
- Window operations (maximize, minimize, resize, close)
- Focus management
- Desktop UI automation
- Process monitoring

**Use Cases:**
- Desktop application testing
- Automated workflows
- Application monitoring
- UI automation

### [Mobile Use](mobile-use/)

Android mobile UI automation for app testing and gesture-based interactions.

**Key Features:**
- UI element detection and interaction
- Touch gestures (tap, swipe, scroll)
- Text input and key events
- Screenshot capture
- Mobile application management
- ADB integration

**Use Cases:**
- Mobile app testing
- UI automation
- Gesture-based interactions
- Screenshot verification

### [CodeSpace](codespace/)

Cloud-based development environment for code execution and scripting.

**Key Features:**
- Python code execution
- JavaScript/Node.js code execution
- Shell command execution
- File system operations
- Package management (pip, npm)

**Use Cases:**
- Automated testing
- Code validation
- Data processing
- CI/CD integration
- Educational tools

## 📋 Prerequisites

### Basic Requirements

- Python 3.8 or later
- AgentBay SDK: `pip install wuying-agentbay-sdk`
- Valid `AGENTBAY_API_KEY` environment variable

### Additional Requirements by Category

**Browser Use:**
```bash
pip install playwright
playwright install chromium
```

**All Others:**
No additional requirements beyond the basic SDK.

## 🎯 Running Examples

### Option 1: Using Installed Package (Recommended)

1. Install the SDK:
```bash
pip install wuying-agentbay-sdk
```

2. For browser examples, install Playwright:
```bash
playwright install chromium
```

3. Set your API key:
```bash
export AGENTBAY_API_KEY=your_api_key_here
```

4. Run any example:
```bash
python basic_usage.py
python common-features/basics/session_creation/main.py
python browser-use/browser/browser_stealth.py
python codespace/code_execution_example.py
```

### Option 2: Development from Source

1. Install dependencies:
```bash
cd python
poetry install
```

2. For browser examples, install Playwright:
```bash
poetry run playwright install chromium
```

3. Set your API key:
```bash
export AGENTBAY_API_KEY=your_api_key_here
```

4. Run examples with poetry:
```bash
poetry run python docs/examples/basic_usage.py
poetry run python docs/examples/common-features/basics/session_creation/main.py
```

## 💡 Common Patterns

### Basic Session Creation

```python
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams

# Initialize client
agent_bay = AgentBay(api_key="your_api_key")

# Create session
params = CreateSessionParams(image_id="linux_latest")
result = agent_bay.create(params)

if result.success:
    session = result.session
    # Use session...
    
    # Cleanup
    agent_bay.delete(session)
```

### File Operations

```python
# Write file
result = session.file_system.write_file("/tmp/test.txt", "content")

# Read file
result = session.file_system.read_file("/tmp/test.txt")
if result.success:
    print(result.content)
```

### Command Execution

```python
result = session.command.execute_command("ls -la")
if result.success:
    print(result.output)
```

### Browser Automation

```python
import asyncio
from agentbay.browser.browser import BrowserOption
from playwright.async_api import async_playwright

async def automate():
    # Initialize browser
    option = BrowserOption()
    await session.browser.initialize_async(option)
    
    # Connect Playwright
    endpoint_url = session.browser.get_endpoint_url()
    async with async_playwright() as p:
        browser = await p.chromium.connect_over_cdp(endpoint_url)
        context = browser.contexts[0]
        page = await context.new_page()
        
        # Automate...
        await page.goto("https://example.com")
        
        await browser.close()

asyncio.run(automate())
```

### Code Execution

```python
# Python code
python_code = """
print("Hello from Python!")
"""
result = session.code.run_code(python_code, "python")

# JavaScript code
js_code = """
console.log("Hello from JavaScript!");
"""
result = session.code.run_code(js_code, "javascript")
```

## 🎓 Learning Path

### For Beginners

1. Start with [basic_usage.py](basic_usage.py)
2. Explore [Common Features - Basics](common-features/basics/)
3. Try environment-specific examples based on your use case

### For Experienced Developers

1. Review [Common Features](common-features/) for SDK capabilities
2. Jump to your specific environment:
   - [Browser Use](browser-use/) for web automation
   - [Computer Use](computer-use/) for desktop automation
   - [Mobile Use](mobile-use/) for mobile automation
   - [CodeSpace](codespace/) for code execution
3. Explore [Advanced Features](common-features/advanced/) for integrations

## 📖 Best Practices

1. **Always Clean Up**: Delete sessions when done to free resources
2. **Error Handling**: Check `result.success` before using data
3. **Use Labels**: Organize sessions with meaningful labels
4. **Context Sync**: Use context synchronization for data persistence
5. **Resource Limits**: Be aware of concurrent session limits
6. **Proper Cleanup**: Close connections and delete sessions properly
7. **API Key Security**: Never commit API keys to version control

## 🔍 Example Index

### By Use Case

**Web Automation:**
- Browser stealth mode: `browser-use/browser/browser_stealth.py`
- Cookie persistence: `browser-use/browser/browser_context_cookie_persistence.py`
- AI-powered automation: `browser-use/browser/search_agentbay_doc_by_agent.py`

**Desktop Automation:**
- Application management: `computer-use/computer/windows_app_management_example.py`

**Mobile Automation:**
- Mobile UI automation: `mobile-use/mobile_system/main.py`
- ADB integration: `mobile-use/mobile_get_adb_url_example.py`

**Code Execution:**
- Python/JavaScript execution: `codespace/code_execution_example.py`

**Data Management:**
- File operations: `common-features/basics/file_system/main.py`
- Context management: `common-features/basics/context_management/main.py`
- Data persistence: `common-features/basics/data_persistence/main.py`

**Advanced Features:**
- AI Agent: `common-features/advanced/agent_module/main.py`
- OSS integration: `common-features/advanced/oss_management/main.py`
- VPC sessions: `common-features/advanced/vpc_session/main.py`

## 🆘 Troubleshooting

### Resource Creation Delay

If you see "The system is creating resources" message:
- Wait 90 seconds and retry
- This is normal for resource initialization
- Consider using session pooling for production

### API Key Issues

Ensure your API key is properly set:
```bash
export AGENTBAY_API_KEY=your_api_key_here
# Verify
echo $AGENTBAY_API_KEY
```

### Import Errors

If you get import errors:
```bash
# Ensure SDK is installed
pip install wuying-agentbay-sdk

# Or for development
cd python
poetry install
```

### Browser Examples Not Working

For browser examples:
```bash
# Install Playwright
pip install playwright
playwright install chromium
```

## 📚 Related Documentation

- [Python SDK Documentation](../../)
- [API Reference](../api/)
- [Quick Start Guide](../../../docs/quickstart/README.md)
- [Feature Guides](../../../docs/guides/README.md)
- [Common Features Guide](../../../docs/guides/common-features/README.md)
- [Browser Use Guide](../../../docs/guides/browser-use/README.md)
- [Computer Use Guide](../../../docs/guides/computer-use/README.md)
- [Mobile Use Guide](../../../docs/guides/mobile-use/README.md)
- [CodeSpace Guide](../../../docs/guides/codespace/README.md)

## 🤝 Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Documentation](../../../docs/README.md)

---

💡 **Tip**: Start with `basic_usage.py` for a quick overview, then explore category-specific examples based on your needs.





# Archive Upload Mode Context Sync Example

This directory contains examples demonstrating the Archive upload mode functionality for context synchronization in the AgentBay SDK.

## Overview

The Archive upload mode is designed for efficient file transfer by compressing files before uploading them to the context storage. This is particularly useful when:

- Working with large files
- Dealing with many files
- Optimizing bandwidth usage
- Reducing upload time for compressible content

## Files

### `main.py`

A comprehensive example that demonstrates:

1. **Context Creation**: Creating a context for Archive upload mode
2. **Sync Policy Configuration**: Setting up sync policy with Archive uploadMode
3. **Session Management**: Creating and managing sessions with context sync
4. **File Operations**: Writing files to the context path
5. **Context Sync**: Synchronizing context before retrieving information
6. **Context Info**: Retrieving context status information
7. **File Listing**: Listing files in context sync directory
8. **Cleanup**: Proper session cleanup and error handling

## Key Features Demonstrated

### Archive Upload Mode Configuration

```python
# Configure sync policy with Archive upload mode
upload_policy = UploadPolicy(upload_mode=UploadMode.ARCHIVE)
sync_policy = SyncPolicy(upload_policy=upload_policy)

# Create context sync with Archive mode
context_sync = ContextSync(
    context_id=context_result.context_id,
    path="/tmp/archive-mode-test",
    policy=sync_policy
)
```

### Session Creation with Context Sync

```python
session_params = CreateSessionParams(
    labels={
        "example": f"archive-mode-{unique_id}",
        "type": "archive-upload-demo",
        "uploadMode": UploadMode.ARCHIVE.value
    },
    context_syncs=[context_sync]
)

session_result = agent_bay.create(session_params)
```

### File Operations

```python
# Write file to context path
write_result = session.file_system.write_file(file_path, file_content, mode="overwrite")
```

### Context Sync and Information Retrieval

```python
# Call context sync before getting info (async operation)
import asyncio

async def run_sync():
    return await session.context.sync()

sync_result = asyncio.run(run_sync())

# Get context status information after sync
info_result = session.context.info()

# Display context status details
for index, status in enumerate(info_result.context_status_data):
    print(f"Context ID: {status.context_id}")
    print(f"Path: {status.path}")
    print(f"Status: {status.status}")
    print(f"Task Type: {status.task_type}")
```

### File Listing in Context Directory

```python
# List files in context sync directory
list_result = agent_bay.context.list_files(context_id, sync_dir_path, page_number=1, page_size=10)

# Display file entries
for index, entry in enumerate(list_result.entries):
    print(f"FilePath: {entry.file_path}")
    print(f"FileType: {entry.file_type}")
    print(f"FileName: {entry.file_name}")
    print(f"Size: {entry.size} bytes")
```

## Running the Example

### Prerequisites

1. **Environment Setup**: Set your AgentBay API key
   ```bash
   export AGENTBAY_API_KEY="your-api-key-here"
   ```

2. **Dependencies**: Ensure you have the AgentBay SDK installed
   ```bash
   pip install wuying-agentbay-sdk-test
   ```

### Execution

```bash
# Navigate to the python directory
cd python

# Run the example
python docs/examples/archive-upload-mode-example/main.py
```

### Expected Output

The example will output detailed logs showing:

```
🚀 AgentBay Archive Upload Mode Context Sync Example
============================================================

📦 Step 1: Creating context for Archive upload mode...
✅ Context created successfully!
   Context ID: ctx_xxxxx
   Request ID: req_xxxxx

⚙️  Step 2: Configuring sync policy with Archive upload mode...
✅ Sync policy configured with uploadMode: Archive

🔧 Step 3: Creating context sync configuration...
✅ Context sync created:
   Context ID: ctx_xxxxx
   Path: /tmp/archive-mode-test
   Upload Mode: Archive

🏗️  Step 4: Creating session with Archive mode context sync...
✅ Session created successfully!
   Session ID: sess_xxxxx
   Request ID: req_xxxxx
   App Instance ID: app_xxxxx

📝 Step 5: Creating test files in Archive mode context...
📄 Creating file: /tmp/archive-mode-test/test-file-5kb.txt
📊 File content size: 5120 bytes
✅ File write successful!
   Request ID: req_xxxxx

📊 Step 6: Testing context sync and info functionality...
🔄 Calling context sync before getting info...
✅ Context sync successful!
   Sync Request ID: req_xxxxx
📋 Calling context info after sync...
✅ Context info retrieved successfully!
   Info Request ID: req_xxxxx
   Context status data count: X

📋 Context status details:
   [0] Context ID: ctx_xxxxx
       Path: /tmp/archive-mode-test
       Status: Success
       Task Type: upload

🔍 Step 7: Listing files in context sync directory...
✅ List files successful!
   Request ID: req_xxxxx
   Total files found: X

📋 Files in context sync directory:
   [0] FilePath: /tmp/archive-mode-test/test-file-5kb.txt
       FileType: file
       FileName: test-file-5kb.txt
       Size: 5120 bytes

🎉 Archive upload mode example completed successfully!
✅ All operations completed without errors.

🧹 Step 8: Cleaning up session...
✅ Session deleted successfully!
   Success: true
   Request ID: req_xxxxx
```

## Related Documentation

- [Context Sync Documentation](../../../../docs/guides/common-features/basics/data-persistence.md)
- [Session Management Guide](../../../../docs/guides/common-features/basics/session-management.md)
- [File Operations Guide](../../../../docs/guides/common-features/basics/file-operations.md)

## Troubleshooting

### Common Issues

1. **API Key Not Set**
   ```
   Warning: AGENTBAY_API_KEY environment variable not set
   ```
   **Solution**: Set the environment variable or update the API key in the code

2. **Context Creation Failed**
   ```
   Context creation failed: [error message]
   ```
   **Solution**: Check your API key and network connectivity

3. **Session Creation Failed**
   ```
   Session creation failed: [error message]
   ```
   **Solution**: Verify context sync configuration and try again

4. **File Operation Failed**
   ```
   File write failed: [error message]
   ```
   **Solution**: Check file path permissions and available disk space

## Support

For additional help:
- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Documentation Home](../../../README.md)



# Browser Use Examples

This directory contains examples demonstrating browser automation capabilities in AgentBay SDK.

## Overview

Browser Use environment (`browser_latest` image) provides cloud-based browser automation with:
- Playwright integration for browser control
- Stealth mode to avoid detection
- Cookie and session persistence
- CAPTCHA handling capabilities
- Browser extension support
- AI-powered automation

## Directory Structure

```
browser-use/
├── browser/        # Browser automation examples
└── extension/      # Browser extension management examples
```

## Browser Examples

### Core Features

#### browser_context_cookie_persistence.py
Cookie persistence across multiple sessions:
- Creating sessions with Browser Context
- Setting cookies manually using Playwright
- Deleting sessions with context synchronization
- Verifying cookie persistence in new sessions

#### browser_stealth.py
Stealth mode to avoid bot detection:
- Browser fingerprint randomization
- Anti-detection techniques
- Stealth configuration options

#### browser_viewport.py
Custom viewport configuration:
- Setting custom screen resolutions
- Device emulation
- Responsive testing

#### browser_proxies.py
Proxy configuration for network routing:
- HTTP/HTTPS proxy setup
- SOCKS proxy support
- Authentication configuration

#### browser_type_example.py
Browser type selection:
- Chrome browser usage
- Chromium browser usage
- Default browser configuration

#### browser_command_args.py
Custom browser launch arguments:
- Performance optimization
- Feature flags
- Security settings

#### browser_replay.py
Session replay functionality:
- Recording browser sessions
- Replaying recorded sessions
- Session state restoration

### AI-Powered Automation

#### search_agentbay_doc.py
Manual browser automation with Playwright:
- Direct Playwright interactions
- Element selection and interaction
- Search operations

#### search_agentbay_doc_by_agent.py
AI-powered automation using Agent module:
- Natural language commands
- AI-driven element detection
- Simplified complex interactions

### Real-World Use Cases

#### Game Automation
- **game_2048.py**: 2048 game automation
- **game_sudoku.py**: Sudoku game automation
- **sudoku_solver.py**: Advanced Sudoku solving

#### E-commerce and Business
- **admin_add_product.py**: Product management automation
- **shop_inspector.py**: E-commerce shop inspection
- **expense_upload_invoices.py**: Invoice upload automation
- **gv_quick_buy_seat.py**: Quick seat booking

#### Web Interaction
- **visit_aliyun.py**: Basic website navigation
- **alimeeting_availability.py**: Meeting availability checking
- **call_for_user_jd.py**: JD.com user interaction
- **mini_max.py**: MiniMax platform automation

#### CAPTCHA Handling
- **captcha_tongcheng.py**: CAPTCHA solving example

## Extension Examples

### basic_extension_usage.py
Loading and using browser extensions:
- Extension installation
- Extension configuration
- Using extensions in automation

### extension_development_workflow.py
Extension development patterns:
- Development mode setup
- Testing extensions
- Debugging workflows

### extension_testing_automation.py
Automated extension testing:
- Test automation for extensions
- Validation workflows
- CI/CD integration

## Prerequisites

1. **Install Python SDK**:
   ```bash
   pip install wuying-agentbay-sdk
   ```

2. **Install Playwright**:
   ```bash
   pip install playwright
   playwright install chromium
   ```

3. **Set API Key**:
   ```bash
   export AGENTBAY_API_KEY=your_api_key_here
   ```

## Quick Start

### Basic Browser Automation

```python
import asyncio
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams
from agentbay.browser.browser import BrowserOption
from playwright.async_api import async_playwright

async def main():
    # Create session
    agent_bay = AgentBay(api_key="your_api_key")
    params = CreateSessionParams(image_id="browser_latest")
    result = agent_bay.create(params)
    session = result.session
    
    # Initialize browser
    option = BrowserOption()
    await session.browser.initialize_async(option)
    
    # Connect Playwright
    endpoint_url = session.browser.get_endpoint_url()
    async with async_playwright() as p:
        browser = await p.chromium.connect_over_cdp(endpoint_url)
        context = browser.contexts[0]
        page = await context.new_page()
        
        # Automate...
        await page.goto("https://example.com")
        
        await browser.close()
    
    # Cleanup
    agent_bay.delete(session)

asyncio.run(main())
```

### AI-Powered Automation

```python
# Use Agent for intelligent automation
result = await session.browser.agent.act_async(
    "Search for AgentBay on the page and click the first result"
)
```

## Browser Type Selection

```python
from agentbay.browser.browser import BrowserOption

# Use Chrome
option = BrowserOption(browser_type="chrome")
await session.browser.initialize_async(option)

# Use Chromium
option = BrowserOption(browser_type="chromium")
await session.browser.initialize_async(option)

# Use default
option = BrowserOption()
await session.browser.initialize_async(option)
```

## Stealth Configuration

```python
from agentbay.browser.browser import (
    BrowserOption,
    BrowserViewport,
    BrowserFingerprint
)

option = BrowserOption(
    browser_type="chrome",
    use_stealth=True,
    viewport=BrowserViewport(1920, 1080),
    fingerprint=BrowserFingerprint(
        devices=["desktop"],
        operating_systems=["windows", "macos"],
        locales=["en-US"]
    )
)
```

## Cookie Persistence

```python
from agentbay.session_params import BrowserContext

# Create browser context
context_result = agent_bay.context.get("my-browser-context", create=True)

browser_context = BrowserContext(
    context_id=context_result.context.id,
    auto_upload=True
)

params = CreateSessionParams(
    image_id="browser_latest",
    browser_context=browser_context
)

# Cookies will persist across sessions
```

## Best Practices

1. **Always use context synchronization**: When deleting sessions with important browser data, use `sync_context=True`
2. **Proper cleanup**: Always delete sessions and contexts when done
3. **Error handling**: Implement proper error handling for network and browser operations
4. **Resource management**: Close browser connections properly
5. **Unique context names**: Use unique context names to avoid conflicts
6. **Stealth mode**: Use stealth mode for production web scraping
7. **Rate limiting**: Respect website rate limits and robots.txt

## Common Patterns

### Error Handling

```python
try:
    success = await session.browser.initialize_async(option)
    if not success:
        raise RuntimeError("Initialization failed")
    
    # Use browser...
    
except Exception as e:
    print(f"Error: {e}")
finally:
    agent_bay.delete(session)
```

### Waiting for Elements

```python
# Wait for element
await page.wait_for_selector("#my-element", timeout=5000)

# Wait for navigation
await page.wait_for_load_state("networkidle")
```

### Taking Screenshots

```python
# Full page screenshot
await page.screenshot(path="screenshot.png", full_page=True)

# Element screenshot
element = await page.query_selector("#my-element")
await element.screenshot(path="element.png")
```

## Browser Context vs Regular Sessions

| Feature | Regular Browser Session | Browser Context Session |
|---------|------------------------|-------------------------|
| Cookie Persistence | No, cookies lost after session ends | Yes, cookies persist across sessions |
| Setup Complexity | Simple | Requires context creation |
| Use Case | One-time automation | Multi-session workflows |
| Data Synchronization | None | Automatic with `auto_upload=True` |

## API Methods Used

| Method | Purpose |
|--------|---------|
| `session.browser.initialize_async()` | Initialize browser with options |
| `session.browser.get_endpoint_url()` | Get CDP endpoint for Playwright |
| `session.browser.agent.act_async()` | AI-powered browser automation |
| `session.browser.close()` | Close browser connection |

## Related Documentation

- [Browser Use Guide](../../../../docs/guides/browser-use/README.md)
- [Core Features](../../../../docs/guides/browser-use/core-features.md)
- [Advanced Features](../../../../docs/guides/browser-use/advance-features.md)
- [Browser Extensions](../../../../docs/guides/browser-use/browser-extensions.md)
- [Browser Replay](../../../../docs/guides/browser-use/browser-replay.md)

## Troubleshooting

### Browser Initialization Failed

If browser fails to initialize:
- Check session is created successfully
- Verify image_id is `browser_latest`
- Wait a few seconds after session creation

### Playwright Connection Issues

If Playwright can't connect:
- Verify endpoint URL is correct
- Check network connectivity
- Ensure Playwright is installed: `playwright install chromium`

### Cookie Persistence Not Working

Ensure you're using Browser Context:
- Create context with `agent_bay.context.get()`
- Use `BrowserContext` in session params
- Delete session with `sync_context=True`

### Detection by Websites

If websites detect automation:
- Enable stealth mode: `use_stealth=True`
- Randomize fingerprints
- Add delays between actions
- Use residential proxies





# Python Browser Examples

This directory contains Python examples demonstrating browser automation capabilities of the AgentBay SDK.

## Prerequisites

1. **Install Python SDK**:
   ```bash
   pip install wuying-agentbay-sdk
   ```

2. **Install Playwright**:
   ```bash
   pip install playwright
   playwright install chromium
   ```

3. **Set API Key**:
   ```bash
   export AGENTBAY_API_KEY=your_api_key_here
   ```

## Examples

### 1. browser_context_cookie_persistence.py
Demonstrates how to use Browser Context to persist cookies across multiple sessions. This example shows:
- Creating sessions with Browser Context
- Setting cookies manually using Playwright
- Deleting sessions with context synchronization (`sync_context=True`)
- Verifying cookie persistence in new sessions
- Complete cleanup of resources

**Key features demonstrated:**
- Browser Context configuration with `auto_upload=True`
- Manual cookie setting and verification
- Cross-session cookie persistence
- Proper resource cleanup

### 2. search_agentbay_doc.py
Demonstrates basic browser automation using direct Playwright interactions:
- Connecting to AgentBay browser via CDP
- Manual element selection and interaction
- Search operations on websites

### 3. search_agentbay_doc_by_agent.py
Shows how to use the Agent module for intelligent browser automation:
- Using natural language commands with `session.browser.agent.act_async()`
- AI-powered element detection and interaction
- Simplified automation for complex web interactions

### 4. visit_aliyun.py
Basic browser usage example showing:
- Browser initialization
- Simple page navigation
- Basic browser operations

### 5. browser_type_example.py

Comprehensive example demonstrating browser type selection:
- Chrome browser initialization
- Chromium browser initialization
- Default browser (None) usage
- Browser configuration verification
- Side-by-side comparison of browser types

**Run:**
```bash
# Run full example (tests all browser types)
python browser_type_example.py

# Run quick example (Chrome only)
python browser_type_example.py --quick
```

**Key features demonstrated:**
- Browser type selection for Chrome, Chromium, and default
- Configuration validation
- Browser detection and verification
- Command-line options for different test modes

### 6. run_2048.py & run_sudoku.py
Game automation examples demonstrating:
- Complex interaction patterns
- Agent-based automation for games
- Advanced browser control

## Browser Type Selection

When using computer use images, you can choose between Chrome and Chromium:

```python
from agentbay.browser.browser import BrowserOption

# Use Chrome (Google Chrome)
option = BrowserOption(browser_type="chrome")
await session.browser.initialize_async(option)

# Use Chromium (open-source)
option = BrowserOption(browser_type="chromium")
await session.browser.initialize_async(option)

# Use default (None - let browser image decide)
option = BrowserOption()
await session.browser.initialize_async(option)
```

## Running the Examples

1. Install required dependencies:
```bash
pip install wuying-agentbay-sdk playwright
playwright install chromium
```

2. Set your API key:
```bash
export AGENTBAY_API_KEY=your_api_key_here
```

3. Run any example:
```bash
python browser_context_cookie_persistence.py
python search_agentbay_doc.py
# ... etc
```

## Common Patterns

### Basic Browser Initialization

```python
import asyncio
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams
from agentbay.browser.browser import BrowserOption

async def main():
    api_key = os.getenv("AGENTBAY_API_KEY")
    agent_bay = AgentBay(api_key=api_key)
    
    params = CreateSessionParams(image_id="browser_latest")
    result = agent_bay.create(params)
    
    if not result.success:
        raise RuntimeError(f"Failed to create session: {result.error_message}")
    
    session = result.session
    option = BrowserOption()
    success = await session.browser.initialize_async(option)
    
    if not success:
        raise RuntimeError("Browser initialization failed")

asyncio.run(main())
```

### Connecting Playwright

```python
from playwright.async_api import async_playwright

endpoint_url = session.browser.get_endpoint_url()

async with async_playwright() as p:
    browser = await p.chromium.connect_over_cdp(endpoint_url)
    context = browser.contexts[0]
    page = await context.new_page()
    
    # Use page...
    
    await browser.close()

session.delete()
```

### Error Handling

```python
try:
    success = await session.browser.initialize_async(option)
    if not success:
        raise RuntimeError("Initialization failed")
    
    # Use browser...
    
except Exception as e:
    print(f"Error: {e}")
finally:
    session.delete()
```

### Custom Configuration

```python
from agentbay.browser.browser import (
    BrowserOption,
    BrowserViewport,
    BrowserFingerprint
)

option = BrowserOption(
    browser_type="chrome",
    use_stealth=True,
    viewport=BrowserViewport(1920, 1080),
    fingerprint=BrowserFingerprint(
        devices=["desktop"],
        operating_systems=["windows", "macos"],
        locales=["en-US"]
    )
)
```

## Browser Context vs Regular Browser Sessions

| Feature | Regular Browser Session | Browser Context Session |
|---------|------------------------|-------------------------|
| Cookie Persistence | No, cookies lost after session ends | Yes, cookies persist across sessions |
| Setup Complexity | Simple | Requires context creation |
| Use Case | One-time automation | Multi-session workflows |
| Data Synchronization | None | Automatic with `auto_upload=True` |

## Best Practices

1. **Always use context synchronization**: When deleting sessions with important browser data, use `sync_context=True`
2. **Proper cleanup**: Always delete sessions and contexts when done
3. **Error handling**: Implement proper error handling for network and browser operations
4. **Resource management**: Close browser connections properly
5. **Unique context names**: Use unique context names to avoid conflicts

## Related Documentation

- [Browser Extension Examples](../extension/README.md) - Dedicated extension management examples
- [Browser Use Guide](../../../../../docs/guides/browser-use/README.md) - Main browser use guide
- [Browser Context Tutorial](../../../../../docs/guides/browser-use/core-features/browser-context.md) - Browser context management
- [Context Management API](../../../api/common-features/basics/context.md) - Context API reference
- [Browser API Reference](../../../api/browser-use/browser.md) - Browser API reference 



# Extension Examples

This directory contains Python examples demonstrating browser extension management capabilities of the AgentBay SDK.

## Examples

### 1. basic_extension_usage.py
Demonstrates fundamental extension management and browser session creation:
- Uploading browser extensions to the cloud
- Creating browser sessions with extensions
- Extension synchronization and file access
- Multiple extension handling
- Proper resource cleanup

**Key features demonstrated:**
- ExtensionsService initialization and context management
- Extension upload and validation
- ExtensionOption creation for browser sessions
- Extension file access in sessions at `/tmp/extensions/`

### 2. extension_development_workflow.py
Shows a complete development workflow for browser extensions:
- Extension upload for development testing
- Test session creation with extensions
- Extension updates during development
- Iterative development cycle management
- Development resource cleanup

**Key features demonstrated:**
- ExtensionDevelopmentWorkflow class usage
- Extension versioning and updates
- Development session management
- Extension testing patterns

### 3. extension_testing_automation.py
Advanced example for automated extension testing:
- Automated test suite execution
- Multi-extension testing scenarios
- Test result reporting and analysis
- CI/CD integration patterns
- Comprehensive error handling

**Key features demonstrated:**
- ExtensionTestRunner class for automation
- Test suite configuration and execution
- Automated test reporting
- CI/CD compatible testing workflows

## Running the Examples

1. Install required dependencies:
```bash
pip install wuying-agentbay-sdk
```

2. Set your API key:
```bash
export AGENTBAY_API_KEY=your_api_key_here
```

3. Update extension paths in the examples with your actual extension ZIP files.

4. Run any example:
```bash
python basic_extension_usage.py
python extension_development_workflow.py
python extension_testing_automation.py
```

## Extension Requirements

- Extensions must be packaged as ZIP files
- Extensions must include a valid `manifest.json` file
- Extensions are synchronized to `/tmp/extensions/{extension_id}/` in browser sessions

## Usage Patterns

### Basic Extension Management
```python
from agentbay import AgentBay
from agentbay.extension import ExtensionsService

agent_bay = AgentBay(api_key="your_api_key")
extensions_service = ExtensionsService(agent_bay)

# Upload extension
extension = extensions_service.create("/path/to/extension.zip")

# Create browser session with extension
ext_option = extensions_service.create_extension_option([extension.id])
# ... use with BrowserContext
```

### Development Workflow
```python
from extension_development_workflow import ExtensionDevelopmentWorkflow

workflow = ExtensionDevelopmentWorkflow("your_api_key", "my_project")
workflow.upload_extension("/path/to/extension-v1.zip")
session = workflow.create_test_session()
# Test extension...
workflow.update_extension("/path/to/extension-v2.zip")
# Test updated version...
```

### Automated Testing
```python
from extension_testing_automation import ExtensionTestRunner, TestSuite

test_runner = ExtensionTestRunner("your_api_key")
test_suite = TestSuite(
    name="my_tests",
    extension_paths=["/path/to/test-extension.zip"],
    test_cases=["extension_loaded", "manifest_valid"]
)
results = test_runner.run_test_suite(test_suite)
```

## Best Practices

1. **Context Management**:
   - Use descriptive context names for different projects
   - Always call `cleanup()` when done
   - Let the service auto-generate contexts for simple use cases

2. **File Management**:
   - Use ZIP format for all extension packages
   - Validate file existence before upload
   - Include proper manifest.json in extensions

3. **Session Management**:
   - Use meaningful labels for sessions
   - Wait for extension synchronization before testing
   - Create one ExtensionOption per session

4. **Error Handling**:
   - Implement comprehensive error handling
   - Use try-finally blocks for cleanup
   - Validate extension configurations

## Extension File Structure

Extensions are synchronized to browser sessions at:
```
/tmp/extensions/
├── {extension_id_1}/
│   ├── manifest.json
│   ├── content.js
│   └── ... (other extension files)
├── {extension_id_2}/
│   ├── manifest.json
│   └── ... (other extension files)
└── ...
```

## Related Documentation

- [Extension API Reference](../../../../../typescript/docs/api/browser-use/extension.md) - Complete API documentation
- [Browser Extensions Guide](../../../../../docs/guides/browser-use/browser-extensions.md) - Tutorial and best practices
- [Browser Examples](../browser/README.md) - Additional browser automation examples

## Troubleshooting

**Extension not found in session:**
- Check that extension was uploaded successfully
- Verify session was created with proper ExtensionOption
- Wait for synchronization to complete before accessing files

**Upload failures:**
- Ensure file is in ZIP format
- Check file permissions and accessibility
- Verify API key and network connectivity

**Context errors:**
- Use unique context names to avoid conflicts
- Don't mix extensions from different sources
- Clean up contexts when no longer needed



# CodeSpace Examples

This directory contains examples demonstrating code execution capabilities in AgentBay SDK.

## Overview

CodeSpace environment (`code_latest` image) provides a cloud-based development environment where you can:
- Execute Python and JavaScript code
- Perform file operations
- Run shell commands
- Manage packages (pip, npm)

## Examples

### code_execution_example.py

Comprehensive example demonstrating:
- **Python Code Execution**: Run Python scripts with full standard library access
- **JavaScript Code Execution**: Execute Node.js code with npm packages
- **File Operations**: Read, write, and manage files in the code environment
- **Command Execution**: Run shell commands for system operations

## Prerequisites

- Python 3.8 or later
- Valid `AGENTBAY_API_KEY` environment variable
- AgentBay SDK installed

## Installation

```bash
pip install wuying-agentbay-sdk
```

## Usage

```bash
# Set your API key
export AGENTBAY_API_KEY=your_api_key_here

# Run the example
python code_execution_example.py
```

## Features Demonstrated

### Python Code Execution

```python
python_code = """
import sys
print(f"Python version: {sys.version}")
"""

result = session.code.run_code(python_code, "python")
if result.success:
    print(result.result)
```

### JavaScript Code Execution

```python
js_code = """
const os = require('os');
console.log(`Platform: ${os.platform()}`);
"""

result = session.code.run_code(js_code, "javascript")
if result.success:
    print(result.result)
```

### File Operations

```python
# Write file
session.file_system.write_file("/tmp/test.txt", "Hello World")

# Read file
result = session.file_system.read_file("/tmp/test.txt")
print(result.content)
```

### Command Execution

```python
# Execute shell command
result = session.command.execute_command("python --version")
if result.success:
    print(result.output)
```

## Use Cases

1. **Automated Testing**: Run test suites in isolated environments
2. **Code Validation**: Validate code snippets before deployment
3. **Data Processing**: Execute data transformation scripts
4. **CI/CD Integration**: Integrate with continuous integration pipelines
5. **Educational Tools**: Provide safe code execution environments for learning

## API Methods Used

| Method | Purpose |
|--------|---------|
| `session.code.run_code()` | Execute Python or JavaScript code |
| `session.file_system.write_file()` | Write content to a file |
| `session.file_system.read_file()` | Read content from a file |
| `session.command.execute_command()` | Execute shell commands |

## Best Practices

1. **Error Handling**: Always check `result.success` before using output
2. **Resource Cleanup**: Delete sessions when done to free resources
3. **Timeout Management**: Set appropriate timeouts for long-running code
4. **Security**: Never execute untrusted code without proper validation
5. **Package Management**: Install required packages before code execution

## Related Documentation

- [Code Execution Guide](../../../../docs/guides/codespace/code-execution.md)
- [Session Management](../../../../docs/guides/common-features/basics/session-management.md)
- [File Operations](../../../../docs/guides/common-features/basics/file-operations.md)

## Troubleshooting

### Code Execution Timeout

If your code takes too long to execute, consider:
- Breaking it into smaller chunks
- Increasing timeout settings
- Using asynchronous execution patterns

### Package Not Found

If you need additional packages:
```python
# Install Python package
session.command.execute_command("pip install package-name")

# Install Node.js package
session.command.execute_command("npm install package-name")
```

### Permission Denied

Ensure you're writing to accessible directories like `/tmp` or user home directory.





# Common Features Examples

This directory contains examples demonstrating features available across all AgentBay environment types (browser, computer, mobile, and codespace).

## Directory Structure

```
common-features/
├── basics/          # Fundamental features for all users
└── advanced/        # Advanced features and integrations
```

## Basics

Essential features that every AgentBay user should know:

### [session_creation](basics/session_creation/)
Session lifecycle management examples:
- Creating sessions with default parameters
- Session creation with labels
- Session creation with context synchronization
- Browser context for cookie persistence
- Mobile configuration with app management

### [file_system](basics/file_system/)
File operations in cloud environments:
- Reading and writing files
- Directory operations
- File information retrieval
- File editing and moving
- File searching
- Large file operations with chunking

### [filesystem_example](basics/filesystem_example/)
Practical filesystem use cases:
- **file_transfer_example.py**: File transfer between local and cloud
- **watch_directory_example.py**: Directory monitoring and change detection

### [context_management](basics/context_management/)
Context creation and management:
- Creating and managing contexts
- Data storage and retrieval
- Cross-session data sharing

### [data_persistence](basics/data_persistence/)
Data persistence across sessions:
- Storing data across sessions
- Data retrieval patterns
- Context synchronization demonstration
- Recycle policy configuration

### [label_management](basics/label_management/)
Session organization with labels:
- Adding labels to sessions
- Filtering and searching sessions
- Label-based session management

### [list_sessions](basics/list_sessions/)
Session listing and filtering:
- Listing all sessions
- Filtering by labels
- Session status monitoring

### [get](basics/get/)
Session retrieval:
- Getting session by ID
- Session information retrieval

## Advanced

Advanced features for power users and integrations:

### [agent_module](advanced/agent_module/)
AI-powered automation:
- Using Agent for task execution
- Natural language task descriptions
- Intelligent automation workflows

### [oss_management](advanced/oss_management/)
Object Storage Service integration:
- OSS environment initialization
- File upload to OSS
- File download from OSS
- Anonymous upload/download

### [vpc_session](advanced/vpc_session/)
Secure isolated network environments:
- Creating VPC sessions
- VPC network configuration
- Secure session management

### [screenshot_download](advanced/screenshot_download/)
Screenshot capture and download:
- Taking screenshots
- Downloading screenshots locally
- Image format handling

## Prerequisites

- Python 3.8 or later
- AgentBay SDK installed: `pip install wuying-agentbay-sdk`
- Valid `AGENTBAY_API_KEY` environment variable

## Quick Start

```bash
# Set your API key
export AGENTBAY_API_KEY=your_api_key_here

# Run any example
cd basics/session_creation
python main.py

cd ../file_system
python main.py
```

## Common Patterns

### Basic Session Creation

```python
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams

agent_bay = AgentBay(api_key="your_api_key")
params = CreateSessionParams(image_id="linux_latest")
result = agent_bay.create(params)

if result.success:
    session = result.session
    # Use session...
    agent_bay.delete(session)
```

### File Operations

```python
# Write file
result = session.file_system.write_file("/tmp/test.txt", "content")

# Read file
result = session.file_system.read_file("/tmp/test.txt")
if result.success:
    print(result.content)
```

### Command Execution

```python
result = session.command.execute_command("ls -la")
if result.success:
    print(result.output)
```

### Context Management

```python
# Get or create context
context_result = agent_bay.context.get("my-context", create=True)

# Use context with session
from agentbay.context_sync import ContextSync, SyncPolicy

context_sync = ContextSync.new(
    context_id=context_result.context.id,
    path="/tmp/data",
    policy=SyncPolicy.default()
)
params = CreateSessionParams(context_syncs=[context_sync])
```

## Best Practices

1. **Always Clean Up**: Delete sessions when done to free resources
2. **Error Handling**: Check `result.success` before using data
3. **Use Labels**: Organize sessions with meaningful labels
4. **Context Sync**: Use context synchronization for data persistence
5. **Resource Limits**: Be aware of concurrent session limits

## Related Documentation

- [Session Management Guide](../../../../docs/guides/common-features/basics/session-management.md)
- [File Operations Guide](../../../../docs/guides/common-features/basics/file-operations.md)
- [Data Persistence Guide](../../../../docs/guides/common-features/basics/data-persistence.md)
- [Agent Modules Guide](../../../../docs/guides/common-features/advanced/agent-modules.md)

## Troubleshooting

### Resource Creation Delay

If you see "The system is creating resources" message:
- Wait 90 seconds and retry
- This is normal for resource initialization
- Consider using session pooling for production

### API Key Issues

Ensure your API key is properly set:
```bash
export AGENTBAY_API_KEY=your_api_key_here
# Verify
echo $AGENTBAY_API_KEY
```

### Context Synchronization Timeout

For large contexts:
- Increase timeout settings
- Use selective synchronization
- Consider splitting into smaller contexts





# Agent Module Example

This example demonstrates how to use the Agent module to execute AI-powered tasks using natural language descriptions.

## Overview

The Agent module allows you to execute complex tasks using human-readable instructions, monitor task status, and terminate running tasks. This capability extends the functionality of cloud sessions by adding AI-powered automation.

## Running the Example

1. Ensure you have the AgentBay SDK installed
2. Set the `AGENTBAY_API_KEY` environment variable with your valid API key
3. Run the example:

```bash
cd docs/examples/python/agent_module
python main.py
```

## What the Example Does

1. Initializes the AgentBay client with your API key
2. Creates a new session
3. Executes a simple task using the Agent module ("Create a word document, input some words and save the document.")
4. Displays the task results
5. Cleans up by deleting the session

## Key Concepts

- **Session Creation**: All Agent operations happen within a session context
- **Task Execution**: Tasks are executed using natural language descriptions
- **Result Handling**: Task results include success status, output, and error information
- **Resource Management**: Sessions should be properly deleted when no longer needed

## Next Steps

Try modifying the task description to perform different operations, such as:
- "Find out the current weather in New York City by Google/Baidu"
- "Copy all the text files from folder A to folder B"
- "Navigate to bilibili.com and search for 'Wuying AgentBay ' and play the first video."



# OSS Management Example

This example demonstrates how to use the Object Storage Service (OSS) features of the AgentBay SDK for Python.

## Features Demonstrated

- Initializing OSS credentials in a session
- Uploading files to OSS buckets
- Downloading files from OSS buckets
- Anonymous uploads to OSS using URLs
- Anonymous downloads from OSS using URLs
- Handling OSS operations in a session environment

## Running the Example

1. Make sure you have installed the AgentBay SDK:

```bash
pip install wuying-agentbay-sdk
```

2. Set your API key as an environment variable (recommended):

```bash
export AGENTBAY_API_KEY=your_api_key_here
```

3. Optionally, set OSS credentials as environment variables:

```bash
export OSS_ACCESS_KEY_ID=your_access_key_id
export OSS_ACCESS_KEY_SECRET=your_access_key_secret
export OSS_SECURITY_TOKEN=your_security_token
export OSS_ENDPOINT=https://oss-cn-hangzhou.aliyuncs.com
export OSS_REGION=cn-hangzhou
export OSS_TEST_BUCKET=your_test_bucket
```

4. Run the example:

```bash
python main.py
```

## Code Explanation

The example demonstrates OSS integration with AgentBay:

1. Create a new session
2. Initialize OSS environment with credentials
3. Create a test file in the session
4. Upload the file to an OSS bucket
5. Upload a file anonymously using a URL
6. Download a file from an OSS bucket
7. Download a file anonymously using a URL
8. Clean up by deleting the session

OSS integration allows you to:

- Transfer files between your local environment and the cloud session
- Store session artifacts in permanent storage
- Share files across multiple sessions
- Download resources from external sources
- Implement file backup and restore functionality

For more details on OSS integration, see the [OSS API Reference](../../../../../../typescript/docs/api/common-features/advanced/oss.md).



# VPC Session Example

This example demonstrates how to create and use VPC (Virtual Private Cloud) sessions with the AgentBay SDK.

## Overview

VPC sessions provide enhanced security and networking capabilities by running your cloud sessions within a private network environment. This example shows how to create a VPC session and use its available modules.

## Running the Example

1. Ensure you have the AgentBay SDK installed
2. Set the `AGENTBAY_API_KEY` environment variable with your valid API key
3. Run the example:

```bash
cd docs/examples/python/vpc_session
python main.py
```

## What the Example Does

1. Initializes the AgentBay client with your API key
2. Creates a new VPC session with specific parameters
3. Tests FileSystem operations by writing and reading a file
4. Tests Command operations by executing system commands
5. Cleans up by deleting the session

## Key Concepts

- **VPC Session Creation**: VPC sessions are created by setting the `is_vpc` parameter to `True`
- **Module Availability**: VPC sessions have limited module availability compared to standard sessions
- **Resource Management**: VPC sessions should be properly deleted when no longer needed
- **Security**: VPC sessions provide network isolation for sensitive operations

## Available Modules in VPC Sessions

1. **FileSystem**: File and directory operations
2. **Command**: Command execution
3. **System Tools**: Specialized system-level tools
4. **Browser Tools**: Browser automation capabilities

## Next Steps

Try modifying the example to:
- Use context synchronization with VPC sessions
- Test different command executions
- Implement error handling for unavailable modules



# Context Management Example

This example demonstrates how to use the Context Management features of the AgentBay SDK for Python.

## Features Demonstrated

- Listing all contexts
- Getting or creating a context (by name or context ID)
- Creating a session with a context
- Updating a context
- Clearing context data (removing persistent data)
- Deleting a context

## Running the Example

1. Make sure you have installed the AgentBay SDK:

```bash
pip install wuying-agentbay-sdk
```

2. Set your API key as an environment variable (recommended):

```bash
export AGENTBAY_API_KEY=your_api_key_here
```

3. Run the example:

```bash
python main.py
```

## Code Explanation

The example demonstrates a full lifecycle of context management:

1. Initialize the AgentBay client with an API key
2. List all existing contexts to see what's available
3. Get an existing context by name or context ID, or create it if it doesn't exist
4. Create a session using the context
5. Update the context's properties
6. Clear context data (remove persistent data while keeping the context)
7. Clean up by deleting the session and context

For more details on context management, see the [Context API Reference](../../../../../../typescript/docs/api/common-features/basics/context.md) and [Data Persistence Tutorial](../../../../../../docs/guides/common-features/basics/data-persistence.md).



# Data Persistence Examples

This directory contains examples demonstrating data persistence functionality in AgentBay SDK.

## Examples

### 1. `main.py` - Basic Data Persistence

Demonstrates the fundamental data persistence features:

- Context creation for persistent storage
- File persistence across multiple sessions
- Context synchronization and file sharing
- Multi-session data verification

### 2. `context_sync_demo.py` - Advanced Sync with Callbacks

Demonstrates the new callback-based context synchronization:

- Async context sync with callback functions
- Timing analysis and performance monitoring
- Status verification using `context.info()`
- Multiple sync operations and error handling
- Backward compatibility with traditional sync

### 3. `recycle_policy_example.py` - Data Lifecycle Management

Demonstrates RecyclePolicy for controlling context data lifecycle:

- Using default RecyclePolicy (keeps data forever)
- Setting custom lifecycle durations (1 day, 3 days, etc.)
- Applying RecyclePolicy to specific paths
- Available lifecycle options
- Error handling (wildcard patterns validation)

## Key Features

### Data Persistence

- **Context Creation**: Create persistent storage contexts
- **Cross-Session Persistence**: Data survives session deletion
- **File Synchronization**: Automatic sync of files to persistent storage
- **Multi-Session Access**: Access data from different sessions

### Context Sync Callbacks

- **Async Operations**: Non-blocking sync operations
- **Real-time Feedback**: Immediate notification on completion
- **Timing Information**: Detailed performance metrics
- **Error Handling**: Graceful handling of failures and timeouts
- **Status Monitoring**: Track sync progress and completion

### Data Lifecycle Management

- **RecyclePolicy**: Control how long context data is retained in the cloud
- **Lifecycle Options**: 1 day to forever (11 options available)
- **Path-Specific Policies**: Apply different lifecycles to different directories
- **Automatic Cleanup**: Data is automatically deleted after specified duration
- **Wildcard Validation**: Ensures path safety by rejecting wildcard patterns

## Usage

### Basic Data Persistence

```bash
cd python/docs/examples/data_persistence
python main.py
```

### Context Sync Callbacks

```bash
cd python/docs/examples/data_persistence
python context_sync_demo.py
```

### RecyclePolicy Example

```bash
cd python/docs/examples/data_persistence
python recycle_policy_example.py
```

## Prerequisites

- AgentBay SDK installed
- Valid API key configured (via environment variable `AGENTBAY_API_KEY` or default configuration)
- Network access to AgentBay services

## Expected Behavior

Both examples will:

1. Create a persistent context
2. Create a session with context synchronization
3. Write test data to the persistent storage
4. Demonstrate data persistence across sessions
5. Clean up resources

The callback example additionally shows:

- Async sync operations with timing
- Callback notifications
- Status monitoring
- Error handling scenarios

## Output

Both examples provide detailed console output showing:

- Step-by-step progress
- Success/failure status for each operation
- Timing information (callback example)
- Data verification results
- Cleanup confirmation

## Notes

- Examples use temporary contexts that are cleaned up after execution
- File paths use `/tmp/` for demonstration purposes
- Timing may vary based on network conditions and file sizes
- The callback example includes timeout handling for robustness




# Context Sync Anonymous Callback Example

This example demonstrates the `context.sync()` method with anonymous callback functionality, showing how to use the new asynchronous sync capabilities in AgentBay SDK.

## Overview

The example showcases:

- **Anonymous Callback Functions**: Using lambda functions for callback implementation
- **Async Context Sync**: Using `context.sync()` with callback functions
- **Timing Analysis**: Measuring sync operation duration
- **Session Deletion in Callback**: Deleting session within callback without sync_context
- **Error Handling**: Managing sync failures and timeouts

## Key Features Demonstrated

### 1. Dual-Mode Sync Function

The `context.sync()` function now supports both async and sync calling patterns:

```python
# Pattern 1: Async call - wait for completion
result = await session.context.sync()
if result.success:
    print("✅ Async sync completed successfully")

# Pattern 2: Sync call with callback - immediate return
session.context.sync(callback=lambda success: (
    print(f"✅ Anonymous sync callback: {'SUCCESS' if success else 'FAILED'}") or
    print("🧹 Deleting session after sync completion...") or
    agent_bay.delete(session) or
    print("✅ Session deleted successfully")
))
```

### 2. Timing Analysis

The example includes detailed timing analysis for different file sizes:

- **Small files** (< 1KB): Typically 2-5 seconds
- **Medium files** (1-10KB): Typically 5-15 seconds
- **Large files** (> 10KB): Typically 15-60 seconds

### 3. Session Deletion in Callback

Demonstrates deleting the session within the callback function without sync_context:

```python
# Session deletion happens automatically in the callback
agent_bay.delete(session, sync_context=False)
```

### 4. Automatic Handling

The callback handles everything automatically without needing to wait:

```python
# Callback handles success, failure, and cleanup automatically
# No need for manual waiting or timeout handling
```

## Example Structure

### Step 1: Context Creation

- Creates a persistent context for data storage
- Configures sync policy and context sync settings

### Step 2: Session Setup

- Creates session with context synchronization
- Mounts context to `/tmp/sync_data` path

### Step 3: Test Data Creation

- Creates multiple test files of different sizes
- Sets up directory structure for organized testing

### Step 4: Anonymous Callback Sync Demonstration

- Shows async sync with anonymous callback functionality
- Demonstrates timing measurement and status monitoring
- Includes session deletion within callback (no sync_context)
- Automatic handling without manual waiting




# FileSystem Operations Example

This example demonstrates how to use the FileSystem features of the Wuying AgentBay SDK. It covers a comprehensive set of file system operations, including:

- Basic file reading and writing
- Directory creation and listing
- File information retrieval
- File editing and moving
- File searching
- Multiple file reading
- Large file operations with automatic chunking

This example is particularly useful for understanding how to work with files and directories efficiently in the AgentBay cloud environment.

## Features Demonstrated

### Basic File Operations
- **File Writing**: Create new files with content
- **File Reading**: Read file contents
- **File Appending**: Add content to existing files

### Directory Operations
- **Directory Creation**: Create new directories
- **Directory Listing**: List contents of directories

### File Information
- **File Info Retrieval**: Get detailed information about files (size, permissions, etc.)

### File Manipulation
- **File Editing**: Edit specific parts of file content
- **File Moving**: Move files between directories

### Search Operations
- **File Searching**: Search for files containing specific patterns

### Multiple File Operations
- **Multiple File Reading**: Read multiple files in a single operation

### Large File Operations
- **Large File Writing**: Write files larger than the default API size limits using automatic chunking
- **Large File Reading**: Read large files using automatic chunking
- **Custom Chunk Size**: Specify custom chunk sizes for both reading and writing operations
- **Performance Measurement**: Measure and compare operation times with different chunk sizes

## Prerequisites

- Python 3.10 or later
- Wuying AgentBay SDK installed:
  ```bash
  pip install wuying-agentbay-sdk
  ```

## Running the Example

```bash
cd file_system
python main.py
```

Make sure you have set the `AGENTBAY_API_KEY` environment variable or replace the placeholder in the code with your actual API key.

## How It Works

The example demonstrates the following workflow:

1. **Session Creation**: Creates a new session with the specified image ID
2. **Basic File Operations**: Demonstrates writing, reading, and appending to files
3. **Directory Operations**: Shows how to create directories and list their contents
4. **File Information**: Retrieves and displays detailed file information
5. **File Editing**: Demonstrates how to edit specific parts of a file
6. **File Moving**: Shows how to move files between directories
7. **File Searching**: Searches for files containing specific patterns
8. **Multiple File Reading**: Reads multiple files in a single operation
9. **Large File Operations**: Demonstrates reading and writing large files with both default and custom chunk sizes
10. **Content Verification**: Verifies that file operations maintain content integrity
11. **Performance Comparison**: Measures and reports the time taken for large file operations

Each section of the example is clearly marked and includes verification steps to ensure operations are working correctly.

## API Reference

For more detailed information on the FileSystem API methods, refer to the SDK documentation.



# FileSystem Examples

This directory contains examples demonstrating the FileSystem functionality in the AgentBay SDK for Python.

## Examples

### Watch Directory Example ([watch_directory_example.py](./watch_directory_example.py))

Demonstrates how to monitor file changes in a directory:

- Creating directories for monitoring
- Setting up file change monitoring with callbacks
- Performing file operations to trigger events
- Processing different types of file events (create, modify, delete)
- Proper resource cleanup

### File Transfer Example ([file_transfer_example.py](./file_transfer_example.py))

Demonstrates file upload and download operations:

- Creating contexts and sessions with file transfer capabilities
- Using the simplified FileSystem API for file transfers
- Uploading files from local storage to the cloud
- Downloading files from the cloud to local storage
- Tracking file transfer progress with callbacks
- Verifying file content integrity after transfers
- Proper resource cleanup

## Running the Examples

1. Make sure you have installed the AgentBay SDK:

```bash
pip install wuying-agentbay-sdk
```

2. Set your API key as an environment variable (recommended):

```bash
export AGENTBAY_API_KEY=your_api_key_here
```

3. Run an example:

```bash
python watch_directory_example.py
```

or

```bash
python file_transfer_example.py
```

## Code Explanation

### Watch Directory Example

The watch directory example demonstrates real-time file monitoring capabilities:

1. Initialize the AgentBay client with an API key
2. Create a session with a suitable image
3. Create a test directory to monitor
4. Set up monitoring with a callback function to handle file events
5. Perform various file operations to trigger events
6. Process and display the detected file changes
7. Clean up resources properly

### File Transfer Example

The file transfer example demonstrates uploading and downloading files:

1. Initialize the AgentBay client with an API key
2. Create a context for file operations
3. Create a browser session with context synchronization
4. Create test files for upload
5. Upload files to the cloud using the simplified API
6. Download files from the cloud to local storage
7. Track progress during transfers
8. Verify file content integrity
9. Clean up resources properly

## API Reference

For detailed information about the FileSystem API, see the [FileSystem API Reference](../../../../../../typescript/docs/api/common-features/basics/filesystem.md).




# Get API Example

This example demonstrates how to use the `get` API to retrieve a session by its ID.

## Description

The `get` API allows you to retrieve a session object by providing its session ID. This is useful when you have a session ID from a previous operation and want to access or manage that session.

## Prerequisites

- Python 3.8 or higher
- Valid API key set in `AGENTBAY_API_KEY` environment variable
- agentbay package installed

## Installation

```bash
pip install agentbay
```

## Usage

```bash
# Set your API key
export AGENTBAY_API_KEY="your-api-key-here"

# Run the example
python main.py
```

## Code Example

```python
import os
from agentbay import AgentBay

# Initialize AgentBay client
api_key = os.getenv("AGENTBAY_API_KEY")
agentbay = AgentBay(api_key=api_key)

# Retrieve a session by ID
session_id = "your-session-id"
result = agentbay.get(session_id)

if result.success:
    session = result.session
    print(f"Retrieved session: {session.session_id}")
    print(f"Request ID: {result.request_id}")
    # Use the session for further operations
    # ...
else:
    print(f"Failed to get session: {result.error_message}")
```

## API Reference

### get

```python
def get(session_id: str) -> SessionResult
```

Get a session by its ID.

**Parameters:**
- `session_id` (str): The ID of the session to retrieve

**Returns:**
- `SessionResult`: Result object containing:
  - `success` (bool): Whether the operation succeeded
  - `session` (Session): The Session instance if successful
  - `request_id` (str): The API request ID
  - `error_message` (str): Error message if failed

## Expected Output

```
Creating a session...
Created session with ID: session-xxxxxxxxxxxxx

Retrieving session using Get API...
Successfully retrieved session:
  Session ID: session-xxxxxxxxxxxxx
  Request ID: DAD825FE-2CD8-19C8-BB30-CC3BA26B9398

Session is ready for use

Cleaning up...
Session session-xxxxxxxxxxxxx deleted successfully
```

## Notes

- The session ID must be valid and from an existing session
- The get API internally calls the GetSession API endpoint
- The returned session object can be used for all session operations (commands, files, etc.)
- Always clean up sessions when done to avoid resource waste

## Error Handling

The `get` method returns a `SessionResult` object with error information:

1. **Empty session_id**: Result will have `success=False`
   ```python
   result = agentbay.get("")
   if not result.success:
       print(f"Error: {result.error_message}")  # "session_id is required"
   ```

2. **Non-existent session**: Result will have `success=False`
   ```python
   result = agentbay.get("non-existent-session-id")
   if not result.success:
       print(f"Error: {result.error_message}")  # "Failed to get session..."
   ```





# Label Management Example

This example demonstrates how to use the label management features of the AgentBay SDK for Python.

## Features Demonstrated

- Creating sessions with custom labels
- Getting labels from a session
- Updating labels for a session
- Listing all sessions
- Filtering sessions by labels
- Retrieving label information from filtered sessions

## Running the Example

1. Make sure you have installed the AgentBay SDK:

```bash
pip install wuying-agentbay-sdk
```

2. Set your API key as an environment variable (recommended):

```bash
export AGENTBAY_API_KEY=your_api_key_here
```

3. Run the example:

```bash
python main.py
```

## Code Explanation

The example demonstrates a full lifecycle of label management:

1. Create a session with initial labels
2. Retrieve the labels from the session
3. Create another session with different labels
4. Update the labels for the second session
5. Retrieve the updated labels
6. List all sessions
7. Filter sessions by label criteria
8. Clean up by deleting the sessions

Labels are useful for organizing and categorizing sessions, making it easier to find and manage them. You can use labels to:

- Group sessions by project
- Mark sessions with their purpose
- Tag sessions with version information
- Indicate session status
- Filter sessions based on any criteria

For more details on session management, see the [Session API Reference](../../../../../../typescript/docs/api/common-features/basics/session.md) and [Session Management Tutorial](../../../../../../docs/guides/common-features/basics/session-management.md). 



# List Sessions Example

This example demonstrates how to use the `list()` API to query and filter sessions in AgentBay.

## Overview

The `list()` API provides a simple and intuitive interface for querying sessions with optional filtering and pagination support. It's designed to be more user-friendly than the deprecated `list_by_labels()` API.

## Features Demonstrated

This example shows:

1. **List all sessions** - Query all sessions without any filters
2. **Filter by labels** - Query sessions that match specific labels
3. **Multiple label filtering** - Query sessions that match multiple label criteria
4. **Pagination** - Retrieve results page by page
5. **Iterate all pages** - Automatically fetch all results across multiple pages

## Prerequisites

Before running this example, ensure you have:

1. **AgentBay SDK installed**:
   ```bash
   pip install wuying-agentbay-sdk
   ```

2. **API Key configured**:
   ```bash
   export AGENTBAY_API_KEY='your-api-key-here'
   ```

## Running the Example

```bash
cd /path/to/wuying-agentbay-sdk/python/docs/examples/list_sessions
python main.py
```

## Code Walkthrough

### 1. List All Sessions

```python
from agentbay import AgentBay

agent_bay = AgentBay(api_key=api_key)

# List all sessions without any filter
result = agent_bay.list()

if result.success:
    print(f"Total sessions: {result.total_count}")
    print(f"Sessions on this page: {len(result.sessions)}")
    print(f"Request ID: {result.request_id}")
```

### 2. Filter by Single Label

```python
# Find all sessions with project='my-project'
result = agent_bay.list(labels={"project": "my-project"})

if result.success:
    for session in result.sessions:
        print(f"Session ID: {session.session_id}")
```

### 3. Filter by Multiple Labels

```python
# Find sessions that match ALL specified labels
result = agent_bay.list(
    labels={
        "project": "my-project",
        "environment": "production"
    }
)
```

### 4. Pagination

```python
# Get first page with 10 items per page
result = agent_bay.list(
    labels={"project": "my-project"},
    page=1,
    limit=10
)

# Get second page
if result.next_token:
    result_page2 = agent_bay.list(
        labels={"project": "my-project"},
        page=2,
        limit=10
    )
```

### 5. Iterate All Pages

```python
all_sessions = []
page = 1
limit = 10

while True:
    result = agent_bay.list(
        labels={"project": "my-project"},
        page=page,
        limit=limit
    )

    if not result.success:
        break

    all_sessions.extend(result.sessions)

    # Break if no more pages
    if not result.next_token:
        break

    page += 1

print(f"Total sessions: {len(all_sessions)}")
```

## API Reference

### Method Signature

```python
def list(
    labels: Optional[Dict[str, str]] = None,
    page: Optional[int] = None,
    limit: Optional[int] = None
) -> SessionListResult
```

### Parameters

- **labels** (Optional[Dict[str, str]]): Labels to filter sessions. All specified labels must match.
  - Default: `None` (no filtering, returns all sessions)
  - Example: `{"project": "demo", "environment": "prod"}`

- **page** (Optional[int]): Page number for pagination, starting from 1.
  - Default: `None` (returns first page)
  - Example: `2` (returns second page)

- **limit** (Optional[int]): Maximum number of items per page.
  - Default: `None` (uses default of 10)
  - Example: `20` (returns up to 20 items per page)

### Return Value

Returns a `SessionListResult` object with:

- **success** (bool): Whether the operation was successful
- **sessions** (List[Session]): List of Session objects matching the filter
- **total_count** (int): Total number of matching sessions
- **next_token** (str): Token for the next page (empty if no more pages)
- **max_results** (int): Maximum results per page
- **request_id** (str): Unique request identifier for tracking
- **error_message** (str): Error message if operation failed

## Use Cases

### 1. Session Inventory

List all sessions to get an overview of your current session inventory:

```python
result = agent_bay.list()
print(f"You have {result.total_count} active sessions")
```

### 2. Project Management

Find all sessions for a specific project:

```python
result = agent_bay.list(labels={"project": "website-automation"})
for session in result.sessions:
    print(f"Session: {session.session_id}")
```

### 3. Environment-Specific Queries

Query sessions by environment (dev, staging, prod):

```python
dev_sessions = agent_bay.list(labels={"environment": "dev"})
prod_sessions = agent_bay.list(labels={"environment": "prod"})

print(f"Dev sessions: {len(dev_sessions.sessions)}")
print(f"Prod sessions: {len(prod_sessions.sessions)}")
```

### 4. Bulk Operations

Retrieve all matching sessions and perform batch operations:

```python
# Get all sessions for a project
all_sessions = []
page = 1

while True:
    result = agent_bay.list(
        labels={"project": "old-project"},
        page=page,
        limit=50
    )

    if not result.success:
        break

    all_sessions.extend(result.sessions)

    if not result.next_token:
        break

    page += 1

# Perform bulk cleanup
for session in all_sessions:
    agent_bay.delete(session)
```

## Key Advantages over list_by_labels()

The new `list()` API offers several advantages:

1. **Simpler Interface**: No need to create `ListSessionParams` objects
2. **Intuitive Pagination**: Use familiar `page` and `limit` parameters
3. **Request Tracking**: All responses include `request_id` for debugging
4. **Cleaner Code**: More readable and maintainable code
5. **Type Safety**: Better IDE autocomplete support

## Comparison with Deprecated API

### Old way (list_by_labels):
```python
from agentbay.session_params import ListSessionParams

params = ListSessionParams(
    labels={"project": "demo"},
    max_results=10,
    next_token=""
)
result = agent_bay.list_by_labels(params)
```

### New way (list):
```python
result = agent_bay.list(
    labels={"project": "demo"},
    page=1,
    limit=10
)
```

## Expected Output

```
✅ AgentBay client initialized

📝 Creating test sessions...
✅ Created session 1: session-xxxxx
   Request ID: xxxxx-xxxxx-xxxxx
✅ Created session 2: session-yyyyy
   Request ID: yyyyy-yyyyy-yyyyy
✅ Created session 3: session-zzzzz
   Request ID: zzzzz-zzzzz-zzzzz

============================================================
Example 1: List all sessions (no filter)
============================================================
✅ Found 15 total sessions
📄 Showing 10 sessions on this page
🔑 Request ID: req-xxxxx-xxxxx
📊 Max results per page: 10
   1. Session ID: session-xxxxx
   2. Session ID: session-yyyyy
   3. Session ID: session-zzzzz

[... more examples ...]

============================================================
🧹 Cleaning up test sessions...
============================================================
✅ Deleted session: session-xxxxx
   Request ID: req-delete-xxxxx
✅ Deleted session: session-yyyyy
   Request ID: req-delete-yyyyy
✅ Deleted session: session-zzzzz
   Request ID: req-delete-zzzzz

✨ Demo completed successfully!
```

## Troubleshooting

### API Key Not Set
```
Error: AGENTBAY_API_KEY environment variable not set
```
**Solution**: Set your API key:
```bash
export AGENTBAY_API_KEY='your-api-key-here'
```

### No Sessions Found
```
Found 0 sessions with specified labels
```
**Solution**: Check that:
1. You have active sessions with the specified labels
2. Label keys and values match exactly (case-sensitive)
3. All specified labels must match (AND logic, not OR)

### Rate Limiting
If you encounter rate limiting, add delays between requests:
```python
import time
result = agent_bay.list(labels={"project": "demo"})
time.sleep(1)  # Wait 1 second between requests
```

## Related Documentation

- [Session Management Guide](../../../../../../docs/guides/common-features/basics/session-management.md)
- [AgentBay API Reference](../../../../../../typescript/docs/api/common-features/basics/agentbay.md)
- [Label Management Example](../label_management/README.md)

## Support

For issues or questions:
- GitHub Issues: https://github.com/aliyun/wuying-agentbay-sdk/issues
- Documentation: https://github.com/aliyun/wuying-agentbay-sdk





# Session Creation and Management Example

This example demonstrates comprehensive session creation and management using the Wuying AgentBay SDK. It covers various session types and configurations:

## Features Demonstrated

### 1. Basic Session Management
- Initializing the AgentBay client
- Creating a session with default parameters
- Listing all available sessions
- Deleting sessions
- Verifying session deletion

### 2. Session with Labels
- Creating sessions with custom labels for organization
- Retrieving and displaying session labels
- Using labels for project management and environment tracking

### 3. Context-Enabled Sessions
- Creating sessions with predefined contexts
- Context synchronization during session creation
- Managing persistent data across sessions

### 4. Context Synchronization
- Advanced context management with multiple contexts
- Listing and managing synchronized contexts
- Understanding context states and availability

### 5. Browser Context Sessions
- Creating sessions with browser-specific contexts
- Persistent browser data (cookies, localStorage, etc.)
- Context synchronization on session deletion

### 6. Mobile Configuration Sessions 
- Creating mobile sessions with app management rules
- Resolution Control: Locking screen resolution for consistent testing
- Package Management: Configuring allowed app packages
- Mobile-specific session parameters and cleanup


This example is useful for understanding the complete session lifecycle, advanced configuration options, and mobile-specific session management.

## Running the Example

```bash
cd session_creation
python main.py
```

Make sure you have set the `AGENTBAY_API_KEY` environment variable or replace the placeholder in the code with your actual API key.




# Computer Use Examples

This directory contains examples demonstrating Windows desktop automation capabilities in AgentBay SDK.

## Overview

Computer Use environment (`windows_latest` image) provides cloud-based Windows desktop automation with:
- Application management (start, stop, list)
- Window operations (maximize, minimize, resize, close)
- Focus management
- Desktop UI automation workflows
- Process monitoring

## Examples

### windows_app_management_example.py

Comprehensive Windows application management example demonstrating:

1. **Finding Installed Applications**
   - Discover all applications in Windows start menu
   - Filter system applications
   - Search for specific applications

2. **Launching Applications**
   - Start applications by command
   - Monitor spawned processes
   - Track process IDs

3. **Monitoring Running Applications**
   - List currently visible applications
   - Get application window information
   - Track application states

4. **Stopping Applications**
   - Stop by process ID (PID)
   - Stop by process name
   - Graceful termination

## Prerequisites

- Python 3.8 or later
- AgentBay SDK installed: `pip install wuying-agentbay-sdk`
- Valid `AGENTBAY_API_KEY` environment variable

## Quick Start

```bash
# Set your API key
export AGENTBAY_API_KEY=your_api_key_here

# Run the example
cd computer
python windows_app_management_example.py
```

## Usage Examples

### Basic Application Management

```python
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams

# Create Windows session
agent_bay = AgentBay(api_key="your_api_key")
params = CreateSessionParams(image_id="windows_latest")
result = agent_bay.create(params)
session = result.session

# Get installed applications
apps_result = session.computer.get_installed_apps(
    start_menu=True,
    desktop=False,
    ignore_system_apps=True
)

if apps_result.success:
    for app in apps_result.data:
        print(f"App: {app.name}")
        print(f"Command: {app.start_cmd}")

# Start an application
start_result = session.computer.start_app("C:\\Windows\\System32\\notepad.exe")
if start_result.success:
    for process in start_result.data:
        print(f"Started: {process.pname} (PID: {process.pid})")

# List visible applications
visible_result = session.computer.list_visible_apps()
if visible_result.success:
    for app in visible_result.data:
        print(f"Visible: {app.pname} (PID: {app.pid})")

# Stop application by PID
stop_result = session.computer.stop_app_by_pid(process.pid)

# Stop application by name
stop_result = session.computer.stop_app_by_pname("notepad.exe")

# Cleanup
agent_bay.delete(session)
```

### Window Management

```python
# List all windows
windows_result = session.window.list_windows()
if windows_result.success:
    for window in windows_result.data:
        print(f"Window: {window.title}")
        print(f"Handle: {window.handle}")

# Focus a window
focus_result = session.window.focus_window(window_handle)

# Maximize window
maximize_result = session.window.maximize_window(window_handle)

# Minimize window
minimize_result = session.window.minimize_window(window_handle)

# Close window
close_result = session.window.close_window(window_handle)
```

### UI Automation

```python
# Take screenshot
screenshot_result = session.ui.screenshot()
if screenshot_result.success:
    with open("screenshot.png", "wb") as f:
        f.write(screenshot_result.data)

# Click at coordinates
click_result = session.ui.click(x=100, y=200)

# Type text
type_result = session.ui.type("Hello, World!")

# Send key
from agentbay.ui import KeyCode
key_result = session.ui.key(KeyCode.ENTER)
```

## Features Demonstrated

### Application Discovery
- Find installed applications in start menu
- Filter system applications
- Search by application name
- Get application start commands

### Process Management
- Start applications by command
- Monitor process creation
- Track process IDs and names
- List visible applications with windows

### Application Control
- Stop applications by PID
- Stop applications by process name
- Graceful vs forceful termination
- Error handling for process operations

### Window Operations
- List all windows
- Focus specific windows
- Maximize/minimize windows
- Close windows
- Get window information

## API Methods Used

| Method | Purpose |
|--------|---------|
| `session.computer.get_installed_apps()` | Get list of installed applications |
| `session.computer.start_app()` | Start an application |
| `session.computer.list_visible_apps()` | List currently visible applications |
| `session.computer.stop_app_by_pid()` | Stop application by process ID |
| `session.computer.stop_app_by_pname()` | Stop application by process name |
| `session.window.list_windows()` | List all windows |
| `session.window.focus_window()` | Focus a specific window |
| `session.window.maximize_window()` | Maximize a window |
| `session.window.minimize_window()` | Minimize a window |
| `session.window.close_window()` | Close a window |
| `session.ui.screenshot()` | Take a screenshot |
| `session.ui.click()` | Click at coordinates |
| `session.ui.type()` | Type text |
| `session.ui.key()` | Send keyboard key |

## Common Use Cases

### 1. Automated Testing
```python
# Start application
session.computer.start_app("C:\\MyApp\\app.exe")

# Wait for window
import time
time.sleep(2)

# Interact with UI
session.ui.click(x=200, y=300)
session.ui.type("test data")
session.ui.key(KeyCode.ENTER)

# Verify results
screenshot = session.ui.screenshot()
```

### 2. Application Monitoring
```python
# Monitor running applications
while True:
    visible_apps = session.computer.list_visible_apps()
    if visible_apps.success:
        print(f"Running apps: {len(visible_apps.data)}")
    time.sleep(60)
```

### 3. Automated Workflows
```python
# Open Excel
session.computer.start_app("excel.exe")
time.sleep(3)

# Type data
session.ui.type("=SUM(A1:A10)")
session.ui.key(KeyCode.ENTER)

# Save
session.ui.key(KeyCode.CTRL, KeyCode.S)
```

## Best Practices

1. **Wait for Application Load**: Add delays after starting applications
2. **Error Handling**: Always check `result.success` before proceeding
3. **Resource Cleanup**: Stop applications and delete sessions when done
4. **Process Identification**: Use PIDs for reliable process management
5. **Retry Logic**: Implement retries for resource creation delays
6. **Window Focus**: Ensure window has focus before UI interactions
7. **Screenshot Verification**: Use screenshots to verify UI state

## Related Documentation

- [Computer Use Guide](../../../../docs/guides/computer-use/README.md)
- [Computer Application Management](../../../../docs/guides/computer-use/computer-application-management.md)
- [Computer UI Automation](../../../../docs/guides/computer-use/computer-ui-automation.md)
- [Window Management](../../../../docs/guides/computer-use/window-management.md)

## Troubleshooting

### Resource Creation Delay

If you see "Resource creation in progress" message:
- Wait 90 seconds and retry
- This is normal for Windows session initialization
- Consider session pooling for production

### Application Not Found

If application is not in the list:
- Check application is installed in start menu
- Try using full path to executable
- Verify application name spelling

### Application Won't Start

If application fails to start:
- Verify start command is correct
- Check application permissions
- Ensure application is compatible with Windows version
- Review application dependencies

### Window Operations Fail

If window operations don't work:
- Verify window handle is valid
- Check window still exists
- Ensure window is not minimized (for some operations)
- Wait for window to be ready

### UI Automation Issues

If UI interactions fail:
- Take screenshot to verify UI state
- Ensure window has focus
- Add delays between actions
- Verify coordinates are correct
- Check for popup dialogs blocking interaction





# Windows Application Management Example

This example demonstrates how to use the AgentBay SDK to manage desktop applications on Windows.

## Overview

The example shows a complete workflow:

1. **Find installed applications** - Discover all applications available in the Windows environment
2. **Launch an application** - Start Notepad as an example
3. **Monitor running applications** - List currently visible applications with windows
4. **Stop the application** - Gracefully terminate the running application

## Prerequisites

- Python 3.7+
- AgentBay SDK
- Valid `AGENTBAY_API_KEY` environment variable

## Installation

```bash
# Create virtual environment
python3 -m venv venv

# Activate virtual environment
# On macOS/Linux:
source venv/bin/activate
# On Windows:
# venv\Scripts\activate

# Install AgentBay SDK
pip install -e /path/to/wuying-agentbay-sdk/python
```

## Usage

```bash
# Set your API key
export AGENTBAY_API_KEY="your_api_key_here"

# Run the example
python windows_app_management_example.py
```

## What the Example Does

### Step 1: Finding Installed Applications

```python
apps_result = session.computer.get_installed_apps(
    start_menu=True,
    desktop=False,
    ignore_system_apps=True
)
```

Discovers all installed applications in the Windows start menu, filtering out system apps.

### Step 2: Finding Target Application

Searches for Notepad in the list of installed applications. Falls back to the default Windows path if not found.

### Step 3: Launching Application

```python
start_result = session.computer.start_app(notepad_cmd)
```

Starts Notepad and returns information about all spawned processes.

### Step 4: Monitoring Running Applications

```python
visible_result = session.computer.list_visible_apps()
```

Lists all applications with visible windows currently running.

### Step 5: Stopping Application

```python
# Method 1: Stop by Process ID
stop_result = session.computer.stop_app_by_pid(pid)

# Method 2: Stop by Process Name (fallback)
stop_result = session.computer.stop_app_by_pname(process_name)
```

Attempts to stop the application, first by PID, then by process name if needed.

## Expected Output

```
================================================================================
Windows Application Management Example
================================================================================

Initializing AgentBay client...
✅ Client initialized

Creating Windows session...
  Attempt 1/2...
✅ Session created: session-xxxxxxxxxxxxxxxxx

================================================================================
Step 1: Finding installed applications...
================================================================================
✅ Found 120 installed applications

First 5 applications:

1. Notepad
   Start Command: C:\Windows\System32\notepad.exe

2. Paint
   Start Command: C:\Windows\System32\mspaint.exe

...

================================================================================
Step 2: Finding Notepad application...
================================================================================
✅ Found application: Notepad
Start Command: C:\Windows\System32\notepad.exe

================================================================================
Step 3: Launching application...
================================================================================
✅ Application started with 1 process(es)
  - notepad.exe (PID: 12345)
    Command: C:\Windows\System32\notepad.exe

================================================================================
Step 4: Waiting for application to load...
================================================================================
Waiting 5 seconds...
✅ Wait complete

================================================================================
Step 5: Checking running applications...
================================================================================
✅ Found 1 visible application(s)
  - notepad.exe (PID: 12345)

================================================================================
Step 6: Stopping application...
================================================================================
Attempting to stop process by PID: 12345
✅ Application stopped successfully (by PID)

================================================================================
Workflow Summary
================================================================================
✅ Session creation: Success
✅ Get installed apps: 120 applications found
✅ Find target app: Found
✅ Start application: 1 processes started
✅ List visible apps: 1 visible applications
✅ Stop application: Success
================================================================================

🎉 Workflow completed successfully!

================================================================================
Cleaning up session...
================================================================================
✅ Session deleted
```

## Features Demonstrated

- **Session Management**: Creating and cleaning up Windows sessions
- **Application Discovery**: Finding installed desktop applications
- **Process Management**: Starting and stopping applications
- **Process Monitoring**: Listing visible applications
- **Error Handling**: Robust error handling with fallback strategies
- **Retry Logic**: Automatic retry for resource creation delays

## API Methods Used

| Method | Purpose |
|--------|---------|
| `session.computer.get_installed_apps()` | Get list of installed applications |
| `session.computer.start_app()` | Start an application |
| `session.computer.list_visible_apps()` | List currently visible applications |
| `session.computer.stop_app_by_pid()` | Stop application by process ID |
| `session.computer.stop_app_by_pname()` | Stop application by process name |

## Troubleshooting

### Resource Creation Delay

If you see "Resource creation in progress" message, the script will automatically wait and retry. This is normal for Windows sessions.

### Application Not Found

The example uses Notepad which is available on all Windows systems. If you want to use a different application:

1. Run the example once to see the list of available applications
2. Modify the code to search for your target application
3. Update the start command accordingly

## Related Documentation

- [Computer Application Management Guide](../../../../../docs/guides/computer-use/computer-application-management.md)
- [Session Management](../../../../../docs/guides/common-features/basics/session-management.md)
- [Computer UI Automation](../../../../../docs/guides/computer-use/computer-ui-automation.md)

## License

This example is part of the Wuying AgentBay SDK.




# Mobile Use Examples

This directory contains examples demonstrating mobile UI automation capabilities in AgentBay SDK.

## Overview

Mobile Use environment (`mobile_latest` image) provides cloud-based Android mobile automation with:
- UI element detection and interaction
- Touch gestures (tap, swipe, scroll)
- Text input and key events
- Screenshot capture
- Mobile application management
- ADB (Android Debug Bridge) integration

## Examples

### mobile_system/main.py

Comprehensive mobile automation example demonstrating:

1. **Application Management**
   - Get installed applications
   - Start applications
   - Stop applications
   - Application state monitoring

2. **UI Element Detection**
   - Get clickable UI elements
   - Get all UI elements (tree structure)
   - Element property inspection

3. **Touch Interactions**
   - Tap at coordinates
   - Swipe gestures
   - Multi-touch operations

4. **Text Input**
   - Input text to focused elements
   - Send key events
   - Keyboard operations

5. **Screenshot Capture**
   - Capture mobile screen
   - Save screenshots locally

### mobile_get_adb_url_example.py

ADB URL retrieval example:
- Get ADB connection URL
- Connect external tools to mobile session
- Remote debugging setup

## Prerequisites

- Python 3.8 or later
- AgentBay SDK installed: `pip install wuying-agentbay-sdk`
- Valid `AGENTBAY_API_KEY` environment variable

## Quick Start

```bash
# Set your API key
export AGENTBAY_API_KEY=your_api_key_here

# Run the main example
cd mobile_system
python main.py

# Run ADB URL example
cd ..
python mobile_get_adb_url_example.py
```

## Usage Examples

### Basic Mobile Automation

```python
from agentbay import AgentBay
from agentbay.session_params import CreateSessionParams
from agentbay.ui import KeyCode

# Create mobile session
agent_bay = AgentBay(api_key="your_api_key")
params = CreateSessionParams(image_id="mobile_latest")
result = agent_bay.create(params)
session = result.session

# Get installed applications
apps_result = session.mobile.get_installed_apps(
    start_menu=True,
    desktop=False,
    ignore_system_apps=True
)

if apps_result.success:
    print(f"Found {len(apps_result.data)} applications")

# Start an application
start_result = session.mobile.start_app(
    "monkey -p com.android.settings -c android.intent.category.LAUNCHER 1"
)

# Get clickable UI elements
elements_result = session.mobile.get_clickable_ui_elements()
if elements_result.success:
    for element in elements_result.elements:
        print(f"Element: {element['text']}")

# Tap on screen
tap_result = session.mobile.tap(x=500, y=800)

# Swipe gesture
swipe_result = session.mobile.swipe(
    start_x=100,
    start_y=800,
    end_x=900,
    end_y=200,
    duration_ms=500
)

# Input text
input_result = session.mobile.input_text("Hello, AgentBay!")

# Send key event
key_result = session.mobile.send_key(KeyCode.HOME)

# Take screenshot
screenshot_result = session.mobile.screenshot()
if screenshot_result.success:
    with open("screenshot.png", "wb") as f:
        f.write(screenshot_result.data)

# Stop application
stop_result = session.mobile.stop_app_by_cmd(
    "am force-stop com.android.settings"
)

# Cleanup
agent_bay.delete(session)
```

### UI Element Tree Navigation

```python
# Get all UI elements
all_elements_result = session.mobile.get_all_ui_elements(timeout_ms=3000)

if all_elements_result.success:
    import json
    elements = json.loads(all_elements_result.elements)
    
    def print_element(element, indent=0):
        prefix = "  " * indent
        print(f"{prefix}- {element['className']}")
        print(f"{prefix}  text: '{element['text']}'")
        print(f"{prefix}  resourceId: '{element['resourceId']}'")
        
        for child in element.get('children', []):
            print_element(child, indent + 1)
    
    for element in elements:
        print_element(element)
```

### Application with Specific Activity

```python
# Start app with specific activity
app_package = "com.example.app"
app_activity = "com.example.app.MainActivity"
start_cmd = f"monkey -p {app_package} -c android.intent.category.LAUNCHER 1"

start_result = session.mobile.start_app(
    start_cmd=start_cmd,
    activity=app_activity
)

if start_result.success:
    for process in start_result.data:
        print(f"Started: {process.pname} (PID: {process.pid})")
```

### ADB Connection

```python
# Get ADB URL for external tools
adb_url_result = session.mobile.get_adb_url()
if adb_url_result.success:
    adb_url = adb_url_result.data
    print(f"ADB URL: {adb_url}")
    
    # Use with adb command line:
    # adb connect {adb_url}
```

## Features Demonstrated

### Application Management
- List installed applications
- Filter system applications
- Start applications with monkey command
- Start with specific activity
- Stop applications by command
- Monitor application processes

### UI Element Detection
- Get clickable elements only
- Get complete UI element tree
- Element property inspection
- Resource ID and text extraction
- Hierarchical element structure

### Touch Interactions
- Single tap at coordinates
- Long press
- Swipe gestures with duration
- Multi-point touch
- Drag and drop

### Text Input
- Input text to focused elements
- Send individual key events
- Special keys (HOME, BACK, etc.)
- Keyboard shortcuts

### Screenshot Operations
- Capture full screen
- Save to local file
- Base64 encoding support
- Image format handling

## API Methods Used

| Method | Purpose |
|--------|---------|
| `session.mobile.get_installed_apps()` | Get list of installed applications |
| `session.mobile.start_app()` | Start an application |
| `session.mobile.stop_app_by_cmd()` | Stop application by command |
| `session.mobile.get_clickable_ui_elements()` | Get clickable UI elements |
| `session.mobile.get_all_ui_elements()` | Get complete UI element tree |
| `session.mobile.tap()` | Tap at coordinates |
| `session.mobile.swipe()` | Perform swipe gesture |
| `session.mobile.input_text()` | Input text |
| `session.mobile.send_key()` | Send key event |
| `session.mobile.screenshot()` | Take screenshot |
| `session.mobile.get_adb_url()` | Get ADB connection URL |

## Common Use Cases

### 1. App Testing Automation

```python
# Start app
session.mobile.start_app("monkey -p com.myapp -c android.intent.category.LAUNCHER 1")

# Wait for app to load
import time
time.sleep(3)

# Get UI elements
elements = session.mobile.get_clickable_ui_elements()

# Find and tap login button
for element in elements.elements:
    if element['text'] == 'Login':
        session.mobile.tap(x=element['x'], y=element['y'])
        break

# Input credentials
session.mobile.input_text("user@example.com")
session.mobile.send_key(KeyCode.TAB)
session.mobile.input_text("password123")

# Submit
session.mobile.send_key(KeyCode.ENTER)

# Verify with screenshot
screenshot = session.mobile.screenshot()
```

### 2. UI Element Inspection

```python
# Get all elements
all_elements = session.mobile.get_all_ui_elements()

# Find specific element by text
def find_element_by_text(elements, text):
    for element in elements:
        if element['text'] == text:
            return element
        if 'children' in element:
            result = find_element_by_text(element['children'], text)
            if result:
                return result
    return None

target = find_element_by_text(all_elements.elements, "Settings")
if target:
    session.mobile.tap(x=target['x'], y=target['y'])
```

### 3. Gesture Automation

```python
# Swipe up (scroll down)
session.mobile.swipe(
    start_x=500,
    start_y=1500,
    end_x=500,
    end_y=500,
    duration_ms=300
)

# Swipe right (navigate)
session.mobile.swipe(
    start_x=100,
    start_y=800,
    end_x=900,
    end_y=800,
    duration_ms=200
)

# Long press
session.mobile.tap(x=500, y=800)  # Hold for long press
```

## Best Practices

1. **Wait for UI Load**: Add delays after starting apps or navigation
2. **Element Verification**: Verify elements exist before interaction
3. **Error Handling**: Check `result.success` for all operations
4. **Resource Cleanup**: Stop apps and delete sessions when done
5. **Screenshot Verification**: Use screenshots to verify UI state
6. **Coordinate Accuracy**: Use element coordinates from UI tree
7. **Gesture Timing**: Adjust swipe duration for different effects
8. **Key Events**: Use appropriate key codes for device buttons

## Related Documentation

- [Mobile Use Guide](../../../../docs/guides/mobile-use/README.md)
- [Mobile Application Management](../../../../docs/guides/mobile-use/mobile-application-management.md)
- [Mobile UI Automation](../../../../docs/guides/mobile-use/mobile-ui-automation.md)

## Troubleshooting

### Application Not Starting

If application fails to start:
- Verify package name is correct
- Check application is installed
- Ensure monkey command syntax is correct
- Try with specific activity

### UI Elements Not Found

If UI elements are missing:
- Wait longer for UI to load
- Check timeout parameter
- Verify app is in correct state
- Take screenshot to inspect UI

### Touch Interactions Not Working

If taps/swipes don't work:
- Verify coordinates are within screen bounds
- Check element is visible and enabled
- Ensure no overlay blocking interaction
- Add delay before interaction

### ADB Connection Issues

If ADB URL doesn't work:
- Verify session is mobile_latest image
- Check network connectivity
- Ensure ADB is installed locally
- Try reconnecting: `adb disconnect` then `adb connect`

### Screenshot Issues

If screenshots fail or are corrupted:
- Check session is active
- Verify sufficient memory
- Try smaller screen resolution
- Handle base64 decoding correctly





# Mobile System Example

This example demonstrates how to use the mobile system features of the AgentBay SDK for Python.

## Features Demonstrated

- Creating a session with a mobile image
- Getting installed applications
- Starting and stopping applications
- Getting clickable UI elements
- Getting all UI elements with hierarchy information
- Sending key events
- Input text
- Swipe screen gestures
- Click screen operations
- Taking screenshots
- Starting applications with specific activities

## Running the Example

1. Make sure you have installed the AgentBay SDK:

```bash
pip install wuying-agentbay-sdk
```

2. Set your API key as an environment variable (recommended):

```bash
export AGENTBAY_API_KEY=your_api_key_here
```

3. Run the example:

```bash
python main.py
```

## Code Explanation

The example demonstrates mobile system operations:

1. Create a new session with a mobile image
2. Get a list of installed applications
3. Start an application using a package name
4. Stop an application
5. Interact with the UI using various methods:
   - Get clickable UI elements
   - Get all UI elements with their hierarchy
   - Send key events (HOME key)
   - Input text
   - Perform swipe gestures
   - Perform click operations
6. Take screenshots
7. Start an application with a specific activity
8. Clean up by deleting the session

Mobile system features are particularly useful for:

- Mobile application testing
- Automated UI testing
- Creating mobile app demos
- Building mobile app automation tools
- Implementing mobile device control applications

For more details on mobile system features, see the [Application API Reference](../../../../../typescript/docs/api/computer-use/application.md) and [UI API Reference](../../../../../typescript/docs/api/computer-use/ui.md).





# Typescript SDK Documentation


# AgentBay SDK for TypeScript

> Execute commands, manipulate files, and run code in cloud environments

## 📦 Installation

```bash
npm install wuying-agentbay-sdk
```

## 🚀 Prerequisites

Before using the SDK, you need to:

1. Register an Alibaba Cloud account: [https://aliyun.com](https://aliyun.com)
2. Get API credentials: [AgentBay Console](https://agentbay.console.aliyun.com/service-management)
3. Set environment variable: `export AGENTBAY_API_KEY=your_api_key`

## 🚀 Quick Start
```typescript
import { AgentBay } from 'wuying-agentbay-sdk';

async function main() {
    // Create session
    const agentBay = new AgentBay();
    const result = await agentBay.create();
    // Verified: ✓ Client initialized and session created successfully

    if (result.success) {
        const session = result.session;

        // Execute command
        const cmdResult = await session.command.executeCommand("ls -la");
        console.log(cmdResult.output);
        // Verified: ✓ Command executed successfully
        // Sample output: "总计 100\ndrwxr-x--- 16 wuying wuying 4096..."

        // File operations
        await session.fileSystem.writeFile("/tmp/test.txt", "Hello World");
        const content = await session.fileSystem.readFile("/tmp/test.txt");
        console.log(content.content);
        // Verified: ✓ File written and read successfully
        // Output: "Hello World"
    }
}

main().catch(console.error);
```

## 📖 Complete Documentation

### 🆕 New Users
- [📚 Quick Start Tutorial](https://github.com/aliyun/wuying-agentbay-sdk/tree/main/docs/quickstart/README.md) - Get started in 5 minutes
- [🎯 Core Concepts](https://github.com/aliyun/wuying-agentbay-sdk/tree/main/docs/quickstart/basic-concepts.md) - Understanding cloud environments and sessions

### 🚀 Experienced Users
**Choose Your Cloud Environment:**
- 🌐 [Browser Use](https://github.com/aliyun/wuying-agentbay-sdk/tree/main/docs/guides/browser-use/README.md) - Web scraping, browser testing, form automation
- 🖥️ [Computer Use](https://github.com/aliyun/wuying-agentbay-sdk/tree/main/docs/guides/computer-use/README.md) - Windows desktop automation, UI testing
- 📱 [Mobile Use](https://github.com/aliyun/wuying-agentbay-sdk/tree/main/docs/guides/mobile-use/README.md) - Android UI testing, mobile app automation
- 💻 [CodeSpace](https://github.com/aliyun/wuying-agentbay-sdk/tree/main/docs/guides/codespace/README.md) - Code execution, development environments

**Additional Resources:**
- [📖 Feature Guides](https://github.com/aliyun/wuying-agentbay-sdk/tree/main/docs/guides/README.md) - Complete feature introduction
- [🔧 TypeScript API Reference](docs/api/README.md) - Detailed API documentation
- [💻 TypeScript Examples](docs/examples/README.md) - Complete example code
- [📋 Logging Configuration](https://github.com/aliyun/wuying-agentbay-sdk/tree/main/docs/guides/common-features/configuration/logging.md) - Configure logging levels and output

### 🆘 Need Help
- [🔧 TypeScript API Reference](docs/api/README.md) - Local API documentation
- [💡 TypeScript Examples](docs/examples/README.md) - Local example code

## 🔧 Core Features Quick Reference

### Session Management
```typescript
// Create session
const session = (await agentBay.create()).session;
// Verified: ✓ Session created successfully
```

### File Operations
```typescript
// Read and write files
await session.fileSystem.writeFile("/path/file.txt", "content");
const content = await session.fileSystem.readFile("/path/file.txt");
// Verified: ✓ File operations work correctly
// content.content contains the file's text content

// List directory
const files = await session.fileSystem.listDirectory("/path");
// Verified: ✓ Returns list of file/directory information
```

### Command Execution
```typescript
// Execute command
const result = await session.command.executeCommand("node script.js");
console.log(result.output);
// Verified: ✓ Command executed successfully
// result.output contains the command's stdout
```

### Data Persistence
```typescript
// Create context
const context = (await agentBay.context.get("my-project", true)).context;
// Verified: ✓ Context created or retrieved successfully

// Create session with context
import { ContextSync, SyncPolicy } from 'wuying-agentbay-sdk';
const contextSync = new ContextSync({
    contextId: context.id,
    path: "/tmp/data",
    policy: SyncPolicy.default()
});
const session = (await agentBay.create({ contextSync: [contextSync] })).session;
// Verified: ✓ Session created with context synchronization
// Data in /tmp/data will be synchronized to the context
```

## 🆘 Get Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Complete Documentation](https://github.com/aliyun/wuying-agentbay-sdk/tree/main/docs/README.md)

## 📄 License

This project is licensed under the Apache License 2.0 - see the [LICENSE](../LICENSE) file for details.



# AgentBay TypeScript SDK API Reference

Complete API reference documentation for the AgentBay TypeScript SDK.

## 📚 Common Features

APIs available across all environments:

### Basics
- [**AgentBay**](common-features/basics/agentbay.md) - Main client for creating and managing sessions
- [**Session**](common-features/basics/session.md) - Session lifecycle and operations management
- [**Command**](common-features/basics/command.md) - Execute shell commands in cloud environments
- [**FileSystem**](common-features/basics/filesystem.md) - File and directory operations
- [**Context**](common-features/basics/context.md) - Data persistence and context management
- [**ContextManager**](common-features/basics/context-manager.md) - Context operations and file synchronization
- [**Logging**](common-features/basics/logging.md) - Logging configuration and management

### Advanced
- [**Agent**](common-features/advanced/agent.md) - AI agent integration and MCP tools
- [**OSS**](common-features/advanced/oss.md) - Object Storage Service integration

## 🚀 Environment-Specific Features

### Browser Use (`browser_latest`)
- [**Browser**](browser-use/browser.md) - Browser initialization and CDP connection
  - `initialize()` / `initializeAsync()` - Initialize browser with configuration options
  - `getEndpointUrl()` - Get CDP WebSocket endpoint for Playwright/Puppeteer connection
  - Options: Stealth mode, proxy (custom/wuying), fingerprint, viewport, CAPTCHA solving
  - AI Agent: `agent.act()`, `agent.observe()`, `agent.extract()` for natural language automation
- [**Extension**](browser-use/extension.md) - Browser extension management and deployment

### Computer Use (`windows_latest`, `linux_latest`)
- [**Computer**](computer-use/computer.md) - Desktop automation operations
  - Mouse: `clickMouse()`, `moveMouse()`, `dragMouse()`, `scroll()`, `getCursorPosition()`
  - Keyboard: `inputText()`, `pressKeys()`, `releaseKeys()`
  - Screen: `screenshot()`, `getScreenSize()`
  - Window: `listRootWindows()`, `getActiveWindow()`, `activateWindow()`, `closeWindow()`, `maximizeWindow()`, `minimizeWindow()`, `restoreWindow()`, `resizeWindow()`, `fullscreenWindow()`, `focusMode()`
  - Application: `getInstalledApps()`, `startApp()`, `listVisibleApps()`, `stopAppByPname()`, `stopAppByPid()`, `stopAppByCmd()`
- [**UI**](computer-use/ui.md) - ⚠️ Deprecated, use Computer or Mobile APIs instead
- [**Window**](computer-use/window.md) - ⚠️ Deprecated, use Computer API instead
- [**Application**](computer-use/application.md) - ⚠️ Deprecated, use Computer or Mobile APIs instead

### Mobile Use (`mobile_latest`)
- [**Mobile**](mobile-use/mobile.md) - Android mobile device automation
  - Touch: `tap()`, `swipe()`
  - Input: `inputText()`, `sendKey()` (with KeyCode constants)
  - UI Elements: `getClickableUiElements()`, `getAllUiElements()`
  - Application: `getInstalledApps()`, `startApp()`, `stopAppByCmd()`
  - Screen: `screenshot()`

### CodeSpace (`code_latest`)
- [**Code**](codespace/code.md) - Execute code in cloud environment
  - `runCode()` - Run Python or JavaScript code with timeout control
  - Supports: Python, JavaScript
  - Maximum execution time: 60 seconds (gateway limitation)

## 📘 Related Documentation

- [Feature Guides](../../../docs/guides/README.md) - Detailed usage guides and tutorials
- [Code Examples](../examples/README.md) - Complete example implementations
- [Quick Start](../../../docs/quickstart/README.md) - Get started in 5 minutes

---

**Need help?** Check out the [complete documentation](../../../docs/README.md) or [open an issue](https://github.com/aliyun/wuying-agentbay-sdk/issues).




# Browser API Reference

The Browser API provides methods for initializing and managing browser instances in the AgentBay cloud environment. It supports both headless and non-headless browsers with extensive configuration options including stealth mode, custom viewports, fingerprinting, proxies, and more.

## Overview

The Browser API is accessed through a session instance and provides methods for browser lifecycle management and connection to automation frameworks via Chrome DevTools Protocol (CDP).

```typescript
import { AgentBay, BrowserOptionClass } from '@wuying-org/agentbay-sdk';

// Access browser through session
const session = result.session;
const browserAPI = session.browser;
```

## Interfaces and Classes

### BrowserOption Interface

Type definition for browser configuration options.

```typescript
export interface BrowserOption {
  useStealth?: boolean;
  userAgent?: string;
  viewport?: BrowserViewport;
  screen?: BrowserScreen;
  fingerprint?: BrowserFingerprint;
  solveCaptchas?: boolean;
  proxies?: BrowserProxy[];
  extensionPath?: string;
  browserType?: 'chrome' | 'chromium' | undefined;
  cmdArgs?: string[];
  defaultNavigateUrl?: string;
}
```

**Properties:**

- `useStealth` (boolean | undefined): Enable stealth mode to avoid detection. Default: `undefined`
- `userAgent` (string | undefined): Custom user agent string. Default: `undefined`
- `viewport` (BrowserViewport | undefined): Browser viewport dimensions. Default: `undefined`
- `screen` (BrowserScreen | undefined): Screen dimensions. Default: `undefined`
- `fingerprint` (BrowserFingerprint | undefined): Fingerprint configuration. Default: `undefined`
- `solveCaptchas` (boolean | undefined): Auto-solve captchas. Default: `undefined`
- `proxies` (BrowserProxy[] | undefined): Proxy configurations (max 1). Default: `undefined`
- `extensionPath` (string | undefined): Path to extensions directory. Default: `undefined`
- `browserType` ('chrome' | 'chromium' | undefined): Browser type (computer use images only). Default: `undefined`
- `cmdArgs` (string[] | undefined): List of Chrome/Chromium command-line arguments to customize browser behavior. Default: `undefined`
- `defaultNavigateUrl` (string | undefined): URL that the browser automatically navigates to after initialization. Recommended to use Chrome internal pages (e.g., `"chrome://version/"`) to avoid timeout issues. Default: `undefined`

### BrowserOptionClass

Class implementation of BrowserOption with validation and serialization.

```typescript
export class BrowserOptionClass implements BrowserOption {
  useStealth?: boolean;
  userAgent?: string;
  viewport?: BrowserViewport;
  screen?: BrowserScreen;
  fingerprint?: BrowserFingerprint;
  solveCaptchas?: boolean;
  proxies?: BrowserProxy[];
  extensionPath?: string;
  browserType?: 'chrome' | 'chromium' | undefined;
  cmdArgs?: string[];
  defaultNavigateUrl?: string;

  constructor(
    useStealth = false,
    userAgent?: string,
    viewport?: BrowserViewport,
    screen?: BrowserScreen,
    fingerprint?: BrowserFingerprint,
    solveCaptchas = false,
    proxies?: BrowserProxy[],
    browserType?: 'chrome' | 'chromium',
    cmdArgs?: string[],
    defaultNavigateUrl?: string
  )
}
```

**Constructor Parameters:**

All parameters are optional with defaults:
- `useStealth`: `false`
- `solveCaptchas`: `false`
- `browserType`: `undefined`
- `cmdArgs`: `undefined`
- `defaultNavigateUrl`: `undefined`
- Other parameters: `undefined`

**Methods:**

#### toMap(): Record<string, any>

Converts BrowserOption to a plain object for API requests.

```typescript
toMap(): Record<string, any>
```

**Returns:**
- `Record<string, any>`: Object representation of the browser options

**Example:**
```typescript
const option = new BrowserOptionClass(true); // useStealth = true
const optionMap = option.toMap();
```

#### fromMap(m: Record<string, any>): BrowserOptionClass

Populates BrowserOption from a plain object.

```typescript
fromMap(m: Record<string, any> | null | undefined): BrowserOptionClass
```

**Parameters:**
- `m` (Record<string, any> | null | undefined): Object containing browser option data

**Returns:**
- `BrowserOptionClass`: Self (for method chaining)

**Example:**
```typescript
const option = new BrowserOptionClass();
option.fromMap({ useStealth: true, browserType: 'chrome' });
```

### BrowserViewport

Defines the browser viewport dimensions.

```typescript
export interface BrowserViewport {
  width: number;
  height: number;
}
```

**Common Viewport Sizes:**
```typescript
// Desktop
{ width: 1920, height: 1080 }
{ width: 1366, height: 768 }

// Laptop
{ width: 1440, height: 900 }

// Tablet
{ width: 1024, height: 768 }

// Mobile
{ width: 375, height: 667 }
{ width: 414, height: 896 }
```

### BrowserScreen

Defines the screen dimensions (usually same or larger than viewport).

```typescript
export interface BrowserScreen {
  width: number;
  height: number;
}
```

### BrowserFingerprint

Configuration for browser fingerprint randomization.

```typescript
export interface BrowserFingerprint {
  devices?: string[];
  operatingSystems?: string[];
  locales?: string[];
}
```

**Valid Values:**

- **devices**: `["desktop", "mobile"]`
- **operatingSystems**: `["windows", "macos", "linux", "android", "ios"]`
- **locales**: Standard locale strings (e.g., `["en-US", "zh-CN", "ja-JP"]`)

**Example:**
```typescript
const fingerprint: BrowserFingerprint = {
  devices: ["desktop"],
  operatingSystems: ["windows", "macos"],
  locales: ["en-US", "en-GB"]
};
```

### BrowserProxy / BrowserProxyClass

Configuration for browser proxy settings.

```typescript
export interface BrowserProxy {
  type: 'custom' | 'wuying';
  server?: string;
  username?: string;
  password?: string;
  strategy?: string;
  pollSize?: number;
}

export class BrowserProxyClass implements BrowserProxy {
  constructor(
    type: 'custom' | 'wuying',
    server?: string,
    username?: string,
    password?: string,
    strategy?: string,
    pollSize?: number
  )
}
```

**Proxy Types:**

1. **Custom Proxy** (`type: "custom"`):
   ```typescript
   const proxy = new BrowserProxyClass(
     'custom',
     'proxy.example.com:8080',
     'user',
     'pass'
   );
   
   // Or using interface
   const proxy: BrowserProxy = {
     type: 'custom',
     server: 'proxy.example.com:8080',
     username: 'user',
     password: 'pass'
   };
   ```

2. **WuYing Proxy** (`type: "wuying"`):
   - **Restricted Strategy**: Single dedicated IP
     ```typescript
     const proxy: BrowserProxy = {
       type: 'wuying',
       strategy: 'restricted'
     };
     ```
   
   - **Polling Strategy**: Rotating IP pool
     ```typescript
     const proxy: BrowserProxy = {
       type: 'wuying',
       strategy: 'polling',
       pollSize: 10
     };
     ```

**Validation Rules:**
- Maximum 1 proxy allowed in the `proxies` array
- `server` is required for `custom` type
- `strategy` is required for `wuying` type
- `pollSize` must be > 0 for `polling` strategy

## Browser Class

### Methods

#### initialize(option: BrowserOption | BrowserOptionClass): boolean

Initializes the browser with the given options (synchronous).

```typescript
initialize(option: BrowserOption | BrowserOptionClass): boolean
```

**Parameters:**
- `option` (BrowserOption | BrowserOptionClass): Browser configuration options

**Returns:**
- `boolean`: `true` if initialization was successful, `false` otherwise

**Throws:**
- `Error`: If browser option validation fails

**Example:**
```typescript
const option = new BrowserOptionClass(
  true,                                    // useStealth
  "Mozilla/5.0 (Macintosh; Intel...)",   // userAgent
  { width: 1920, height: 1080 },         // viewport
);

const success = session.browser.initialize(option);
if (!success) {
  throw new Error("Browser initialization failed");
}
```

#### initializeAsync(option: BrowserOption | BrowserOptionClass): Promise<boolean>

Initializes the browser with the given options (asynchronous).

```typescript
async initializeAsync(option: BrowserOption | BrowserOptionClass): Promise<boolean>
```

**Parameters:**
- `option` (BrowserOption | BrowserOptionClass): Browser configuration options

**Returns:**
- `Promise<boolean>`: Resolves to `true` if successful, `false` otherwise

**Throws:**
- `Error`: If browser option validation fails

**Example:**
```typescript
// Using BrowserOptionClass
const option = new BrowserOptionClass(
  false,  // useStealth
  undefined,  // userAgent
  undefined,  // viewport
  undefined,  // screen
  undefined,  // fingerprint
  false,  // solveCaptchas
  undefined,  // proxies
  'chrome' as 'chrome'  // browserType
);

const success = await session.browser.initializeAsync(option);
if (!success) {
  throw new Error("Browser initialization failed");
}

// Or using plain object
const success = await session.browser.initializeAsync({
  browserType: 'chrome',
  useStealth: true
});
```

#### getEndpointUrl(): string

Retrieves the CDP (Chrome DevTools Protocol) endpoint URL for connecting automation tools.

```typescript
getEndpointUrl(): string
```

**Returns:**
- `string`: The CDP WebSocket endpoint URL (e.g., `ws://host:port/devtools/browser/...`)

**Throws:**
- `Error`: If browser is not initialized

**Example:**
```typescript
const endpointUrl = session.browser.getEndpointUrl();

// Use with Playwright
import { chromium } from 'playwright';
const browser = await chromium.connectOverCDP(endpointUrl);
```

#### isInitialized(): boolean

Checks if the browser has been initialized.

```typescript
isInitialized(): boolean
```

**Returns:**
- `boolean`: `true` if the browser is initialized, `false` otherwise

**Example:**
```typescript
if (session.browser.isInitialized()) {
  console.log("Browser is ready");
} else {
  console.log("Browser needs initialization");
}
```

#### getOption(): BrowserOptionClass | null

Retrieves the current browser configuration.

```typescript
getOption(): BrowserOptionClass | null
```

**Returns:**
- `BrowserOptionClass | null`: The current browser configuration, or `null` if not initialized

**Example:**
```typescript
const option = session.browser.getOption();
if (option) {
  console.log(`Browser type: ${option.browserType}`);
}
```

## Complete Usage Example

### Basic Usage

```typescript
import { AgentBay, CreateSessionParams, BrowserOptionClass } from '@wuying-org/agentbay-sdk';
import { chromium } from 'playwright';

async function main() {
  // Initialize AgentBay
  const apiKey = process.env.AGENTBAY_API_KEY;
  if (!apiKey) {
    throw new Error("AGENTBAY_API_KEY not set");
  }
  const agentBay = new AgentBay(apiKey);

  // Create session
  const params = new CreateSessionParams({ imageId: 'browser_latest' });
  const result = await agentBay.create(params);
  if (!result.success || !result.session) {
    throw new Error("Failed to create session");
  }

  const session = result.session;

  try {
    // Initialize browser with default options
    const option = new BrowserOptionClass();
    const ok = await session.browser.initializeAsync(option);
    if (!ok) {
      throw new Error("Browser initialization failed");
    }

    // Get CDP endpoint
    const endpointUrl = session.browser.getEndpointUrl();

    // Connect with Playwright
    const browser = await chromium.connectOverCDP(endpointUrl);
    const context = browser.contexts()[0];
    const page = await context.newPage();

    // Navigate and interact
    await page.goto('https://example.com');
    const title = await page.title();
    console.log(`Page title: ${title}`);

    await browser.close();

  } finally {
    session.delete();
  }
}

main();
```

### Advanced Configuration

```typescript
import {
  BrowserOptionClass,
  BrowserProxyClass,
  BrowserViewport,
  BrowserScreen,
  BrowserFingerprint
} from '@wuying-org/agentbay-sdk';

// Create custom browser configuration
const option = new BrowserOptionClass(
  true,                                    // useStealth
  "Mozilla/5.0 (Windows NT 10.0...)",     // userAgent
  { width: 1920, height: 1080 },          // viewport
  { width: 1920, height: 1080 },          // screen
  {                                        // fingerprint
    devices: ["desktop"],
    operatingSystems: ["windows", "macos"],
    locales: ["en-US"]
  },
  false,                                   // solveCaptchas
  [new BrowserProxyClass(                  // proxies
    'custom',
    'proxy.example.com:8080',
    'username',
    'password'
  )],
  'chrome' as 'chrome',                    // browserType
  [                                        // cmdArgs
    '--disable-features=PrivacySandboxSettings4',
    '--disable-background-timer-throttling',
  ],
  'chrome://version/'                      // defaultNavigateUrl
);

// Or using plain object interface
const option = {
  useStealth: true,
  userAgent: "Mozilla/5.0 (Windows NT 10.0...)",
  viewport: { width: 1920, height: 1080 },
  screen: { width: 1920, height: 1080 },
  browserType: 'chrome' as 'chrome',
  cmdArgs: [
    '--disable-features=PrivacySandboxSettings4',
    '--disable-background-timer-throttling',
  ],
  defaultNavigateUrl: 'chrome://version/',
  fingerprint: {
    devices: ["desktop"],
    operatingSystems: ["windows", "macos"],
    locales: ["en-US"]
  },
  proxies: [{
    type: 'custom' as 'custom',
    server: 'proxy.example.com:8080',
    username: 'username',
    password: 'password'
  }]
};

// Initialize with custom options
const success = await session.browser.initializeAsync(option);
if (!success) {
  throw new Error("Failed to initialize browser");
}
```

## Error Handling

### Common Errors

1. **Browser Not Initialized**
   ```typescript
   try {
     const endpoint = session.browser.getEndpointUrl();
   } catch (error) {
     // Error: "Browser not initialized"
     console.error("Initialize browser before getting endpoint");
   }
   ```

2. **Invalid Configuration**
   ```typescript
   try {
     const option = new BrowserOptionClass(
       false, undefined, undefined, undefined, undefined, false, undefined,
       'firefox' as any  // Invalid browser type
     );
   } catch (error) {
     // Error: "browserType must be 'chrome' or 'chromium'"
     console.error(`Configuration error: ${error.message}`);
   }
   ```

3. **Multiple Proxies**
   ```typescript
   try {
     const option = new BrowserOptionClass(
       false, undefined, undefined, undefined, undefined, false,
       [proxy1, proxy2]  // Too many proxies
     );
   } catch (error) {
     // Error: "proxies list length must be limited to 1"
     console.error(`Too many proxies: ${error.message}`);
   }
   ```

### Best Practices

```typescript
// Check initialization status
if (!session.browser.isInitialized()) {
  console.log("Browser not initialized");
}

// Always use try-finally for cleanup
try {
  const ok = await session.browser.initializeAsync(option);
  if (!ok) {
    throw new Error("Initialization failed");
  }
  
  // Use the browser...
  
} finally {
  session.delete();
}

// Type safety with TypeScript
const option: BrowserOption = {
  browserType: 'chrome',  // Type-checked
  useStealth: true
};
```

## Browser Type Selection

> **Note:** The `browserType` property is only available for **computer use images**. For standard browser images, the browser type is determined by the image.

### Choosing Browser Type

```typescript
// Use Chrome (Google Chrome)
const option = new BrowserOptionClass(
  false, undefined, undefined, undefined, undefined, false, undefined,
  'chrome' as 'chrome'
);

// Or using object interface
const option: BrowserOption = { browserType: 'chrome' };

// Use Chromium (open-source)
const option: BrowserOption = { browserType: 'chromium' };

// Use default (undefined - let browser image decide)
const option = new BrowserOptionClass(); // browserType is undefined by default
```

### When to Use Each Type

**Chrome** (`'chrome'`):
- Need specific Chrome-only features
- Testing against actual Chrome browser
- Matching production Chrome environment

**Chromium** (`'chromium'`):
- Open-source preference
- Lighter resource usage
- Standard web automation

**Default** (`undefined`):
- Let the platform choose optimal browser
- Maximum compatibility
- Recommended for most use cases

## Integration with Automation Tools

### Playwright

```typescript
import { chromium } from 'playwright';

// Get endpoint
const endpointUrl = session.browser.getEndpointUrl();

// Connect Playwright
const browser = await chromium.connectOverCDP(endpointUrl);
const context = browser.contexts()[0];
const page = await context.newPage();

// Use page...

await browser.close();
```

### Puppeteer

```typescript
import puppeteer from 'puppeteer-core';

// Get endpoint
const endpointUrl = session.browser.getEndpointUrl();

// Connect Puppeteer
const browser = await puppeteer.connect({
  browserWSEndpoint: endpointUrl
});

const pages = await browser.pages();
const page = pages[0];

// Use page...

await browser.disconnect();
```

## PageUseAgent Integration

The Browser class includes an `agent` property for AI-powered browser automation.

```typescript
import { ActOptions } from '@wuying-org/agentbay-sdk';

// Use PageUseAgent for natural language actions
const actResult = await session.browser.agent.actAsync(
  new ActOptions({ action: "Click the sign in button" }),
  page
);

if (actResult.success) {
  console.log(`Action completed: ${actResult.message}`);
} else {
  console.log(`Action failed: ${actResult.message}`);
}
```

See the [PageUseAgent documentation](../../../../docs/guides/browser-use/advance-features/page-use-agent.md) for more details.

## Performance Considerations

### Resource Usage

- **Stealth Mode**: Adds overhead for anti-detection measures
- **Fingerprinting**: Randomization has minimal performance impact
- **Proxies**: May add latency depending on proxy location
- **Extensions**: Each extension increases memory usage

### Optimization Tips

1. **Reuse Sessions**: Keep sessions alive for multiple operations
2. **Appropriate Viewport**: Use actual target viewport size
3. **Minimal Extensions**: Only load necessary extensions
4. **Async Operations**: Use `initializeAsync` for better concurrency

## Troubleshooting

### Browser Won't Initialize

```typescript
// Check session status
if (!result.success) {
  console.error(`Session creation failed: ${result.errorMessage}`);
}

// Verify image supports browser
const params = new CreateSessionParams({ imageId: 'browser_latest' });

// Check initialization
const success = await session.browser.initializeAsync(option);
console.log(`Initialization success: ${success}`);
```

### CDP Connection Fails

```typescript
// Ensure browser is initialized
if (!session.browser.isInitialized()) {
  throw new Error("Browser not initialized");
}

// Get and verify endpoint
const endpointUrl = session.browser.getEndpointUrl();
console.log(`Endpoint: ${endpointUrl}`);
```

### Configuration Issues

```typescript
// Check option values
const option = new BrowserOptionClass();
option.browserType = 'chrome';
console.log(`Browser type: ${option.browserType}`);
console.log(`Use stealth: ${option.useStealth}`);

// Type-safe validation
const validOption: BrowserOption = {
  browserType: 'chrome',  // TypeScript ensures valid value
  useStealth: true
};
```

## Type Definitions

### Complete Type Reference

```typescript
// Main interfaces
export interface BrowserOption { /* ... */ }
export interface BrowserViewport { /* ... */ }
export interface BrowserScreen { /* ... */ }
export interface BrowserFingerprint { /* ... */ }
export interface BrowserProxy { /* ... */ }

// Classes
export class BrowserOptionClass implements BrowserOption { /* ... */ }
export class BrowserProxyClass implements BrowserProxy { /* ... */ }

// Browser class
export class Browser {
  initialize(option: BrowserOption | BrowserOptionClass): boolean;
  initializeAsync(option: BrowserOption | BrowserOptionClass): Promise<boolean>;
  getEndpointUrl(): string;
  isInitialized(): boolean;
  getOption(): BrowserOptionClass | null;
  agent: BrowserAgent;
}
```

## See Also

- [Browser Use Guide](../../../../docs/guides/browser-use/README.md) - Complete guide with examples
- [Core Features](../../../../docs/guides/browser-use/core-features.md) - Essential browser features
- [Advanced Features](../../../../docs/guides/browser-use/advance-features.md) - Advanced configuration
- [Browser Examples](../../examples/browser-use/browser/README.md) - Runnable example code
- [PageUseAgent API](../../../../docs/guides/browser-use/advance-features/page-use-agent.md) - AI-powered browser automation
- [Session Management](../common-features/basics/session.md) - Session lifecycle and management





# Extension API Reference

The Extension API provides functionality for managing browser extensions in the AgentBay cloud environment. This enables uploading, managing, and integrating browser extensions with cloud browser sessions for automated testing and development workflows.

## Import

```typescript
import { AgentBay, ExtensionsService, ExtensionOption, Extension } from "wuying-agentbay-sdk";
import { CreateSessionParams, BrowserContext } from "wuying-agentbay-sdk";
```

## Extension Class

The `Extension` class represents a browser extension in the AgentBay cloud environment.

### Properties

```typescript
id: string          // The unique identifier of the extension (auto-generated)
name: string        // The name of the extension (typically filename)
createdAt?: string  // Date and time when the extension was uploaded (optional)
```

### Constructor

```typescript
constructor(id: string, name: string, createdAt?: string)
```

**Parameters:**
- `id` (string): Unique extension identifier
- `name` (string): Extension name
- `createdAt` (string, optional): Creation timestamp

**Example:**
```typescript
const extension = new Extension('ext_123abc', 'my-extension.zip', '2023-01-01T10:00:00Z');
console.log(extension.id); // 'ext_123abc'
console.log(extension.name); // 'my-extension.zip'
```

## ExtensionOption Class

The `ExtensionOption` class encapsulates extension configuration for browser sessions.

### Properties

```typescript
contextId: string     // The context ID where extensions are stored
extensionIds: string[] // List of extension IDs to include in browser sessions
```

### Constructor

```typescript
constructor(contextId: string, extensionIds: string[])
```

**Parameters:**
- `contextId` (string): ID of the extension context
- `extensionIds` (string[]): List of extension IDs to synchronize

**Throws:**
- `Error`: If contextId is empty or extensionIds is empty

### Methods

#### validate

Validates the extension option configuration.

```typescript
validate(): boolean
```

**Returns:**
- `boolean`: True if configuration is valid, false otherwise

**Example:**
```typescript
const extOption = new ExtensionOption("ctx_123", ["ext_1", "ext_2"]);
if (extOption.validate()) {
    console.log("Configuration is valid");
} else {
    console.log("Invalid configuration");
}
```

#### toString

Returns string representation of ExtensionOption.

```typescript
toString(): string
```

**Example:**
```typescript
const option = new ExtensionOption('ctx_123', ['ext_1', 'ext_2']);
console.log(option.toString()); 
// "ExtensionOption(contextId='ctx_123', extensionIds=["ext_1","ext_2"])"
```

#### toDisplayString

Returns human-readable string representation.

```typescript
toDisplayString(): string
```

**Example:**
```typescript
console.log(option.toDisplayString()); 
// "Extension Config: 2 extension(s) in context 'ctx_123'"
```

## ExtensionsService Class

The `ExtensionsService` class provides methods for managing browser extensions in the AgentBay cloud environment.

### Constructor

```typescript
constructor(agentBay: AgentBay, contextId: string = "")
```

**Parameters:**
- `agentBay` (AgentBay): The AgentBay client instance
- `contextId` (string, optional): Context ID or name. If empty, auto-generates a unique name

**Auto-Context Management:**
- If `contextId` is empty → generates `extensions-{timestamp}` automatically
- If `contextId` exists → uses existing context
- If `contextId` doesn't exist → creates new context with the provided name

### Properties

```typescript
contextId: string     // The actual context ID used for extension storage
contextName: string   // The context name (may be auto-generated)
autoCreated: boolean  // Whether the context was auto-created by this service
```

### Methods

#### create

Uploads a new browser extension to the cloud context.

```typescript
create(localPath: string): Promise<Extension>
```

**Parameters:**
- `localPath` (string): Path to the local extension ZIP file

**Returns:**
- `Promise<Extension>`: Extension object with generated ID and metadata

**Throws:**
- `Error`: If the local file doesn't exist or format is not supported (only ZIP files allowed)
- `AgentBayError`: If upload fails

**Example:**
```typescript
import { AgentBay, ExtensionsService } from "wuying-agentbay-sdk";

// Initialize the SDK
const agentBay = new AgentBay({ apiKey: "your_api_key" });

// Create extensions service
const extensionsService = new ExtensionsService(agentBay);

// Upload extension
const extension = await extensionsService.create("/path/to/my-extension.zip");
console.log(`Extension uploaded: ${extension.name} (ID: ${extension.id})`);
```

#### list

Lists all extensions in the current context.

```typescript
list(): Promise<Extension[]>
```

**Returns:**
- `Promise<Extension[]>`: List of all extensions in the context

**Throws:**
- `AgentBayError`: If listing fails

**Example:**
```typescript
// List all extensions
const extensions = await extensionsService.list();
for (const ext of extensions) {
    console.log(`Extension: ${ext.name} (ID: ${ext.id})`);
}
```

#### update

Updates an existing extension with a new file.

```typescript
update(extensionId: string, newLocalPath: string): Promise<Extension>
```

**Parameters:**
- `extensionId` (string): ID of the extension to update
- `newLocalPath` (string): Path to the new extension ZIP file

**Returns:**
- `Promise<Extension>`: Updated extension object

**Throws:**
- `Error`: If the new local file doesn't exist
- `Error`: If the extension ID doesn't exist in the context
- `AgentBayError`: If update fails

**Example:**
```typescript
// Update existing extension
const updatedExt = await extensionsService.update("ext_123", "/path/to/updated-extension.zip");
console.log(`Extension updated: ${updatedExt.name}`);
```

#### delete

Deletes an extension from the context.

```typescript
delete(extensionId: string): Promise<boolean>
```

**Parameters:**
- `extensionId` (string): ID of the extension to delete

**Returns:**
- `Promise<boolean>`: True if deletion was successful, false otherwise

**Example:**
```typescript
// Delete extension
const success = await extensionsService.delete("ext_123");
if (success) {
    console.log("Extension deleted successfully");
} else {
    console.log("Failed to delete extension");
}
```

#### createExtensionOption

**🎯 Recommended Method** - Creates an ExtensionOption without exposing context_id to users.

```typescript
createExtensionOption(extensionIds: string[]): ExtensionOption
```

**Parameters:**
- `extensionIds` (string[]): List of extension IDs to include

**Returns:**
- `ExtensionOption`: Configuration object for browser extension integration

**Throws:**
- `Error`: If extensionIds is empty

**Key Benefits:**
- ✅ **No context_id needed**: Users only provide extension IDs
- ✅ **Automatic context handling**: Context ID is handled internally
- ✅ **Clean API**: Decouples users from internal context management

**Example:**
```typescript
import { CreateSessionParams, BrowserContext } from "wuying-agentbay-sdk";

// Create extensions
const ext1 = await extensionsService.create("/path/to/ext1.zip");
const ext2 = await extensionsService.create("/path/to/ext2.zip");

// Create extension option (no context_id needed!)
const extOption = extensionsService.createExtensionOption([ext1.id, ext2.id]);

// Use with BrowserContext for session creation
const sessionParams = new CreateSessionParams()
    .withBrowserContext(new BrowserContext(
        "browser_session",
        true,
        extOption
    ));

const sessionResult = await agentBay.create(sessionParams.toJSON());
const session = sessionResult.session;
```

#### cleanup

Cleans up auto-created context if it was created by this service.

```typescript
cleanup(): Promise<boolean>
```

**Returns:**
- `Promise<boolean>`: True if cleanup was successful or not needed, false if cleanup failed

**Note:** Only cleans up contexts that were auto-created by this service instance.

**Example:**
```typescript
try {
    // Use extensions service
    const extensionsService = new ExtensionsService(agentBay);
    // ... extension operations
} finally {
    // Always cleanup resources
    await extensionsService.cleanup();
}
```

## BrowserContext Integration

Browser extensions are integrated with sessions through the `BrowserContext` class from the session parameters.

### BrowserContext Constructor

```typescript
new BrowserContext(
    contextId: string, 
    autoUpload: boolean = true, 
    extensionOption?: ExtensionOption
)
```

**Parameters:**
- `contextId` (string): ID of the browser context for the session
- `autoUpload` (boolean): Whether to automatically upload browser data when session ends
- `extensionOption` (ExtensionOption, optional): Extension configuration object

**Auto-Generated Properties:**

When `extensionOption` is provided:
- `extensionContextId` (string): Extracted from ExtensionOption
- `extensionIds` (string[]): Extracted from ExtensionOption
- `extensionContextSyncs` (ContextSync[]): Auto-generated context syncs

When `extensionOption` is undefined:
- `extensionContextId` = undefined
- `extensionIds` = []
- `extensionContextSyncs` = undefined

## Usage Patterns

### Basic Extension Management

```typescript
import { AgentBay, ExtensionsService } from "wuying-agentbay-sdk";

// Initialize service
const agentBay = new AgentBay({ apiKey: "your_api_key" });
const extensionsService = new ExtensionsService(agentBay);

try {
    // Upload extensions
    const ext1 = await extensionsService.create("/path/to/extension1.zip");
    const ext2 = await extensionsService.create("/path/to/extension2.zip");
    
    // List extensions
    const extensions = await extensionsService.list();
    console.log(`Total extensions: ${extensions.length}`);
    
} finally {
    // Clean up when done
    await extensionsService.cleanup();
}
```

### Browser Session with Extensions

```typescript
import { AgentBay, ExtensionsService } from "wuying-agentbay-sdk";
import { CreateSessionParams, BrowserContext } from "wuying-agentbay-sdk";

// Initialize and upload extensions
const agentBay = new AgentBay({ apiKey: "your_api_key" });
const extensionsService = new ExtensionsService(agentBay);

try {
    const ext1 = await extensionsService.create("/path/to/ext1.zip");
    const ext2 = await extensionsService.create("/path/to/ext2.zip");
    
    // Create extension option (simplified - no context_id needed!)
    const extensionOption = extensionsService.createExtensionOption([ext1.id, ext2.id]);
    
    // Create browser session with extensions
    const sessionParams = new CreateSessionParams()
        .withLabels({ purpose: "extension_testing" })
        .withBrowserContext(new BrowserContext(
            "my_browser_session",
            true,
            extensionOption  // All extension config here
        ));
    
    // Create session
    const sessionResult = await agentBay.create(sessionParams.toJSON());
    const session = sessionResult.session;
    
    // Extensions are automatically synchronized to /tmp/extensions/ in the session
    console.log("Session created with extensions!");
    
} finally {
    await extensionsService.cleanup();
}
```

### Error Handling

```typescript
import { AgentBay, ExtensionsService } from "wuying-agentbay-sdk";
import { AgentBayError } from "wuying-agentbay-sdk";
import * as fs from "fs";

try {
    const agentBay = new AgentBay({ apiKey: "your_api_key" });
    const extensionsService = new ExtensionsService(agentBay, "my_extensions");
    
    // Upload extension with validation
    const extensionPath = "/path/to/my-extension.zip";
    if (!fs.existsSync(extensionPath)) {
        throw new Error(`Extension file not found: ${extensionPath}`);
    }
    
    const extension = await extensionsService.create(extensionPath);
    console.log(`✅ Extension uploaded successfully: ${extension.id}`);
    
    // Create extension option
    const extOption = extensionsService.createExtensionOption([extension.id]);
    
    if (!extOption.validate()) {
        throw new Error("Invalid extension configuration");
    }
    
    console.log(`✅ Extension option created: ${extOption}`);
    
} catch (error) {
    if (error instanceof Error) {
        if (error.message.includes("not found")) {
            console.error(`❌ File error: ${error.message}`);
        } else if (error.message.includes("Invalid")) {
            console.error(`❌ Validation error: ${error.message}`);
        } else {
            console.error(`❌ Unexpected error: ${error.message}`);
        }
    } else if (error instanceof AgentBayError) {
        console.error(`❌ AgentBay error: ${error.message}`);
    } else {
        console.error(`❌ Unknown error: ${error}`);
    }
} finally {
    if (extensionsService) {
        await extensionsService.cleanup();
    }
}
```

## Constants

### EXTENSIONS_BASE_PATH

```typescript
const EXTENSIONS_BASE_PATH = "/tmp/extensions";
```

Base path for storing extensions in cloud storage.

## File Location in Sessions

In browser sessions, extensions are automatically synchronized to:
```
/tmp/extensions/{extension_id}/
```

Each extension gets its own directory containing all extension files, including `manifest.json` and other extension assets.

## File Format Requirements

- **Supported Format**: ZIP files (.zip) only
- **File Structure**: Standard browser extension ZIP structure with manifest.json
- **Size Limits**: Determined by cloud storage limits
- **Naming**: Extension IDs are auto-generated with format `ext_{uuid}.zip`

## Context Management

The service automatically handles context lifecycle:

1. **Context Detection**: Checks if context exists
2. **Context Creation**: Creates context if it doesn't exist
3. **Context Usage**: Uses context for all file operations
4. **Context Cleanup**: Optionally cleans up auto-created contexts

## Error Types

- **AgentBayError**: SDK-specific errors for API/cloud operations
- **Error**: Standard errors for validation and file system issues

## Best Practices

1. **Resource Cleanup**: Always call `cleanup()` for auto-created contexts
2. **Error Handling**: Wrap operations in try-catch blocks
3. **Validation**: Validate ExtensionOption before use
4. **File Existence**: Ensure extension files exist before upload
5. **Context Naming**: Use descriptive context names for management
6. **Use Recommended API**: Prefer `createExtensionOption()` over manual ExtensionOption creation

## Related Resources

- [Session API Reference](../common-features/basics/session.md)
- [Context API Reference](../common-features/basics/context.md) 
- [AgentBay API Reference](../common-features/basics/agentbay.md)
- [Extension Examples](../../examples/browser-use/extension-example/README.md) - Practical usage examples
- [Browser Extensions Guide](../../../../docs/guides/browser-use/browser-extensions.md) - Complete tutorial



# Code Module - TypeScript

The Code module handles code execution operations in the AgentBay cloud environment.

## 📖 Related Tutorial

- [Code Execution Guide](../../../../docs/guides/codespace/code-execution.md) - Detailed tutorial on executing code in cloud environments

## Methods

### runCode

Executes code in a specified programming language with a timeout.

```typescript
runCode(code: string, language: string, timeoutS: number = 60): Promise<CodeExecutionResult>
```

**Parameters:**
- `code` (string): The code to execute.
- `language` (string): The programming language of the code. Must be either 'python' or 'javascript'.
- `timeoutS` (number, optional): The timeout for the code execution in seconds. Default is 60s. Note: Due to gateway limitations, each request cannot exceed 60 seconds.

**Returns:**
- `Promise<CodeExecutionResult>`: A promise that resolves to a result object containing success status, execution result, error message if any, and request ID.

**Important Note:**
The `runCode` method requires a session created with the `code_latest` image to function properly. If you encounter errors indicating that the tool is not found, make sure to create your session with `imageId: "code_latest"` in the session creation parameters.

**Usage Example:**

```typescript
import { AgentBay } from 'wuying-agentbay-sdk';

async function main() {
    // Initialize AgentBay with API key
    const apiKey = process.env.AGENTBAY_API_KEY!;
    const agentBay = new AgentBay({ apiKey });

    // Create a session with code_latest image
    const sessionResult = await agentBay.create({
        imageId: "code_latest"
    });
    if (!sessionResult.success) {
        console.error(`Failed to create session: ${sessionResult.errorMessage}`);
        return;
    }
    const session = sessionResult.session;

    // Execute Python code
    const pythonCode = `
print("Hello from Python!")
result = 2 + 3
print(f"Result: {result}")
`;

    const codeResult = await session.code.runCode(pythonCode, "python");
    if (codeResult.success) {
        console.log(`Python code output:\n${codeResult.result}`);
        // Expected output:
        // Hello from Python!
        // Result: 5
        console.log(`Request ID: ${codeResult.requestId}`);
        // Expected: A valid UUID-format request ID
    } else {
        console.error(`Code execution failed: ${codeResult.errorMessage}`);
    }

    // Execute JavaScript code
    const jsCode = `
console.log("Hello from JavaScript!");
const result = 2 + 3;
console.log("Result:", result);
`;

    const jsResult = await session.code.runCode(jsCode, "javascript", 30);
    if (jsResult.success) {
        console.log(`JavaScript code output:\n${jsResult.result}`);
        // Expected output:
        // Hello from JavaScript!
        // Result: 5
        console.log(`Request ID: ${jsResult.requestId}`);
        // Expected: A valid UUID-format request ID
    } else {
        console.error(`Code execution failed: ${jsResult.errorMessage}`);
    }
}

main().catch(console.error);
```

## Error Handling

The runCode method returns a CodeExecutionResult with `success: false` if:
- The specified language is not supported (only 'python' and 'javascript' are supported)
- The code execution fails in the cloud environment
- Network or API communication errors occur

In these cases, the `errorMessage` field will contain details about the failure.

## Types

### CodeExecutionResult

```typescript
interface CodeExecutionResult {
    requestId: string;      // Unique identifier for the API request
    success: boolean;       // Whether the operation was successful
    result: string;         // The execution result/output
    errorMessage?: string;  // Error message if the operation failed
}
``` 



# Agent Class API Reference

The `Agent` class provides AI-powered capabilities for executing tasks, checking task status, and terminating tasks within a session. It enables natural language task execution and monitoring.

**⚠️ Important Note**: The Agent functionality is verified on the `windows_latest` system image.

## 📖 Related Tutorial

- [Agent Modules Guide](../../../../../docs/guides/common-features/advanced/agent-modules.md) - Detailed tutorial on AI-powered automation with Agent modules

## Constructor

### new Agent()

```typescript
constructor(session: McpSession)
```

**Parameters:**
- `session` (McpSession): The Session instance that this Agent belongs to.

## Methods

### executeTask

Executes a specific task described in human language.

```typescript
executeTask(task: string, maxTryTimes: number): Promise<ExecutionResult>
```

**Parameters:**
- `task` (string): Task description in human language.
- `maxTryTimes` (number): Maximum number of retry attempts.

**Returns:**
- `Promise<ExecutionResult>`: A promise that resolves to a result object containing success status, task ID, task status, and error message if any.

**Example:**
```typescript
import { AgentBay } from 'wuying-agentbay-sdk';

// Initialize the SDK
const agentBay = new AgentBay({ apiKey: 'your_api_key' });

// Create a session with Windows image (required for Agent functionality)
async function executeAgentTask() {
  try {
    const params = { imageId: "windows_latest" };
    const createResult = await agentBay.create(params);
    if (createResult.success) {
      const session = createResult.session;
      console.log(`Session created successfully with ID: ${session.getSessionId()}`);

      // Execute a task using the Agent
      const taskDescription = "Find the current weather in New York City";
      const executionResult = await session.agent.executeTask(taskDescription, 10);

      if (executionResult.success) {
        console.log(`Task completed successfully with status: ${executionResult.taskStatus}`);
        console.log(`Task ID: ${executionResult.taskId}`);
      } else {
        console.log(`Task failed: ${executionResult.errorMessage}`);
        // If we have a task ID, we can try to get more detailed status
        if (executionResult.taskId) {
          const statusResult = await session.agent.getTaskStatus(executionResult.taskId);
          if (statusResult.success) {
            console.log(`Task status details: ${statusResult.output}`);
          }
        }
      }
    } else {
      console.log(`Failed to create session: ${createResult.errorMessage}`);
    }
  } catch (error) {
    console.error('Error:', error);
  }
}

executeAgentTask();
```

### getTaskStatus

Gets the status of the task with the given task ID.

```typescript
getTaskStatus(taskId: string): Promise<QueryResult>
```

**Parameters:**
- `taskId` (string): Task ID

**Returns:**
- `Promise<QueryResult>`: A promise that resolves to a result object containing success status, output, and error message if any.

**Example:**
```typescript
// Get the status of a specific task
async function checkTaskStatus(taskId: string) {
  try {
    const statusResult = await session.agent.getTaskStatus(taskId);
    
    if (statusResult.success) {
      console.log(`Task output: ${statusResult.output}`);
    } else {
      console.log(`Failed to get task status: ${statusResult.errorMessage}`);
    }
  } catch (error) {
    console.error('Error:', error);
  }
}

checkTaskStatus("task_12345");
```

### terminateTask

Terminates a task with a specified task ID.

```typescript
terminateTask(taskId: string): Promise<ExecutionResult>
```

**Parameters:**
- `taskId` (string): The ID of the running task.

**Returns:**
- `Promise<ExecutionResult>`: A promise that resolves to a result object containing success status, task ID, task status, and error message if any.

**Example:**
```typescript
// Terminate a running task
async function terminateAgentTask(taskId: string) {
  try {
    const terminateResult = await session.agent.terminateTask(taskId);
    
    if (terminateResult.success) {
      console.log(`Task terminated successfully with status: ${terminateResult.taskStatus}`);
    } else {
      console.log(`Failed to terminate task: ${terminateResult.errorMessage}`);
    }
  } catch (error) {
    console.error('Error:', error);
  }
}

terminateAgentTask("task_12345");
```



# OSS API Reference

The OSS (Object Storage Service) module provides functionality for interacting with cloud storage services.

## 📖 Related Tutorial

- [OSS Integration Guide](../../../../../docs/guides/common-features/advanced/oss-integration.md) - Detailed tutorial on integrating with Object Storage Service

## OSS Class

The `OSS` class provides methods for OSS operations.

### envInit

Initializes OSS environment variables with the specified credentials.

```typescript
async envInit(
  accessKeyId: string,
  accessKeySecret: string,
  securityToken: string,
  endpoint?: string,
  region?: string
): Promise<OSSClientResult>
```

**Parameters:**
- `accessKeyId`: The Access Key ID for OSS authentication.
- `accessKeySecret`: The Access Key Secret for OSS authentication.
- `securityToken`: The security token for OSS authentication.
- `endpoint`: The OSS service endpoint. If not specified, the default is used.
- `region`: The OSS region. If not specified, the default is used.

**Returns:**
- `Promise<OSSClientResult>`: Result object containing client configuration, request ID, success status, and error message if any.

**Throws:**
- `APIError`: If the environment initialization fails.

**Example:**
```typescript
import { AgentBay } from 'wuying-agentbay-sdk';

// Initialize the SDK
const agentBay = new AgentBay({ apiKey: 'your_api_key' });

// Initialize OSS environment
async function initializeOSS() {
  try {
    const result = await agentBay.oss.envInit(
      'your_access_key_id',
      'your_access_key_secret',
      'your_security_token',
      'oss-cn-hangzhou.aliyuncs.com',
      'cn-hangzhou'
    );
    console.log('OSS environment initialized successfully:', result);
  } catch (error) {
    console.error('Error initializing OSS environment:', error);
  }
}

initializeOSS();
```


### upload

**Note:** Before calling this API, you must call `envInit` to initialize the OSS environment.

Uploads a local file or directory to OSS.

```typescript
async upload(bucket: string, object: string, path: string): Promise<string>
```

**Parameters:**
- `bucket`: OSS bucket name.
- `object`: Object key in OSS.
- `path`: Local file or directory path to upload.

**Returns:**
- `Promise<string>`: The result of the upload operation.

**Throws:**
- `APIError`: If the upload fails.

**Example:**
```typescript
import { AgentBay } from 'wuying-agentbay-sdk';

// Initialize the SDK
const agentBay = new AgentBay({ apiKey: 'your_api_key' });

async function uploadFile() {
  try {
    // Step 1: Initialize OSS environment
    await agentBay.oss.envInit(
      'your_access_key_id',
      'your_access_key_secret',
      'your_security_token',
      'oss-cn-hangzhou.aliyuncs.com',
      'cn-hangzhou'
    );
    // Step 2: Upload file to OSS
    const result = await agentBay.oss.upload('my-bucket', 'my-object', '/path/to/local/file');
    console.log('File uploaded successfully:', result);
  } catch (error) {
    console.error('Error uploading file:', error);
  }
}

uploadFile();
```

### uploadAnonymous

**Note:** Before calling this API, you must call `envInit` to initialize the OSS environment.

Uploads a local file or directory to a URL anonymously.

```typescript
async uploadAnonymous(url: string, path: string): Promise<string>
```

**Parameters:**
- `url`: The HTTP/HTTPS URL to upload the file to.
- `path`: Local file or directory path to upload.

**Returns:**
- `Promise<string>`: The result of the upload operation.

**Throws:**
- `APIError`: If the upload fails.

**Example:**
```typescript
import { AgentBay } from 'wuying-agentbay-sdk';

// Initialize the SDK
const agentBay = new AgentBay({ apiKey: 'your_api_key' });

async function uploadFileAnonymously() {
  try {
    // Step 1: Initialize OSS environment
    await agentBay.oss.envInit(
      'your_access_key_id',
      'your_access_key_secret',
      'your_security_token',
      'oss-cn-hangzhou.aliyuncs.com',
      'cn-hangzhou'
    );
    // Step 2: Upload file anonymously
    const result = await agentBay.oss.uploadAnonymous('https://example.com/upload', '/path/to/local/file');
    console.log('File uploaded anonymously successfully:', result);
  } catch (error) {
    console.error('Error uploading file anonymously:', error);
  }
}

uploadFileAnonymously();
```

### download

**Note:** Before calling this API, you must call `envInit` to initialize the OSS environment.

Downloads an object from OSS to a local file.

```typescript
async download(bucket: string, object: string, path: string): Promise<string>
```

**Parameters:**
- `bucket`: OSS bucket name.
- `object`: Object key in OSS.
- `path`: Local path to save the downloaded file.

**Returns:**
- `Promise<string>`: The result of the download operation.

**Throws:**
- `APIError`: If the download fails.

**Example:**
```typescript
import { AgentBay } from 'wuying-agentbay-sdk';

// Initialize the SDK
const agentBay = new AgentBay({ apiKey: 'your_api_key' });

async function downloadFile() {
  try {
    // Step 1: Initialize OSS environment
    await agentBay.oss.envInit(
      'your_access_key_id',
      'your_access_key_secret',
      'your_security_token',
      'oss-cn-hangzhou.aliyuncs.com',
      'cn-hangzhou'
    );
    // Step 2: Download file from OSS
    const result = await agentBay.oss.download('my-bucket', 'my-object', '/path/to/local/file');
    console.log('File downloaded successfully:', result);
  } catch (error) {
    console.error('Error downloading file:', error);
  }
}

downloadFile();
```

### downloadAnonymous

**Note:** Before calling this API, you must call `envInit` to initialize the OSS environment.

Downloads a file from a URL anonymously to a local file.

```typescript
async downloadAnonymous(url: string, path: string): Promise<string>
```

**Parameters:**
- `url`: The HTTP/HTTPS URL to download the file from.
- `path`: The full local file path to save the downloaded file.

**Returns:**
- `Promise<string>`: The result of the download operation.

**Throws:**
- `APIError`: If the download fails.

**Example:**
```typescript
import { AgentBay } from 'wuying-agentbay-sdk';

// Initialize the SDK
const agentBay = new AgentBay({ apiKey: 'your_api_key' });

async function downloadFileAnonymously() {
  try {
    // Step 1: Initialize OSS environment
    await agentBay.oss.envInit(
      'your_access_key_id',
      'your_access_key_secret',
      'your_security_token',
      'oss-cn-hangzhou.aliyuncs.com',
      'cn-hangzhou'
    );
    // Step 2: Download file anonymously
    const result = await agentBay.oss.downloadAnonymous('https://example.com/file.txt', '/path/to/local/file.txt');
    console.log('File downloaded anonymously successfully:', result);
  } catch (error) {
    console.error('Error downloading file anonymously:', error);
  }
}

downloadFileAnonymously();
```

## Related Resources

- [Filesystem API Reference](../basics/filesystem.md)
- [Session API Reference](../basics/session.md)



# AgentBay Class API Reference

The `AgentBay` class is the main entry point for interacting with the AgentBay cloud environment. It provides methods for creating, retrieving, listing, and deleting sessions.

## 📖 Related Tutorials

- [SDK Configuration Guide](../../../../../docs/guides/common-features/configuration/sdk-configuration.md) - Detailed tutorial on configuring the SDK
- [VPC Sessions Guide](../../../../../docs/guides/common-features/advanced/vpc-sessions.md) - Tutorial on creating sessions in VPC environments
- [Session Link Access Guide](../../../../../docs/guides/common-features/advanced/session-link-access.md) - Tutorial on accessing sessions via links

## Constructor

### new AgentBay()

```typescript
constructor(options: { apiKey?: string; config?: Config } = {})
```

**Parameters:**
- `options` (object): Configuration options object
  - `apiKey` (string, optional): The API key for authentication. If not provided, the SDK will look for the `AGENTBAY_API_KEY` environment variable.
  - `config` (Config, optional): Custom configuration object containing endpoint and timeout_ms. If not provided, default configuration is used.

**Throws:**
- `Error`: If no API key is provided and `AGENTBAY_API_KEY` environment variable is not set.

## Properties

### context

A `ContextService` instance for managing persistent contexts. See the [Context API Reference](context.md) for more details.

## Methods


Creates a new session in the AgentBay cloud environment.


```typescript
create(params?: CreateSessionParams): Promise<SessionResult>
```

**Parameters:**
- `params` (CreateSessionParams, optional): Parameters for session creation.

**Returns:**
- `Promise<SessionResult>`: A promise that resolves to a result object containing the new Session instance, success status, request ID, and error message if any.

**Behavior:**
- When `params` includes valid `PersistenceDataList`, after creating the session, the API will check `session.context.info` to retrieve ContextStatusData.
- It will continuously monitor all data items' Status in ContextStatusData until all items show either "Success" or "Failed" status, or until the maximum retry limit (150 times with 2-second intervals) is reached.
- Any "Failed" status items will have their error messages printed.
- The Create operation only returns after context status checking completes.

**Throws:**
- `Error`: If the session creation fails.

**Example:**
```typescript
import { AgentBay, CreateSessionParams } from 'wuying-agentbay-sdk';
import { ContextSync, SyncPolicy } from 'wuying-agentbay-sdk/context-sync';

// Initialize the SDK with default configuration
const agentBay = new AgentBay({ apiKey: 'your_api_key' });

// Or initialize with custom configuration
const agentBayWithConfig = new AgentBay({
  apiKey: 'your_api_key',
  config: {
    endpoint: 'https://agentbay.example.com',
    timeout_ms: 30000
  }
});

// Create a session with default parameters
async function createDefaultSession() {
  const result = await agentBay.create();
  if (result.success) {
    console.log(`Created session with ID: ${result.session.sessionId}`);
    return result.session;
  }
  throw new Error(`Failed to create session: ${result.errorMessage}`);
}

// Create a session with custom parameters
async function createCustomSession() {
  const params: CreateSessionParams = {
    imageId: 'linux_latest',
    labels: { project: 'demo', environment: 'testing' }
  };
  
  const result = await agentBay.create(params);
  if (result.success) {
    console.log(`Created custom session with ID: ${result.session.sessionId}`);
    return result.session;
  }
  throw new Error(`Failed to create session: ${result.errorMessage}`);
}

// Create a mobile session with extra configurations
async function createMobileSession() {
  import { MobileExtraConfig, AppManagerRule, ExtraConfigs } from 'wuying-agentbay-sdk';
  
  const appRule: AppManagerRule = {
    ruleType: "White",
    appPackageNameList: [
      "com.android.settings",
      "com.example.trusted.app",
      "com.system.essential.service"
    ]
  };

  const mobileConfig: MobileExtraConfig = {
    lockResolution: true,  // Lock screen resolution for consistent testing
    appManagerRule: appRule,
    hideNavigationBar: true,  // Hide navigation bar for immersive experience
    uninstallBlacklist: [  // Protect critical apps from uninstallation
      "com.android.systemui",
      "com.android.settings",
      "com.google.android.gms"
    ]
  };

  const extraConfigs: ExtraConfigs = { mobile: mobileConfig };

  const params = new CreateSessionParams()
    .withImageId("mobile_latest")
    .withLabels({ project: "mobile-testing", config_type: "whitelist" })
    .withExtraConfigs(extraConfigs);

  const result = await agentBay.create(params);
  if (result.success) {
    console.log(`Created mobile session with extra configs: ${result.session.sessionId}`);
    return result.session;
  }
  throw new Error(`Failed to create mobile session: ${result.errorMessage}`);
}

// Create a mobile session with blacklist configuration
async function createMobileSessionWithBlacklist() {
  const appRule: AppManagerRule = {
    ruleType: "Black",
    appPackageNameList: [
      "com.malware.suspicious",
      "com.unwanted.adware",
      "com.social.distraction"
    ]
  };

  const mobileSecurityConfig: MobileExtraConfig = {
    lockResolution: false,  // Allow adaptive resolution
    appManagerRule: appRule,
    hideNavigationBar: false,  // Show navigation bar (default behavior)
    uninstallBlacklist: ["com.android.systemui"]  // Protect system UI from uninstallation
  };

  const extraConfigs: ExtraConfigs = { mobile: mobileSecurityConfig };

  const params = new CreateSessionParams()
    .withImageId("mobile_latest")
    .withLabels({ project: "mobile-security", config_type: "blacklist", security: "enabled" })
    .withExtraConfigs(extraConfigs);

  const result = await agentBay.create(params);
  if (result.success) {
    console.log(`Created secure mobile session with blacklist: ${result.session.sessionId}`);
    return result.session;
  }
  throw new Error(`Failed to create secure mobile session: ${result.errorMessage}`);
}

// RECOMMENDED: Create a session with context synchronization
async function createSessionWithSync() {
  const contextSync = new ContextSync({
    contextId: 'your_context_id',
    path: '/mnt/persistent',
    policy: SyncPolicy.default()
  });
  
  const params: CreateSessionParams = {
    imageId: 'linux_latest',
    contextSync: [contextSync]
  };
  
  const result = await agentBay.create(params);
  if (result.success) {
    console.log(`Created session with context sync: ${result.session.sessionId}`);
    return result.session;
  }
  throw new Error(`Failed to create session: ${result.errorMessage}`);
}
```

### get

Retrieves a session by its ID.

```typescript
get(sessionId: string): Promise<SessionResult>
```

**Parameters:**
- `sessionId` (string): The ID of the session to retrieve.

**Returns:**
- `Promise<SessionResult>`: A promise that resolves to a result object containing the Session instance, request ID, success status, and error message if any.

**Example:**
```typescript
import { AgentBay } from 'wuying-agentbay-sdk';

async function getSessionExample() {
  const agentBay = new AgentBay({ apiKey: 'your_api_key' });

  const createResult = await agentBay.create();
  if (!createResult.success) {
    console.error(`Failed to create session: ${createResult.errorMessage}`);
    return;
  }

  const sessionId = createResult.session.sessionId;
  console.log(`Created session with ID: ${sessionId}`);
  // Output: Created session with ID: session-xxxxxxxxxxxxxx

  const result = await agentBay.get(sessionId);
  if (result.success) {
    console.log(`Successfully retrieved session: ${result.session.sessionId}`);
    // Output: Successfully retrieved session: session-xxxxxxxxxxxxxx
    console.log(`Request ID: ${result.requestId}`);
    // Output: Request ID: XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
    
    const deleteResult = await result.session.delete();
    if (deleteResult.success) {
      console.log(`Session ${sessionId} deleted successfully`);
      // Output: Session session-xxxxxxxxxxxxxx deleted successfully
    }
  } else {
    console.error(`Failed to get session: ${result.errorMessage}`);
  }
}

getSessionExample();
```


```typescript
listByLabels(params?: ListSessionParams): Promise<SessionListResult>
```

**Parameters:**
- `params` (ListSessionParams, optional): Parameters including labels and pagination options. If not provided, defaults will be used (labels `{}`, maxResults `10`).

**Returns:**
- `Promise<SessionListResult>`: A promise that resolves to a result object containing the filtered sessions, pagination information, and request ID.

**Throws:**
- `Error`: If the session listing fails.

**Example:**
```typescript
import { AgentBay, ListSessionParams } from 'wuying-agentbay-sdk';

// Initialize the SDK
const agentBay = new AgentBay({ apiKey: 'your_api_key' });

// List sessions by labels with pagination
async function listSessionsByLabels() {
  // Create pagination parameters
  const params: ListSessionParams = {
    maxResults: 10,  // Maximum results per page
    nextToken: '',   // Token for the next page, empty for the first page
    labels: { environment: 'production', project: 'demo' }  // Filter labels
  };
  
  // Get the first page of results
  const result = await agentBay.listByLabels(params);
  
  // Process the results
  if (result.success) {
    // Print the current page sessions
    console.log(`Found ${result.data.length} sessions:`);
    result.data.forEach(session => {
      console.log(`Session ID: ${session.sessionId}`);
    });
    
    // Print pagination information
    console.log(`Total count: ${result.totalCount}`);
    console.log(`Max results per page: ${result.maxResults}`);
    console.log(`Next token: ${result.nextToken}`);
    
    // If there is a next page, retrieve it
    if (result.nextToken) {
      const nextParams = {
        ...params,
        nextToken: result.nextToken
      };
      const nextPageResult = await agentBay.listByLabels(nextParams);
      // Process the next page...
    }
  }
}

listSessionsByLabels();
```

### list

Returns paginated list of Sessions filtered by labels.

```typescript
list(labels?: Record<string, string>, page?: number, limit?: number): Promise<SessionListResult>
```

**Parameters:**
- `labels` (Record<string, string>, optional): Labels to filter Sessions. Defaults to empty object (returns all sessions).
- `page` (number, optional): Page number for pagination (starting from 1). Defaults to undefined (returns first page).
- `limit` (number, optional): Maximum number of items per page. Defaults to 10.

**Returns:**
- `Promise<SessionListResult>`: A promise that resolves to a paginated list of session IDs that match the labels, including requestId, success status, and pagination information.

**Key Features:**
- **Simple Interface**: Pass labels directly as an object parameter
- **Pagination Support**: Use `page` and `limit` parameters for easy pagination
- **Request ID**: All responses include a `requestId` for tracking and debugging
- **Flexible Filtering**: Filter by any combination of labels or list all sessions

**Example:**
```typescript
import { AgentBay } from 'wuying-agentbay-sdk';

const agentBay = new AgentBay('your_api_key');

async function listSessions() {
  // List all sessions
  let result = await agentBay.list();

  // List sessions with specific labels
  result = await agentBay.list({ project: 'demo' });

  // List sessions with pagination (page 2, 10 items per page)
  result = await agentBay.list({ 'my-label': 'my-value' }, 2, 10);

  if (result.success) {
    for (const sessionId of result.sessionIds) {
      console.log(`Session ID: ${sessionId}`);
    }
    console.log(`Total count: ${result.totalCount}`);
    console.log(`Request ID: ${result.requestId}`);
  } else {
    console.error(`Error: ${result.errorMessage}`);
  }
}

listSessions();
```

### delete

```typescript
delete(session: Session, syncContext?: boolean): Promise<DeleteResult>
```

**Parameters:**
- `session` (Session): The session to delete.
- `syncContext` (boolean, optional): If true, the API will trigger a file upload via `session.context.sync` before actually releasing the session. Default is false.

**Returns:**
- `Promise<DeleteResult>`: A promise that resolves to a result object containing success status, request ID, and error message if any.

**Behavior:**
- When `syncContext` is true, the API will first call `session.context.sync` to trigger file upload.
- It will then check `session.context.info` to retrieve ContextStatusData and monitor all data items' Status.
- The API waits until all items show either "Success" or "Failed" status, or until the maximum retry limit (150 times with 2-second intervals) is reached.
- Any "Failed" status items will have their error messages printed.
- The session deletion only proceeds after context sync status checking completes.

**Throws:**
- `Error`: If the session deletion fails.

**Example:**
```typescript
import { AgentBay } from 'wuying-agentbay-sdk';

// Initialize the SDK
const agentBay = new AgentBay({ apiKey: 'your_api_key' });

// Create and delete a session
async function createAndDeleteSession() {
  try {
    // Create a session
    const createResult = await agentBay.create();
    if (createResult.success) {
      const session = createResult.session;
      console.log(`Created session with ID: ${session.sessionId}`);
      
      // Use the session for operations...
      
      // Delete the session when done
      const deleteResult = await agentBay.delete(session);
      if (deleteResult.success) {
        console.log('Session deleted successfully');
      } else {
        console.log(`Failed to delete session: ${deleteResult.errorMessage}`);
      }
    }
  } catch (error) {
    console.error('Error:', error);
  }
}

createAndDeleteSession();
```




# Command Class API Reference

The `Command` class provides methods for executing commands within a session in the AgentBay cloud environment.

## 📖 Related Tutorial

- [Command Execution Guide](../../../../../docs/guides/common-features/basics/command-execution.md) - Detailed tutorial on executing shell commands

## Methods

### executeCommand

Executes a shell command in the cloud environment.

```typescript
executeCommand(command: string, timeoutMs: number = 1000): Promise<CommandResult>
```

**Parameters:**
- `command` (string): The command to execute.
- `timeoutMs` (number, optional): The timeout for the command execution in milliseconds. Default is 1000ms.

**Returns:**
- `Promise<CommandResult>`: A promise that resolves to a result object containing the command output, success status, and request ID.

**CommandResult Interface:**
```typescript
interface CommandResult {
    requestId: string;      // Unique identifier for the API request
    success: boolean;       // Whether the operation was successful
    output: string;         // The command output (stdout)
    errorMessage?: string;  // Error message if the operation failed
}
```

**Note:** The `output` field contains the standard output (stdout) of the executed command. Error output (stderr) is typically included in the `errorMessage` field when the command fails.

**Usage Example:**

```typescript
import { AgentBay } from 'wuying-agentbay-sdk';

async function main() {
    // Initialize AgentBay with API key
    const apiKey = process.env.AGENTBAY_API_KEY!;
    const ab = new AgentBay({ apiKey });

    // Create a session
    const sessionResult = await ab.create();
    const session = sessionResult.session;

    try {
        // Execute a command with default timeout (1000ms)
        const result = await session.command.executeCommand("ls -la");
        if (result.success) {
            console.log(`Command output:\n${result.output}`);
            // Expected output: Directory listing showing files and folders
            console.log(`Request ID: ${result.requestId}`);
            // Expected: A valid UUID-format request ID
        } else {
            console.error(`Command execution failed: ${result.errorMessage}`);
        }

        // Execute a command with custom timeout (5000ms)
        const resultWithTimeout = await session.command.executeCommand(
            "sleep 2 && echo 'Done'", 
            5000
        );
        if (resultWithTimeout.success) {
            console.log(`Command output: ${resultWithTimeout.output}`);
            // Expected output: "Done\n"
            // The command waits 2 seconds then outputs "Done"
        } else {
            console.error(`Command execution failed: ${resultWithTimeout.errorMessage}`);
        }

        // Note: If a command exceeds its timeout, it will return an error
        // Example: await session.command.executeCommand("sleep 3", 1000)
        // Returns error in errorMessage field
    } catch (error) {
        console.error('Error:', error);
    }
}

main().catch(console.error);
```

## Related Resources

- [Session Class](session.md): The session class that provides access to the Command class.
- [Code Class](../../codespace/code.md): For executing Python and JavaScript code.
- [FileSystem Class](filesystem.md): Provides methods for file operations within a session.





# ContextManager API Reference

The `ContextManager` class provides functionality for managing contexts within a session. It enables you to interact with the contexts that are synchronized to the session, including reading and writing data, and managing file operations.

## 📖 Related Tutorial

- [Data Persistence Guide](../../../../../docs/guides/common-features/basics/data-persistence.md) - Detailed tutorial on context management and data persistence

## Overview

The `ContextManager` is accessed through a session instance (`session.context`) and provides functionality for managing contexts within that session.

## Data Types

```typescript
interface ContextStatusData {
  contextId: string;     // The ID of the context
  path: string;          // The path where the context is mounted
  errorMessage: string;  // Error message if the operation failed
  status: string;        // Status of the synchronization task
  startTime: number;     // Start time of the task (Unix timestamp)
  finishTime: number;    // Finish time of the task (Unix timestamp)
  taskType: string;      // Type of the task (e.g., "upload", "download")
}
```

## Result Types

```typescript
interface ContextInfoResult extends ApiResponse {
  requestId: string;  // The request ID
  contextStatusData: ContextStatusData[];  // Array of context status data objects
}
```

```typescript
interface ContextSyncResult extends ApiResponse {
  requestId: string;  // The request ID
  success: boolean;   // Indicates whether the synchronization was successful
}
```

## Methods

### info

Gets information about context synchronization status for the current session.

```typescript
info(): Promise<ContextInfoResult>
```

**Returns:**
- `Promise<ContextInfoResult>`: A promise that resolves to a result object containing the context status data and request ID.

**Example:**
```typescript
import { AgentBay } from 'wuying-agentbay-sdk';

// Initialize the SDK
const agentBay = new AgentBay({ apiKey: 'your_api_key' });

// Create a session and get context info
async function getContextInfo() {
  try {
    // Create a session
    const result = await agentBay.create();
    if (result.success) {
      const session = result.session;
      
      try {
        // Get context synchronization information
        const infoResult = await session.context.info();
        console.log(`Request ID: ${infoResult.requestId}`);
        console.log(`Context status data count: ${infoResult.contextStatusData.length}`);
        
        if (infoResult.contextStatusData.length > 0) {
          infoResult.contextStatusData.forEach(item => {
            console.log(`  Context ${item.contextId}: Status=${item.status}, ` +
                       `Path=${item.path}, TaskType=${item.taskType}`);
          });
        } else {
          console.log('No context synchronization tasks found');
        }
      } finally {
        await session.delete();
      }
    }
  } catch (error) {
    console.error('Error:', error);
  }
}

getContextInfo();

// Expected output:
// Request ID: 41FC3D61-4AFB-1D2E-A08E-5737B2313234
// Context status data count: 0
// No context synchronization tasks found
```

### infoWithParams

Gets information about context synchronization status with optional filter parameters.

```typescript
infoWithParams(contextId?: string, path?: string, taskType?: string): Promise<ContextInfoResult>
```

**Parameters:**
- `contextId` (string, optional): The ID of the context to get information for.
- `path` (string, optional): The path where the context is mounted.
- `taskType` (string, optional): The type of task to get information for (e.g., "upload", "download").

**Returns:**
- `Promise<ContextInfoResult>`: A promise that resolves to a result object containing the context status data and request ID.

**Example:**
```typescript
// Get info for a specific context and path
const infoResult = await session.context.infoWithParams(
  'SdkCtx-04bdw8o39bq47rv1t',
  '/mnt/persistent'
);

console.log(`Request ID: ${infoResult.requestId}`);
infoResult.contextStatusData.forEach(item => {
  console.log(`  Context ${item.contextId}: Status=${item.status}`);
});

// Expected output when no sync tasks are found:
// Request ID: EB18A2D5-3C51-1F50-9FF1-8543CA328772
```

### sync

Synchronizes a context with the session. This method supports two modes:
- **Async mode (default)**: When called without a callback, it waits for the sync operation to complete.
- **Callback mode**: When a callback is provided, it returns immediately and calls the callback when complete.

```typescript
sync(
  contextId?: string,
  path?: string,
  mode?: string,
  callback?: SyncCallback,
  maxRetries?: number,
  retryInterval?: number
): Promise<ContextSyncResult>
```

**Parameters:**
- `contextId` (string, optional): The ID of the context to synchronize.
- `path` (string, optional): The path where the context should be mounted.
- `mode` (string, optional): The synchronization mode (e.g., "upload", "download").
- `callback` (SyncCallback, optional): Optional callback function `(success: boolean) => void`. If provided, the method runs in background and calls callback when complete.
- `maxRetries` (number, optional): Maximum number of retries for polling completion status. Default: 150.
- `retryInterval` (number, optional): Milliseconds to wait between retries. Default: 1500.

**Returns:**
- `Promise<ContextSyncResult>`: A promise that resolves to a result object containing success status and request ID.

**Example (Async mode - waits for completion):**
```typescript
import { AgentBay } from 'wuying-agentbay-sdk';

// Initialize the SDK
const agentBay = new AgentBay({ apiKey: 'your_api_key' });

// Synchronize context and wait for completion
async function syncContextExample() {
  try {
    // Create a session
    const result = await agentBay.create();
    if (result.success) {
      const session = result.session;
      
      try {
        // Get or create a context
        const contextResult = await agentBay.context.get('my-context', true);
        if (contextResult.context) {
          // Trigger context synchronization and wait for completion
          const syncResult = await session.context.sync(
            contextResult.context.id,
            '/mnt/persistent',
            'upload'
          );
          
          console.log(`Sync completed - Success: ${syncResult.success}`);
          console.log(`Request ID: ${syncResult.requestId}`);
        }
      } finally {
        await session.delete();
      }
    }
  } catch (error) {
    console.error('Error:', error);
  }
}

syncContextExample();

// Expected output:
// Sync completed - Success: true
// Request ID: 39B00280-B9DA-17D1-BCBB-9C577E057F0A
```

**Example (Callback mode - returns immediately):**
```typescript
import { AgentBay } from 'wuying-agentbay-sdk';

const agentBay = new AgentBay({ apiKey: 'your_api_key' });

async function syncWithCallbackExample() {
  try {
    const result = await agentBay.create();
    if (result.success) {
      const session = result.session;
      
      try {
        const contextResult = await agentBay.context.get('my-context', true);
        
        // Trigger sync with callback - returns immediately
        const syncResult = await session.context.sync(
          contextResult.context.id,
          '/mnt/persistent',
          'upload',
          (success: boolean) => {
            if (success) {
              console.log('Context sync completed successfully');
            } else {
              console.log('Context sync failed or timed out');
            }
          },
          10,   // maxRetries
          1000  // retryInterval in milliseconds
        );
        
        console.log(`Sync triggered - Success: ${syncResult.success}`);
        console.log(`Request ID: ${syncResult.requestId}`);
        
        // Wait a bit for callback to be called
        await new Promise(resolve => setTimeout(resolve, 3000));
      } finally {
        await session.delete();
      }
    }
  } catch (error) {
    console.error('Error:', error);
  }
}

syncWithCallbackExample();

// Expected output:
// Sync triggered - Success: true
// Request ID: 39B00280-B9DA-17D1-BCBB-9C577E057F0A
// Context sync completed successfully  (printed by callback after completion)
```

## Complete Usage Example

```typescript
import { AgentBay } from 'wuying-agentbay-sdk';

async function completeContextManagerExample() {
  // Initialize the SDK
  const agentBay = new AgentBay({ apiKey: 'your_api_key' });

  try {
    // Create a session
    const result = await agentBay.create();
    if (!result.success) {
      console.log(`Failed to create session: ${result.errorMessage}`);
      return;
    }

    const session = result.session;
    console.log(`Session created: ${session.getSessionId()}`);

    try {
      // Get or create a context
      const contextResult = await agentBay.context.get('my-persistent-context', true);
      if (!contextResult.context) {
        console.log('Failed to get context');
        return;
      }

      console.log(`Context ID: ${contextResult.context.id}`);

      // Check initial context status
      const infoResult = await session.context.info();
      console.log(`\nInitial context status data count: ${infoResult.contextStatusData.length}`);

      // Synchronize context and wait for completion
      const syncResult = await session.context.sync(
        contextResult.context.id,
        '/mnt/persistent',
        'upload'
      );

      console.log(`\nSync completed - Success: ${syncResult.success}`);
      console.log(`Request ID: ${syncResult.requestId}`);

      // Check final context status
      const finalInfo = await session.context.infoWithParams(
        contextResult.context.id,
        '/mnt/persistent'
      );

      console.log(`\nFinal context status data count: ${finalInfo.contextStatusData.length}`);
      finalInfo.contextStatusData.forEach(item => {
        console.log(`  Context ${item.contextId}: Status=${item.status}, TaskType=${item.taskType}`);
      });

    } finally {
      // Cleanup
      await session.delete();
      console.log('\nSession deleted');
    }
  } catch (error) {
    console.error('Error:', error);
  }
}

completeContextManagerExample();

// Expected output:
// Session created: session-04bdwfj7u1sew7t4f
// Context ID: SdkCtx-04bdw8o39bq47rv1t
//
// Initial context status data count: 0
//
// Sync completed - Success: true
// Request ID: 39B00280-B9DA-17D1-BCBB-9C577E057F0A
//
// Final context status data count: 0
//
// Session deleted
```

## Notes

- The `ContextManager` is designed to work with contexts synchronized to a session. It is different from the `ContextService` (accessible via `agentBay.context`) which manages contexts globally.
- `info()` and `infoWithParams()` return information about the current synchronization tasks for contexts in the session.
- `sync()` is an async method. When called without a callback, it waits for synchronization to complete. When called with a callback, it returns immediately and calls the callback when complete.
- Synchronization polling checks the status every `retryInterval` milliseconds for up to `maxRetries` attempts.
- Empty `contextStatusData` arrays are normal when there are no active sync tasks.
- All methods return promises and should be called with `await`.




# Context API Reference

The Context API provides functionality for managing persistent storage contexts in the AgentBay cloud environment. Contexts allow you to persist data across sessions and reuse it in future sessions.

## Context Class

The `Context` class represents a persistent storage context in the AgentBay cloud environment.

### Properties

```typescript
id  // The unique identifier of the context
name  // The name of the context
createdAt  // Date and time when the Context was created
lastUsedAt  // Date and time when the Context was last used
```

## ContextService Class

The `ContextService` class provides methods for managing persistent contexts in the AgentBay cloud environment.

### list

Lists all available contexts with pagination support.

```typescript
list(params?: ContextListParams): Promise<ContextListResult>
```

**Parameters:**
- `params` (ContextListParams, optional): Pagination parameters. If not provided, default values are used (maxResults=10).

**Returns:**
- `Promise<ContextListResult>`: A promise that resolves to a result object containing the list of Context objects, pagination info, and request ID.

**Example:**
```typescript
import { AgentBay } from 'wuying-agentbay-sdk';

// Initialize the SDK
const agentBay = new AgentBay({ apiKey: 'your_api_key' });

// List all contexts (using default pagination)
async function listContexts() {
  try {
    const result = await agentBay.context.list();
    if (result.success) {
      console.log(`Found ${result.contexts.length} contexts:`);
      // Expected: Found X contexts (where X is the number of contexts, max 10 by default)
      console.log(`Request ID: ${result.requestId}`);
      // Expected: A valid UUID-format request ID
      result.contexts.slice(0, 3).forEach(context => {
        console.log(`Context ID: ${context.id}, Name: ${context.name}`);
        // Expected output: Context ID: SdkCtx-xxx, Name: xxx
      });
    } else {
      console.log('Failed to list contexts');
    }
  } catch (error) {
    console.error('Error:', error);
  }
}

listContexts();
```

### get

Gets a context by name. Optionally creates it if it doesn't exist.

```typescript
get(name: string, create?: boolean): Promise<ContextResult>
```

**Parameters:**
- `name` (string): The name of the context to get.
- `create` (boolean, optional): Whether to create the context if it doesn't exist. Defaults to false.

**Returns:**
- `Promise<ContextResult>`: A promise that resolves to a result object containing the Context object and request ID.

**Example:**
```typescript
import { AgentBay } from 'wuying-agentbay-sdk';

// Initialize the SDK
const agentBay = new AgentBay({ apiKey: 'your_api_key' });

// Get a context, creating it if it doesn't exist
async function getOrCreateContext() {
  try {
    const result = await agentBay.context.get('my-persistent-context', true);
    if (result.success) {
      const context = result.context;
      console.log(`Context ID: ${context.id}, Name: ${context.name}`);
      // Expected output: Context ID: SdkCtx-xxx, Name: my-persistent-context
      console.log(`Request ID: ${result.requestId}`);
      // Expected: A valid UUID-format request ID
    } else {
      console.log(`Failed to get context: ${result.errorMessage}`);
    }
  } catch (error) {
    console.error('Error:', error);
  }
}

getOrCreateContext();
```

### create

Creates a new context.

```typescript
create(name: string): Promise<ContextResult>
```

**Parameters:**
- `name` (string): The name of the context to create.

**Returns:**
- `Promise<ContextResult>`: A promise that resolves to a result object containing the created Context object and request ID.

**Example:**
```typescript
import { AgentBay } from 'wuying-agentbay-sdk';

// Initialize the SDK
const agentBay = new AgentBay({ apiKey: 'your_api_key' });

// Create a new context
async function createContext() {
  try {
    const result = await agentBay.context.create('my-new-context');
    if (result.success) {
      const context = result.context;
      console.log(`Created context with ID: ${context.id}, Name: ${context.name}`);
    } else {
      console.log(`Failed to create context: ${result.errorMessage}`);
    }
  } catch (error) {
    console.error('Error:', error);
  }
}

createContext();
```

### update

Updates an existing context.

```typescript
update(context: Context): Promise<OperationResult>
```

**Parameters:**
- `context` (Context): The context object to update.

**Returns:**
- `Promise<OperationResult>`: A promise that resolves to a result object containing success status, request ID, and error message if any.

**Example:**
```typescript
import { AgentBay } from 'wuying-agentbay-sdk';

// Initialize the SDK
const agentBay = new AgentBay({ apiKey: 'your_api_key' });

// Update an existing context
async function updateContext() {
  try {
    // Get an existing context
    const result = await agentBay.context.get('my-context');
    if (result.success) {
      const context = result.context;

      // Update the context name
      context.name = 'my-updated-context';

      // Save the changes
      const updateResult = await agentBay.context.update(context);
      if (updateResult.success) {
        console.log(`Context updated successfully, request ID: ${updateResult.requestId}`);
      } else {
        console.log(`Failed to update context: ${updateResult.errorMessage}`);
      }
    } else {
      console.log(`Failed to get context: ${result.errorMessage}`);
    }
  } catch (error) {
    console.error('Error:', error);
  }
}

updateContext();
```

### delete

Deletes a context.

```typescript
delete(context: Context): Promise<OperationResult>
```

**Parameters:**
- `context` (Context): The context object to delete.

**Returns:**
- `Promise<OperationResult>`: A promise that resolves to a result object containing success status, request ID, and error message if any.

**Example:**
```typescript
import { AgentBay } from 'wuying-agentbay-sdk';

// Initialize the SDK
const agentBay = new AgentBay({ apiKey: 'your_api_key' });

// Delete an existing context
async function deleteContext() {
  try {
    // Get an existing context
    const result = await agentBay.context.get('my-context');
    if (result.success) {
      const context = result.context;

      // Delete the context
      const deleteResult = await agentBay.context.delete(context);
      if (deleteResult.success) {
        console.log(`Context deleted successfully, request ID: ${deleteResult.requestId}`);
      } else {
        console.log(`Failed to delete context: ${deleteResult.errorMessage}`);
      }
    } else {
      console.log(`Failed to get context: ${result.errorMessage}`);
    }
  } catch (error) {
    console.error('Error:', error);
  }
}

deleteContext();
```

### clear

Clears the context's persistent data.

```typescript
clear(contextId: string, timeout?: number, pollInterval?: number): Promise<ClearContextResult>
```

**Parameters:**
- `contextId` (string): The unique identifier of the context to clear.
- `timeout` (number, optional): Timeout in seconds to wait for task completion. Default is 60 seconds.
- `pollInterval` (number, optional): Interval in seconds between status polls. Default is 2.0 seconds.

**Returns:**
- `Promise<ClearContextResult>`: A promise that resolves to a result object containing the final task result. The status field will be "available" on success.

**State Transitions:**
- "clearing": Data clearing is in progress
- "available": Clearing completed successfully (final success state)
- "in-use": Context is being used
- "pre-available": Context is being prepared

**Example:**
```typescript
import { AgentBay } from 'wuying-agentbay-sdk';

// Initialize the SDK
const agentBay = new AgentBay({ apiKey: 'your_api_key' });

// Clear context data
async function clearContext() {
  try {
    // Get an existing context
    const result = await agentBay.context.get('my-context');
    if (result.success && result.context) {
      const context = result.context;

      // Clear context data synchronously (wait for completion)
      const clearResult = await agentBay.context.clear(context.id);
      if (clearResult.success) {
        console.log(`Context data cleared successfully`);
        console.log(`Final Status: ${clearResult.status}`);
        // Expected output: Final Status: available
        console.log(`Request ID: ${clearResult.requestId}`);
        // Expected: A valid UUID-format request ID
      } else {
        console.log(`Failed to clear context: ${clearResult.errorMessage}`);
      }
    } else {
      console.log(`Failed to get context: ${result.errorMessage}`);
    }
  } catch (error) {
    console.error('Error:', error);
  }
}

clearContext();
```

### clearAsync

Asynchronously initiates a task to clear the context's persistent data.

```typescript
clearAsync(contextId: string): Promise<ClearContextResult>
```

**Parameters:**
- `contextId` (string): The unique identifier of the context to clear.

**Returns:**
- `Promise<ClearContextResult>`: A promise that resolves to a result object indicating the task has been successfully started, with status field set to "clearing".

**Example:**
```typescript
import { AgentBay } from 'wuying-agentbay-sdk';

// Initialize the SDK
const agentBay = new AgentBay({ apiKey: 'your_api_key' });

// Start clearing context data asynchronously
async function clearContextAsync() {
  try {
    // Get an existing context
    const result = await agentBay.context.get('my-context');
    if (result.success && result.context) {
      const context = result.context;

      // Start clearing context data asynchronously (non-blocking)
      const clearResult = await agentBay.context.clearAsync(context.id);
      if (clearResult.success) {
        console.log(`Clear task started: Success=${clearResult.success}, Status=${clearResult.status}`);
        // Expected output: Clear task started: Success=true, Status=clearing
        console.log(`Request ID: ${clearResult.requestId}`);
        // Expected: A valid UUID-format request ID
      } else {
        console.log(`Failed to start clear: ${clearResult.errorMessage}`);
      }
    } else {
      console.log(`Failed to get context: ${result.errorMessage}`);
    }
  } catch (error) {
    console.error('Error:', error);
  }
}

clearContextAsync();
```

### getClearStatus

Queries the status of the clearing task.

```typescript
getClearStatus(contextId: string): Promise<ClearContextResult>
```

**Parameters:**
- `contextId` (string): The unique identifier of the context to check.

**Returns:**
- `Promise<ClearContextResult>`: A promise that resolves to a result object containing the current task status.

**State Transitions:**
- "clearing": Data clearing is in progress
- "available": Clearing completed successfully (final success state)
- "in-use": Context is being used
- "pre-available": Context is being prepared

**Example:**
```typescript
import { AgentBay } from 'wuying-agentbay-sdk';

// Initialize the SDK
const agentBay = new AgentBay({ apiKey: 'your_api_key' });

// Check clearing status
async function checkClearStatus() {
  try {
    // Get an existing context
    const result = await agentBay.context.get('my-context');
    if (result.success && result.context) {
      const context = result.context;

      // Check clearing status
      const statusResult = await agentBay.context.getClearStatus(context.id);
      if (statusResult.success) {
        console.log(`Current status: ${statusResult.status}`);
        console.log(`Request ID: ${statusResult.requestId}`);
        // Expected: Current status: clearing/available/in-use/pre-available
      } else {
        console.log(`Failed to get status: ${statusResult.errorMessage}`);
      }
    } else {
      console.log(`Failed to get context: ${result.errorMessage}`);
    }
  } catch (error) {
    console.error('Error:', error);
  }
}

checkClearStatus();
```

## Related Resources

- [Session API Reference](session.md)
- [ContextManager API Reference](context-manager.md)



# FileSystem API Reference (TypeScript)

The FileSystem module provides comprehensive file and directory operations within AgentBay sessions, including real-time directory monitoring capabilities and file transfer functionality.

## 📖 Related Tutorial

- [Complete Guide to File Operations](../../../../../docs/guides/common-features/basics/file-operations.md) - Detailed tutorial covering all file operation features

## Overview

The FileSystem class enables you to:
- Perform standard file operations (read, write, create, delete)
- Monitor directories for real-time file changes
- Handle file uploads and downloads between local and remote environments
- Manage file permissions and metadata

## Core Types

### FileChangeEvent

Represents a single file change event detected during directory monitoring.

```typescript
export interface FileChangeEvent {
  eventType: string; // "create", "modify", "delete"
  path: string;      // Full path to the changed file/directory
  pathType: string;  // "file" or "directory"
}
```

### FileChangeResult

Contains the result of file change detection operations.

```typescript
export interface FileChangeResult extends ApiResponse {
  events: FileChangeEvent[];
  rawData: string;
}
```

## File Transfer Methods

### uploadFile

Uploads a local file to a remote path using pre-signed URLs.

```typescript
async uploadFile(
  localPath: string,
  remotePath: string,
  options?: {
    contentType?: string;
    wait?: boolean;
    waitTimeout?: number;
    pollInterval?: number;
    progressCb?: (bytesTransferred: number) => void;
  }
): Promise<UploadResult>
```

**Parameters:**
- `localPath` (string): Local file path to upload
- `remotePath` (string): Remote file path to upload to
- `options` (object, optional): Upload options
  - `contentType` (string): Content type of the file
  - `wait` (boolean): Whether to wait for sync completion (default: true)
  - `waitTimeout` (number): Timeout for waiting in seconds (default: 30.0)
  - `pollInterval` (number): Polling interval in seconds (default: 1.5)
  - `progressCb` (function): Progress callback function

**Returns:**
- `Promise<UploadResult>`: Promise resolving to upload result

**Example:**
```typescript
import { AgentBay } from 'wuying-agentbay-sdk';

async function uploadFileExample() {
  // Initialize AgentBay
  const agentBay = new AgentBay({ apiKey: 'your-api-key' });

  // Create session with context sync for file transfer
  const sessionResult = await agentBay.create({
    imageId: 'code_latest'
  });

  if (!sessionResult.success || !sessionResult.session) {
    throw new Error('Failed to create session');
  }

  const session = sessionResult.session;
  const fileSystem = session.fileSystem();

  try {
    // Upload a file
    const uploadResult = await fileSystem.uploadFile(
      '/local/path/to/file.txt',
      '/remote/path/to/file.txt'
    );

    if (uploadResult.success) {
      console.log(`Upload successful!`);
      console.log(`Bytes sent: ${uploadResult.bytesSent}`);
      console.log(`Request ID (upload URL): ${uploadResult.requestIdUploadUrl}`);
      console.log(`Request ID (sync): ${uploadResult.requestIdSync}`);
    } else {
      console.error(`Upload failed: ${uploadResult.error}`);
    }
  } finally {
    // Clean up session
    await agentBay.delete(session);
  }
}
```

### downloadFile

Downloads a remote file to a local path using pre-signed URLs.

```typescript
async downloadFile(
  remotePath: string,
  localPath: string,
  options?: {
    overwrite?: boolean;
    wait?: boolean;
    waitTimeout?: number;
    pollInterval?: number;
    progressCb?: (bytesReceived: number) => void;
  }
): Promise<DownloadResult>
```

**Parameters:**
- `remotePath` (string): Remote file path to download from
- `localPath` (string): Local file path to download to
- `options` (object, optional): Download options
  - `overwrite` (boolean): Whether to overwrite existing file (default: true)
  - `wait` (boolean): Whether to wait for sync completion (default: true)
  - `waitTimeout` (number): Timeout for waiting in seconds (default: 30.0)
  - `pollInterval` (number): Polling interval in seconds (default: 1.5)
  - `progressCb` (function): Progress callback function

**Returns:**
- `Promise<DownloadResult>`: Promise resolving to download result

**Example:**
```typescript
import { AgentBay } from 'wuying-agentbay-sdk';

async function downloadFileExample() {
  // Initialize AgentBay
  const agentBay = new AgentBay({ apiKey: 'your-api-key' });

  // Create session
  const sessionResult = await agentBay.create({
    imageId: 'code_latest'
  });

  if (!sessionResult.success || !sessionResult.session) {
    throw new Error('Failed to create session');
  }

  const session = sessionResult.session;
  const fileSystem = session.fileSystem();

  try {
    // Download a file
    const downloadResult = await fileSystem.downloadFile(
      '/remote/path/to/file.txt',
      '/local/path/to/file.txt'
    );

    if (downloadResult.success) {
      console.log(`Download successful!`);
      console.log(`Bytes received: ${downloadResult.bytesReceived}`);
      console.log(`Request ID (download URL): ${downloadResult.requestIdDownloadUrl}`);
      console.log(`Request ID (sync): ${downloadResult.requestIdSync}`);
    } else {
      console.error(`Download failed: ${downloadResult.error}`);
    }
  } finally {
    // Clean up session
    await agentBay.delete(session);
  }
}
```

## Directory Monitoring Methods

### getFileChange

Retrieves file changes that occurred in a directory since the last check.

```typescript
async getFileChange(path: string): Promise<FileChangeResult>
```

**Parameters:**
- `path` (string): Directory path to monitor

**Returns:**
- `Promise<FileChangeResult>`: Promise resolving to result containing detected file changes

**Example:**
```typescript
import { AgentBay } from 'wuying-agentbay-sdk';

async function checkFileChanges() {
  // Initialize AgentBay
  const agentBay = new AgentBay({ apiKey: 'your-api-key' });

  // Create session
  const sessionResult = await agentBay.create({
    imageId: 'code_latest'
  });

  if (!sessionResult.success || !sessionResult.session) {
    throw new Error('Failed to create session');
  }

  const session = sessionResult.session;
  const fileSystem = session.fileSystem();

  try {
    // Check for file changes
    const result = await fileSystem.getFileChange('/tmp/watch_dir');

    if (FileChangeResultHelper.hasChanges(result)) {
      console.log(`Detected ${result.events.length} changes:`);
      result.events.forEach(event => {
        console.log(`- ${FileChangeEventHelper.toString(event)}`);
      });
    } else {
      console.log('No changes detected');
    }
  } finally {
    // Clean up session
    await agentBay.delete(session);
  }
}
```

### watchDirectory

Continuously monitors a directory for file changes and executes a callback function when changes are detected.

```typescript
async watchDirectory(
  path: string,
  callback: (events: FileChangeEvent[]) => void,
  intervalMs: number = 1000,
  signal?: AbortSignal
): Promise<void>
```

**Parameters:**
- `path` (string): Directory path to monitor
- `callback` (function): Function called when changes are detected
- `intervalMs` (number, optional): Polling interval in milliseconds (default: 1000, minimum: 100)
- `signal` (AbortSignal, optional): Signal to abort the monitoring

**Returns:**
- `Promise<void>`: Promise that resolves when monitoring stops

**Example:**
```typescript
import { AgentBay } from 'wuying-agentbay-sdk';

async function watchDirectoryExample() {
  // Initialize AgentBay
  const agentBay = new AgentBay({ apiKey: 'your-api-key' });

  // Create session
  const sessionResult = await agentBay.create({
    imageId: 'code_latest'
  });

  if (!sessionResult.success || !sessionResult.session) {
    throw new Error('Failed to create session');
  }

  const session = sessionResult.session;
  const fileSystem = session.fileSystem();

  // Create test directory
  const testDir = '/tmp/agentbay_watch_test';
  await fileSystem.createDirectory(testDir);

  try {
    // Set up callback function
    const callback = (events: FileChangeEvent[]) => {
      console.log(`Detected ${events.length} file changes:`);
      events.forEach(event => {
        console.log(`- ${FileChangeEventHelper.toString(event)}`);
      });
    };

    // Create AbortController for stopping the watch
    const controller = new AbortController();

    // Start monitoring
    const watchPromise = fileSystem.watchDirectory(
      testDir,
      callback,
      1000, // 1 second interval
      controller.signal
    );

    // Simulate file operations after a delay
    setTimeout(async () => {
      // Create a file
      const testFile = `${testDir}/test.txt`;
      await fileSystem.writeFile(testFile, 'Hello, AgentBay!');

      // Modify the file after another delay
      setTimeout(async () => {
        await fileSystem.writeFile(testFile, 'Modified content');

        // Stop monitoring after another delay
        setTimeout(() => {
          controller.abort();
        }, 2000);
      }, 2000);
    }, 2000);

    // Wait for monitoring to complete
    await watchPromise;
    console.log('Monitoring stopped');

  } finally {
    // Clean up
    await agentBay.delete(session);
  }
}
```

## Helper Method Examples

### Using FileChangeEventHelper

```typescript
// Create event from dictionary
const eventData = {
  eventType: 'create',
  path: '/tmp/new_file.txt',
  pathType: 'file'
};
const event = FileChangeEventHelper.fromDict(eventData);

// Convert to string
const eventString = FileChangeEventHelper.toString(event);
console.log(eventString); // "FileChangeEvent(eventType='create', path='/tmp/new_file.txt', pathType='file')"

// Convert to dictionary
const eventDict = FileChangeEventHelper.toDict(event);
console.log(eventDict); // { eventType: 'create', path: '/tmp/new_file.txt', pathType: 'file' }
```

### Using FileChangeResultHelper

```typescript
// Assuming you have a FileChangeResult
const result: FileChangeResult = await fileSystem.getFileChange('/tmp/watch_dir');

// Check if there are changes
if (FileChangeResultHelper.hasChanges(result)) {
  // Get specific types of changes
  const modifiedFiles = FileChangeResultHelper.getModifiedFiles(result);
  const createdFiles = FileChangeResultHelper.getCreatedFiles(result);
  const deletedFiles = FileChangeResultHelper.getDeletedFiles(result);

  console.log('Modified files:', modifiedFiles);
  console.log('Created files:', createdFiles);
  console.log('Deleted files:', deletedFiles);
}
```

## Best Practices

### 1. Polling Interval

Choose an appropriate polling interval based on your needs:

```typescript
// High-frequency monitoring (higher CPU usage)
await fileSystem.watchDirectory(path, callback, 100);

// Normal monitoring (balanced)
await fileSystem.watchDirectory(path, callback, 1000);

// Low-frequency monitoring (lower CPU usage)
await fileSystem.watchDirectory(path, callback, 5000);
```

### 2. Error Handling

Always handle errors and implement proper cleanup:

```typescript
const controller = new AbortController();

try {
  await fileSystem.watchDirectory(path, callback, 1000, controller.signal);
} catch (error) {
  console.error('Watch error:', error);
} finally {
  // Ensure monitoring is stopped
  controller.abort();
}
```

### 3. Callback Function Design

Keep callback functions lightweight and handle errors gracefully:

```typescript
const callback = (events: FileChangeEvent[]) => {
  try {
    events.forEach(event => {
      // Process event
      processFileChange(event);
    });
  } catch (error) {
    console.error('Callback error:', error);
  }
};
```

### 4. Using AbortController

Use AbortController for better control over monitoring lifecycle:

```typescript
const controller = new AbortController();

// Set up automatic timeout
setTimeout(() => {
  controller.abort();
}, 30000); // Stop after 30 seconds

// Start monitoring
await fileSystem.watchDirectory(path, callback, 1000, controller.signal);
```

## Common Use Cases

### 1. Development File Watcher

Monitor source code changes during development:

```typescript
const callback = (events: FileChangeEvent[]) => {
  events.forEach(event => {
    if (event.path.endsWith('.ts') && event.eventType === 'modify') {
      console.log(`TypeScript file modified: ${event.path}`);
      // Trigger rebuild or test
    }
  });
};
```

### 2. Log File Monitor

Monitor log files for new entries:

```typescript
const callback = (events: FileChangeEvent[]) => {
  events.forEach(event => {
    if (event.path.includes('.log') && event.eventType === 'modify') {
      console.log(`Log file updated: ${event.path}`);
      // Process new log entries
    }
  });
};
```

### 3. Configuration File Watcher

Monitor configuration files for changes:

```typescript
const callback = (events: FileChangeEvent[]) => {
  events.forEach(event => {
    if (event.path.endsWith('config.json')) {
      console.log(`Configuration changed: ${event.path}`);
      // Reload configuration
    }
  });
};
```

### 4. Filtered Monitoring

Monitor only specific file types:

```typescript
const callback = (events: FileChangeEvent[]) => {
  const imageEvents = events.filter(event => 
    /\.(jpg|jpeg|png|gif)$/i.test(event.path)
  );
  
  if (imageEvents.length > 0) {
    console.log(`Image files changed: ${imageEvents.length}`);
    imageEvents.forEach(event => {
      console.log(`- ${event.eventType}: ${event.path}`);
    });
  }
};
```

## Advanced Usage

### Multiple Directory Monitoring

Monitor multiple directories with different configurations:

```typescript
async function monitorMultipleDirectories() {
  const directories = [
    { path: '/tmp/src', interval: 500 },
    { path: '/tmp/logs', interval: 2000 },
    { path: '/tmp/config', interval: 5000 }
  ];

  const controllers = directories.map(() => new AbortController());

  try {
    // Start monitoring all directories
    const promises = directories.map((dir, index) => 
      fileSystem.watchDirectory(
        dir.path,
        (events) => console.log(`${dir.path}: ${events.length} changes`),
        dir.interval,
        controllers[index].signal
      )
    );

    // Wait for all monitoring to complete
    await Promise.all(promises);
  } finally {
    // Stop all monitoring
    controllers.forEach(controller => controller.abort());
  }
}
```

### Conditional Monitoring

Start and stop monitoring based on conditions:

```typescript
let isMonitoring = false;
const controller = new AbortController();

async function conditionalMonitoring() {
  if (shouldStartMonitoring() && !isMonitoring) {
    isMonitoring = true;
    
    try {
      await fileSystem.watchDirectory(
        '/tmp/watch_dir',
        (events) => {
          // Check if we should stop monitoring
          if (shouldStopMonitoring()) {
            controller.abort();
          }
          
          // Process events
          processEvents(events);
        },
        1000,
        controller.signal
      );
    } finally {
      isMonitoring = false;
    }
  }
}
```

## Troubleshooting

### Common Issues

1. **High CPU Usage**: Reduce polling frequency by increasing `intervalMs`
2. **Missing Events**: Ensure the directory exists and is accessible
3. **Callback Errors**: Implement proper error handling in callback functions
4. **Memory Leaks**: Always abort controllers and clean up resources

### Performance Considerations

- Use appropriate polling intervals based on your needs
- Filter events in callback functions to reduce processing overhead
- Consider using multiple watchers for different directories with different intervals
- Monitor memory usage when watching large directories with frequent changes

### Error Handling Examples

```typescript
// Handle AbortController errors
try {
  await fileSystem.watchDirectory(path, callback, 1000, controller.signal);
} catch (error) {
  if (error.name === 'AbortError') {
    console.log('Monitoring was aborted');
  } else {
    console.error('Monitoring error:', error);
  }
}

// Handle callback errors
const safeCallback = (events: FileChangeEvent[]) => {
  try {
    processEvents(events);
  } catch (error) {
    console.error('Error processing events:', error);
    // Continue monitoring despite callback errors
  }
};
```

## Limitations

- Polling-based detection (not real-time filesystem events)
- Performance depends on polling interval and directory size
- May miss very rapid file changes that occur between polls
- Requires active session connection to AgentBay service
- AbortController support depends on Node.js version (polyfill may be needed for older versions)




# TypeScript Logging Configuration

## Overview

The TypeScript SDK provides comprehensive logging with support for multiple log levels and automatic sensitive data masking.

## Setting Log Level

### Priority System (Highest to Lowest)

1. **Code-level setup** - `setLogLevel()` can be called after import
2. **Environment variables** - `LOG_LEVEL` or `AGENTBAY_LOG_LEVEL`
3. **.env file** - Automatically loaded from current directory or parent directories
4. **Default values** - INFO level

### Method 1: Environment Variable

**Option A: Using .env File (Recommended)**

Create a `.env` file in your project root:

```
# .env file
LOG_LEVEL=DEBUG
# or
AGENTBAY_LOG_LEVEL=DEBUG
```

The SDK automatically loads `.env` files from the current directory or parent directories.

**Option B: Command Line Environment Variable**

Set environment variables when running your script:

```bash
export LOG_LEVEL=DEBUG
npx ts-node script.ts
```

### Method 2: Code-Level Setup

```typescript
import { setLogLevel, getLogLevel } from '@aliyun/wuying-agentbay-sdk';

// Set log level - works at any time after import
setLogLevel('DEBUG');

// Check current level
const level = getLogLevel();
```

## Log Levels

| Level | Use Case |
|-------|----------|
| **DEBUG** | Development - see everything |
| **INFO** | Default - important events |
| **WARN** | Issues but not failures |
| **ERROR** | Only failures |

Filter rule: **Only logs at your level or HIGHER severity are shown**.

## Logging Functions

### Basic Logging

```typescript
import {
    logDebug,
    logInfo,
    logWarn,
    logError
} from '@aliyun/wuying-agentbay-sdk';

logDebug('Message with arguments', arg1, arg2);
logInfo('Information message');
logWarn('Warning message');
logError('Error message');
```

## File Logging

The TypeScript SDK supports logging to files with automatic rotation.

### Basic File Logging

```typescript
import { setupLogger } from '@aliyun/wuying-agentbay-sdk';

// Configure file logging
setupLogger({
    level: 'DEBUG',
    logFile: '/path/to/app.log'
});
```

### File Rotation

Configure automatic log file rotation when the file reaches a certain size:

```typescript
import { setupLogger } from '@aliyun/wuying-agentbay-sdk';

setupLogger({
    level: 'DEBUG',
    logFile: '/var/log/myapp.log',
    maxFileSize: '100 MB'  // Rotate when file reaches 100 MB
});
```

Supported size units:
- `KB` - Kilobytes
- `MB` - Megabytes (default)
- `GB` - Gigabytes

Default max file size is 10 MB if not specified. When rotation occurs, the current log file is renamed to `<filename>.1`.

### Console and File Logging

You can control whether logs are written to console and/or file:

```typescript
import { setupLogger } from '@aliyun/wuying-agentbay-sdk';

// Log to file only (disable console output)
setupLogger({
    level: 'DEBUG',
    logFile: '/var/log/app.log',
    enableConsole: false
});

// Log to both console and file (default)
setupLogger({
    level: 'DEBUG',
    logFile: '/var/log/app.log',
    enableConsole: true
});
```

### LoggerConfig Options

```typescript
interface LoggerConfig {
  level?: LogLevel;           // Log level: 'DEBUG' | 'INFO' | 'WARN' | 'ERROR'
  logFile?: string;           // Path to log file (undefined = no file logging)
  maxFileSize?: string;       // Max file size before rotation (e.g., "10 MB", "100 MB", "1 GB")
  enableConsole?: boolean;    // Enable/disable console output (default: true)
}
```

## Sensitive Data Masking

The SDK automatically masks sensitive information:

```typescript
import { maskSensitiveData } from '@aliyun/wuying-agentbay-sdk';

const data = {
    api_key: 'sk_live_1234567890',
    password: 'secret123',
    auth_token: 'Bearer xyz'
};

const masked = maskSensitiveData(data);
// Result: api_key masked, password masked, auth_token masked
```

Automatically masked fields:
- api_key, apikey, api-key
- password, passwd, pwd
- token, access_token, auth_token
- secret, private_key
- authorization

Custom fields can be masked by passing them as parameters:

```typescript
const masked = maskSensitiveData(data, ['custom_secret', 'ssn']);
```

## Environment Variable Support

The TypeScript SDK supports both `LOG_LEVEL` and `AGENTBAY_LOG_LEVEL` environment variables for configuration.

### .env File Auto-Loading

The SDK automatically searches for and loads `.env` files from:
1. Current working directory
2. Parent directories (recursive search up to root)
3. Git repository root (if found)

**Example `.env` file:**

```
# Logging configuration
LOG_LEVEL=DEBUG

# Or use the prefixed version
AGENTBAY_LOG_LEVEL=DEBUG

# API configuration
AGENTBAY_API_KEY=your_api_key_here
```

The SDK loads the `.env` file automatically on import, so you don't need any additional configuration code.

## Quick Reference

**Development (see everything)**:
```bash
export LOG_LEVEL=DEBUG
npx ts-node script.ts
```

**Testing (important events only)**:
```bash
npx ts-node test.ts
# Uses default INFO level
```

**Production (problems only)**:
```bash
export LOG_LEVEL=ERROR
node dist/index.js
```




# Session Class

The `Session` class represents a session in the AgentBay cloud environment. It provides methods for managing file systems, executing commands, and more.

## 📖 Related Tutorial

- [Session Management Guide](../../../../../docs/guides/common-features/basics/session-management.md) - Detailed tutorial on session lifecycle and management

## Properties

```typescript
sessionId: string                    // The ID of this session
fileSystem: FileSystem               // The FileSystem instance for this session
command: Command                     // The Command instance for this session
code: Code                          // The Code instance for this session
oss: Oss                            // The Oss instance for this session
application: Application            // The Application instance for this session
window: WindowManager               // The WindowManager instance for this session
ui: UI                              // The UI instance for this session
context: ContextManager             // The ContextManager instance for this session
browser: Browser                    // The Browser instance for this session
agent: Agent                        // The Agent instance for this session
isVpc: boolean                      // Whether this session uses VPC resources
networkInterfaceIp: string          // Network interface IP for VPC sessions
httpPort: string                    // HTTP port for VPC sessions
mcpTools: McpTool[]                 // MCP tools available for this session
```

**Note:** The `agentBay` property is private and not part of the public API.

## Methods

### delete

Deletes this session.

```typescript
delete(syncContext?: boolean): Promise<DeleteResult>
```

**Parameters:**
- `syncContext` (boolean, optional): If true, the API will trigger a file upload via `this.context.sync` before actually releasing the session. Default is false.

**Returns:**
- `Promise<DeleteResult>`: A promise that resolves to a result object containing success status, request ID, and error message if any.

**Behavior:**
- When `syncContext` is true, the API will first call `context.sync` to trigger file upload.
- It will then check `context.info` to retrieve ContextStatusData and monitor only upload task items' Status.
- The API waits until all upload tasks show either "Success" or "Failed" status, or until the maximum retry limit (150 times with 2-second intervals) is reached.
- Any "Failed" status upload tasks will have their error messages printed.
- The session deletion only proceeds after context sync status checking for upload tasks completes.

**Example:**
```typescript
import { AgentBay } from 'wuying-agentbay-sdk';

// Initialize the SDK
const agentBay = new AgentBay({ apiKey: 'your_api_key' });

// Create and delete a session
async function createAndDeleteSession() {
  try {
    const result = await agentBay.create();
    if (result.success) {
      const session = result.session;
      console.log(`Session created with ID: ${session.sessionId}`);

      // Use the session...

      // Delete the session with context synchronization
      const deleteResult = await session.delete(true);
      if (deleteResult.success) {
        console.log('Session deleted successfully with synchronized context');
      } else {
        console.log(`Failed to delete session: ${deleteResult.errorMessage}`);
      }
    }
  } catch (error) {
    console.error('Error:', error);
  }
}

createAndDeleteSession();
```

### setLabels

Sets labels for this session.

```typescript
setLabels(labels: Record<string, string>): Promise<OperationResult>
```

**Parameters:**
- `labels` (Record<string, string>): Key-value pairs representing the labels to set.

**Returns:**
- `Promise<OperationResult>`: A promise that resolves to a result object containing success status, request ID, and error message if any.

**Example:**
```typescript
// Set session labels
async function setSessionLabels(session) {
  try {
    const labels = {
      project: 'demo',
      environment: 'testing',
      version: '1.0.0'
    };

    const result = await session.setLabels(labels);
    console.log(`Labels set successfully, request ID: ${result.requestId}`);
    return result;
  } catch (error) {
    console.error(`Failed to set labels: ${error}`);
    throw error;
  }
}
```

### getLabels

Gets the labels for this session.

```typescript
getLabels(): Promise<OperationResult>
```

**Returns:**
- `Promise<OperationResult>`: A promise that resolves to a result object containing success status, request ID, error message if any, and the labels data.

**Example:**
```typescript
// Get session labels
async function getSessionLabels(session) {
  try {
    const result = await session.getLabels();
    if (result.success) {
      console.log(`Session labels: ${JSON.stringify(result.data)}`);
      console.log(`Request ID: ${result.requestId}`);
      return result.data;
    } else {
      console.log(`Failed to get labels: ${result.errorMessage}`);
      return null;
    }
  } catch (error) {
    console.error(`Failed to get labels: ${error}`);
    throw error;
  }
}
```

### info

Gets information about this session.

```typescript
info(): Promise<InfoResult>
```

**Returns:**
- `Promise<InfoResult>`: A promise that resolves to a result object containing session information, request ID, and success status.

**Example:**
```typescript
// Get session information
async function getSessionInfo(session) {
  try {
    const result = await session.info();
    console.log(`Session ID: ${result.data.sessionId}`);
    console.log(`Resource URL: ${result.data.resourceUrl}`);
    console.log(`Request ID: ${result.requestId}`);
    return result.data;
  } catch (error) {
    console.error(`Failed to get session info: ${error}`);
    throw error;
  }
}
```

### getLink

Gets a link for this session.

```typescript
getLink(protocolType?: string, port?: number): Promise<LinkResult>
```

**Parameters:**
- `protocolType` (string, optional): The protocol type for the link.
- `port` (number, optional): The port for the link. Must be an integer in the range [30100, 30199].

**Returns:**
- `Promise<LinkResult>`: A promise that resolves to a result object containing the session link, request ID, and success status.

**Throws:**
- `Error`: If the port value is not an integer or is outside the valid range [30100, 30199].

**Example:**
```typescript
// Get session link
async function getSessionLink(session) {
  try {
    const result = await session.getLink();
    console.log(`Session link: ${result.data}`);
    console.log(`Request ID: ${result.requestId}`);

    // Get link with specific protocol and port (port must be in range [30100, 30199])
    const customResult = await session.getLink('https', 30150);
    console.log(`Custom link: ${customResult.data}`);

    return result.data;
  } catch (error) {
    console.error(`Failed to get link: ${error}`);
    throw error;
  }
}
```

### getLinkAsync

Asynchronously gets a link for this session.

```typescript
getLinkAsync(protocolType?: string, port?: number): Promise<LinkResult>
```

**Parameters:**
- `protocolType` (string, optional): The protocol type for the link.
- `port` (number, optional): The port for the link. Must be an integer in the range [30100, 30199].

**Returns:**
- `Promise<LinkResult>`: A promise that resolves to a result object containing the session link, request ID, and success status.

**Throws:**
- `Error`: If the port value is not an integer or is outside the valid range [30100, 30199].

**Example:**
```typescript
// Get session link asynchronously
async function getSessionLinkAsync(session) {
  try {
    const result = await session.getLinkAsync();
    console.log(`Session link: ${result.data}`);
    console.log(`Request ID: ${result.requestId}`);

    // Get link with specific protocol and port (port must be in range [30100, 30199])
    const customResult = await session.getLinkAsync('https', 30150);
    console.log(`Custom link: ${customResult.data}`);

    return result.data;
  } catch (error) {
    console.error(`Failed to get link: ${error}`);
    throw error;
  }
}
```

### listMcpTools

Lists MCP tools available for this session.

```typescript
listMcpTools(imageId?: string): Promise<McpToolsResult>
```

**Parameters:**
- `imageId` (string, optional): The image ID to list tools for. Defaults to "linux_latest".

**Returns:**
- `Promise<McpToolsResult>`: A promise that resolves to a result object containing success status, request ID, and the list of MCP tools.

**Example:**
```typescript
// List MCP tools
async function listMcpTools(session) {
  try {
    const result = await session.listMcpTools();
    console.log(`Found ${result.tools.length} MCP tools`);
    console.log(`Request ID: ${result.requestId}`);

    for (const tool of result.tools) {
      console.log(`Tool: ${tool.name} - ${tool.description}`);
    }

    return result.tools;
  } catch (error) {
    console.error(`Failed to list MCP tools: ${error}`);
    throw error;
  }
}
```

## Related Resources

- [FileSystem API Reference](filesystem.md)
- [Command API Reference](command.md)
- [UI API Reference](../../computer-use/ui.md)
- [Window API Reference](../../computer-use/window.md)
- [OSS API Reference](../advanced/oss.md)
- [Application API Reference](../../computer-use/application.md)
- [Context API Reference](context-manager.md)




# Application Class

> **⚠️ DEPRECATED**: This API is deprecated. Please use the [Computer API](computer.md) instead for application management functionality.

The Application class provides methods for managing applications in the AgentBay cloud environment, including listing installed applications, starting applications, and stopping running processes.

## Overview

The Application class is accessed through a session instance and provides methods for application management in the cloud environment.

## Data Types


Represents an installed application.


```typescript
interface InstalledApp {
    name: string;       // The name of the application
    start_cmd: string;  // The command used to start the application
    stop_cmd?: string;  // The command used to stop the application (optional)
    work_directory?: string; // The working directory for the application (optional)
}
```


```typescript
interface Process {
    pname: string;   // The name of the process
    pid: number;     // The process ID
    cmdline?: string; // The command line used to start the process (optional)
}
```


```typescript
async getInstalledApps(includeSystemApps: boolean = true, includeStoreApps: boolean = false, includeDesktopApps: boolean = true): Promise<InstalledApp[]>
```

**Parameters:**
- `includeSystemApps` (boolean, optional): Whether to include system applications. Default is true.
- `includeStoreApps` (boolean, optional): Whether to include store applications. Default is false.
- `includeDesktopApps` (boolean, optional): Whether to include desktop applications. Default is true.

**Returns:**
- `Promise<InstalledApp[]>`: A promise that resolves to a list of installed applications.

**Throws:**
- `APIError`: If there's an error retrieving the installed applications.


```typescript
async startApp(startCmd: string, workDirectory: string = ""): Promise<Process[]>
```

**Parameters:**
- `startCmd` (string): The command used to start the application.
- `workDirectory` (string, optional): The working directory for the application. Default is an empty string.

**Returns:**
- `Promise<Process[]>`: A promise that resolves to a list of processes started.

**Throws:**
- `APIError`: If there's an error starting the application.


```typescript
async stopAppByPName(pname: string): Promise<boolean>
```

**Parameters:**
- `pname` (string): The name of the process to stop.

**Returns:**
- `Promise<boolean>`: A promise that resolves to true if the operation was successful, false otherwise.

**Throws:**
- `APIError`: If there's an error stopping the application.


```typescript
async stopAppByPid(pid: number): Promise<boolean>
```

**Parameters:**
- `pid` (number): The process ID to stop.

**Returns:**
- `Promise<boolean>`: A promise that resolves to true if the operation was successful, false otherwise.

**Throws:**
- `APIError`: If there's an error stopping the application.


```typescript
async stopAppByCmd(stopCmd: string): Promise<boolean>
```

**Parameters:**
- `stopCmd` (string): The command used to stop the application.

**Returns:**
- `Promise<boolean>`: A promise that resolves to true if the operation was successful, false otherwise.

**Throws:**
- `APIError`: If there's an error stopping the application.


```typescript
async listVisibleApps(): Promise<Process[]>
```

**Returns:**
- `Promise<Process[]>`: A promise that resolves to a list of visible processes.

**Throws:**
- `APIError`: If there's an error listing the visible applications.




# Computer Class

The `Computer` class provides desktop UI automation capabilities including mouse operations, keyboard input, screen capture, and window management for desktop environments.

## 📖 Related Tutorials

- [Computer UI Automation Guide](../../../../docs/guides/computer-use/computer-ui-automation.md) - Detailed tutorial on desktop UI automation
- [Window Management Guide](../../../../docs/guides/computer-use/window-management.md) - Tutorial on managing application windows

## Overview

The Computer module is designed for desktop automation tasks and requires sessions created with the `windows_latest` image. It provides comprehensive desktop interaction capabilities through MCP tools.

## Properties

The Computer class is accessible through the session object:

```typescript
session.computer: Computer  // Computer automation instance
```

## Mouse Operations

### clickMouse()

Click mouse at specified coordinates.

```typescript
async clickMouse(x: number, y: number, button?: MouseButton | string): Promise<BoolResult>
```

**Parameters:**
- `x` (number): X coordinate for the click
- `y` (number): Y coordinate for the click  
- `button` (MouseButton | string, optional): Mouse button to click. Default is `'left'`

**Valid button values:**
- `'left'` or `MouseButton.LEFT`: Left mouse button
- `'right'` or `MouseButton.RIGHT`: Right mouse button
- `'middle'` or `MouseButton.MIDDLE`: Middle mouse button
- `'double_left'` or `MouseButton.DOUBLE_LEFT`: Double left click

**Returns:**
- `Promise<BoolResult>`: Result with success status and request ID

**Example:**
```typescript
// Verified: ✓ Works successfully
const result = await session.computer.clickMouse(100, 100, 'left');
if (result.success) {
    console.log('Mouse clicked successfully');
} else {
    console.log(`Click failed: ${result.errorMessage}`);
}
```

### moveMouse()

Move mouse to specified coordinates.

```typescript
async moveMouse(x: number, y: number): Promise<BoolResult>
```

**Parameters:**
- `x` (number): Target X coordinate
- `y` (number): Target Y coordinate

**Returns:**
- `Promise<BoolResult>`: Result with success status and request ID

**Example:**
```typescript
// Verified: ✓ Works successfully
const result = await session.computer.moveMouse(100, 100);
if (result.success) {
    console.log('Mouse moved successfully');
    
    // Verify new position
    const pos = await session.computer.getCursorPosition();
    console.log(`New position: (${pos.x}, ${pos.y})`);
}
```

### dragMouse()

Drag mouse from one position to another.

```typescript
async dragMouse(fromX: number, fromY: number, toX: number, toY: number, button?: MouseButton | string): Promise<BoolResult>
```

**Parameters:**
- `fromX` (number): Starting X coordinate
- `fromY` (number): Starting Y coordinate
- `toX` (number): Ending X coordinate
- `toY` (number): Ending Y coordinate
- `button` (MouseButton | string, optional): Mouse button for drag. Default is `'left'`

**Returns:**
- `Promise<BoolResult>`: Result with success status and request ID

**Example:**
```typescript
// Drag from (50, 50) to (150, 150)
const result = await session.computer.dragMouse(50, 50, 150, 150, 'left');
```

### scroll()

Scroll at specified coordinates.

```typescript
async scroll(x: number, y: number, direction?: ScrollDirection | string, amount?: number): Promise<BoolResult>
```

**Parameters:**
- `x` (number): X coordinate to scroll at
- `y` (number): Y coordinate to scroll at
- `direction` (ScrollDirection | string, optional): Scroll direction. Default is `'up'`
- `amount` (number, optional): Scroll amount. Default is 1

**Valid direction values:**
- `'up'` or `ScrollDirection.UP`: Scroll up
- `'down'` or `ScrollDirection.DOWN`: Scroll down
- `'left'` or `ScrollDirection.LEFT`: Scroll left
- `'right'` or `ScrollDirection.RIGHT`: Scroll right

**Returns:**
- `Promise<BoolResult>`: Result with success status and request ID

**Example:**
```typescript
// Scroll up at center of screen
const result = await session.computer.scroll(400, 300, 'up', 3);
```

## Keyboard Operations

### inputText()

Input text at the current cursor position.

```typescript
async inputText(text: string): Promise<BoolResult>
```

**Parameters:**
- `text` (string): Text to input

**Returns:**
- `Promise<BoolResult>`: Result with success status and request ID

**Example:**
```typescript
// Verified: ✓ Works successfully
const result = await session.computer.inputText('Hello AgentBay');
if (result.success) {
    console.log('Text input successfully');
}
```

### pressKeys()

Press one or more keys.

```typescript
async pressKeys(keys: string[], hold?: boolean): Promise<BoolResult>
```

**Parameters:**
- `keys` (string[]): Array of key names to press
- `hold` (boolean, optional): Whether to hold the keys down. Default is false

**Valid key names:**
- `'Enter'`: Enter key (Note: NOT 'Return')
- `'Ctrl'`, `'Alt'`, `'Shift'`: Modifier keys
- `'a'`, `'b'`, etc.: Letter keys
- Other standard key names

**Returns:**
- `Promise<BoolResult>`: Result with success status and request ID

**Example:**
```typescript
// Verified: ✗ 'Return' is invalid, use 'Enter'
const result = await session.computer.pressKeys(['Enter']);
// Correct usage - tested and working with other keys
const ctrlC = await session.computer.pressKeys(['Ctrl', 'c'], true);
```

### releaseKeys()

Release previously pressed keys.

```typescript
async releaseKeys(keys: string[]): Promise<BoolResult>
```

**Parameters:**
- `keys` (string[]): Array of key names to release

**Returns:**
- `Promise<BoolResult>`: Result with success status and request ID

**Example:**
```typescript
// Release Ctrl key after holding
const result = await session.computer.releaseKeys(['Ctrl']);
```

## Screen Operations

### screenshot()

Take a screenshot of the current screen.

```typescript
async screenshot(): Promise<ScreenshotResult>
```

**Returns:**
- `Promise<ScreenshotResult>`: Result containing screenshot URL

**Example:**
```typescript
// Verified: ✓ Works successfully
const result = await session.computer.screenshot();
if (result.success) {
    console.log('Screenshot taken successfully');
    // result.data contains the screenshot URL
    console.log(`Screenshot URL: ${result.data}`);
}
```

### getScreenSize()

Get the current screen size and DPI scaling information.

```typescript
async getScreenSize(): Promise<ScreenSize>
```

**Returns:**
- `Promise<ScreenSize>`: Result containing screen dimensions and DPI scaling

**ScreenSize Interface:**
```typescript
interface ScreenSize extends OperationResult {
  width: number;           // Screen width in pixels
  height: number;          // Screen height in pixels  
  dpiScalingFactor: number; // DPI scaling factor
}
```

**Example:**
```typescript
// Verified: ✓ Returns actual screen size: 1024x768, DPI: 1.0
const result = await session.computer.getScreenSize();
if (result.success) {
    console.log(`Screen: ${result.width}x${result.height}, DPI: ${result.dpiScalingFactor}`);
} else {
    console.log(`Failed to get screen size: ${result.errorMessage}`);
}
```

### getCursorPosition()

Get the current mouse cursor position.

```typescript
async getCursorPosition(): Promise<CursorPosition>
```

**Returns:**
- `Promise<CursorPosition>`: Result containing cursor coordinates

**CursorPosition Interface:**
```typescript
interface CursorPosition extends OperationResult {
  x: number; // X coordinate
  y: number; // Y coordinate
}
```

**Example:**
```typescript
// Verified: ✓ Returns actual cursor position: (512, 384)
const result = await session.computer.getCursorPosition();
if (result.success) {
    console.log(`Cursor at: (${result.x}, ${result.y})`);
} else {
    console.log(`Failed to get cursor position: ${result.errorMessage}`);
}
```

## Window Management

The Computer class provides window management operations that delegate to the WindowManager:

### listRootWindows()

List all root windows in the system.

```typescript
async listRootWindows(timeoutMs?: number): Promise<WindowListResult>
```

**Parameters:**
- `timeoutMs` (number, optional): Timeout in milliseconds. Default is 3000

**Returns:**
- `Promise<WindowListResult>`: Result containing array of window information

**Example:**
```typescript
// Verified: ✓ Works successfully - found 1 window
const result = await session.computer.listRootWindows();
if (result.success) {
    console.log(`Found ${result.windows.length} windows`);
    result.windows.forEach(window => {
        console.log(`Window: ${window.title} (ID: ${window.id})`);
    });
}
```

### getActiveWindow()

Get information about the currently active window.

```typescript
async getActiveWindow(timeoutMs?: number): Promise<WindowInfoResult>
```

**Parameters:**
- `timeoutMs` (number, optional): Timeout in milliseconds. Default is 3000

**Returns:**
- `Promise<WindowInfoResult>`: Result containing active window information

### activateWindow()

Activate (bring to front) the specified window.

```typescript
async activateWindow(windowId: number): Promise<WindowBoolResult>
```

**Parameters:**
- `windowId` (number): ID of the window to activate

**Returns:**
- `Promise<WindowBoolResult>`: Result with success status

### closeWindow()

Close the specified window.

```typescript
async closeWindow(windowId: number): Promise<WindowBoolResult>
```

**Parameters:**
- `windowId` (number): ID of the window to close

**Returns:**
- `Promise<WindowBoolResult>`: Result with success status

### maximizeWindow()

Maximize the specified window.

```typescript
async maximizeWindow(windowId: number): Promise<WindowBoolResult>
```

### minimizeWindow()

Minimize the specified window.

```typescript
async minimizeWindow(windowId: number): Promise<WindowBoolResult>
```

### restoreWindow()

Restore the specified window to its normal state.

```typescript
async restoreWindow(windowId: number): Promise<WindowBoolResult>
```

### resizeWindow()

Resize the specified window.

```typescript
async resizeWindow(windowId: number, width: number, height: number): Promise<WindowBoolResult>
```

**Parameters:**
- `windowId` (number): ID of the window to resize
- `width` (number): New width in pixels
- `height` (number): New height in pixels

### fullscreenWindow()

Make the specified window fullscreen.

```typescript
async fullscreenWindow(windowId: number): Promise<WindowBoolResult>
```

### focusMode()

Toggle focus mode on or off.

```typescript
async focusMode(on: boolean): Promise<WindowBoolResult>
```

**Parameters:**
- `on` (boolean): True to enable focus mode, false to disable

## Type Definitions

### MouseButton Enum

```typescript
enum MouseButton {
  LEFT = 'left',
  RIGHT = 'right', 
  MIDDLE = 'middle',
  DOUBLE_LEFT = 'double_left'
}
```

### ScrollDirection Enum

```typescript
enum ScrollDirection {
  UP = 'up',
  DOWN = 'down',
  LEFT = 'left',
  RIGHT = 'right'
}
```

### BoolResult Interface

```typescript
interface BoolResult extends OperationResult {
  data?: boolean; // Operation result data
}
```

### ScreenshotResult Interface

```typescript
interface ScreenshotResult extends OperationResult {
  data: string; // Screenshot URL
}
```

## Complete Example

```typescript
import { AgentBay } from 'wuying-agentbay-sdk';

async function computerAutomationExample() {
  const agentBay = new AgentBay();
  
  // Create session with Windows image for computer use
  const sessionResult = await agentBay.create({ imageId: 'windows_latest' });
  if (!sessionResult.success) {
    throw new Error(`Failed to create session: ${sessionResult.errorMessage}`);
  }
  
  const session = sessionResult.session;
  
  try {
    // Take initial screenshot
    // Verified: ✓ Works successfully 
    const screenshot = await session.computer.screenshot();
    console.log('Screenshot taken:', screenshot.success);
    
    // Move mouse and click
    // Verified: ✓ Both operations work successfully
    await session.computer.moveMouse(200, 300);
    await session.computer.clickMouse(200, 300, 'left');
    
    // Input some text
    // Verified: ✓ Works successfully
    await session.computer.inputText('Hello from Computer API!');
    
    // Press Enter (use 'Enter', not 'Return')
    // Note: Test failed with 'Return', use correct key names
    await session.computer.pressKeys(['Enter']);
    
    // List windows
    // Verified: ✓ Works successfully - found windows
    const windows = await session.computer.listRootWindows();
    console.log(`Found ${windows.windows?.length || 0} windows`);
    
  } finally {
    // Clean up
    await agentBay.delete(session);
  }
}
```

## Important Notes

1. **Image Requirement**: Computer automation requires sessions created with `imageId: 'windows_latest'`

2. **Key Names**: Use standard key names like `'Enter'`, not `'Return'`. Invalid key names will result in error code -32602.

3. **Coordinate System**: All coordinates are in screen pixels with (0,0) at top-left corner.

4. **Known Issues**: 
   - Some key names may not be supported - verify key names before use (e.g., use 'Enter' not 'Return')

5. **Window Management**: Window operations delegate to WindowManager and work successfully.

6. **Error Handling**: Always check the `success` property of results and handle `errorMessage` appropriately.

7. **Recent Fixes**: Fixed `getScreenSize()` and `getCursorPosition()` data extraction issue (changed from `result.content[0].text` to `result.data`).



# UI Class API Reference

> **⚠️ DEPRECATED**: This API is deprecated. Please use the [Computer API](computer.md) or [Mobile API](../mobile-use/mobile.md) instead for UI automation functionality.

The `UI` class provides methods for interacting with UI elements in the AgentBay cloud environment. This includes retrieving UI elements, sending key events, inputting text, performing gestures, and taking screenshots.

## Properties

###

- `KeyCode`: Constants for key codes that can be used with the `send_key` method.
  - `HOME`: Home key (3)
  - `BACK`: Back key (4)
  - `VOLUME_UP`: Volume up key (24)
  - `VOLUME_DOWN`: Volume down key (25)
  - `POWER`: Power key (26)
  - `MENU`: Menu key (82)

## Methods


Retrieves all clickable UI elements within the specified timeout.


```typescript
getClickableUIElements(timeoutMs?: number): Promise<UIElementListResult>
```

**Parameters:**
- `timeoutMs` (number, optional): The timeout in milliseconds. Default is 2000ms.

**Returns:**
- `Promise<UIElementListResult>`: A promise that resolves to a result object containing clickable UI elements, success status, and request ID.

**Throws:**
- `APIError`: If the operation fails.


```typescript
getAllUIElements(timeoutMs?: number): Promise<UIElementListResult>
```

**Parameters:**
- `timeoutMs` (number, optional): The timeout in milliseconds. Default is 2000ms.

**Returns:**
- `Promise<UIElementListResult>`: A promise that resolves to a result object containing all UI elements, success status, and request ID.

**Throws:**
- `APIError`: If the operation fails.


```typescript
sendKey(key: number): Promise<BoolResult>
```

**Parameters:**
- `key` (number): The key code to send. Use the `KeyCode` constants.

**Returns:**
- `Promise<BoolResult>`: A promise that resolves to a result object containing success status and request ID.

**Throws:**
- `APIError`: If the operation fails.


```typescript
inputText(text: string): Promise<BoolResult>
```

**Parameters:**
- `text` (string): The text to input.

**Returns:**
- `Promise<BoolResult>`: A promise that resolves to a result object containing success status and request ID.

**Throws:**
- `APIError`: If the operation fails.


```typescript
swipe(startX: number, startY: number, endX: number, endY: number, durationMs?: number): Promise<BoolResult>
```

**Parameters:**
- `startX` (number): The starting X coordinate.
- `startY` (number): The starting Y coordinate.
- `endX` (number): The ending X coordinate.
- `endY` (number): The ending Y coordinate.
- `durationMs` (number, optional): The duration of the swipe in milliseconds. Default is 300ms.

**Returns:**
- `Promise<BoolResult>`: A promise that resolves to a result object containing success status and request ID.

**Throws:**
- `APIError`: If the operation fails.


```typescript
click(x: number, y: number, button?: string): Promise<BoolResult>
```

**Parameters:**
- `x` (number): The X coordinate.
- `y` (number): The Y coordinate.
- `button` (string, optional): The mouse button to use. Default is 'left'.

**Returns:**
- `Promise<BoolResult>`: A promise that resolves to a result object containing success status and request ID.

**Throws:**
- `APIError`: If the operation fails.


```typescript
screenshot(): Promise<OperationResult>
```

**Returns:**
- `Promise<OperationResult>`: A promise that resolves to a result object containing screenshot data, success status, and request ID.

**Throws:**
- `APIError`: If the operation fails.




# Window Class

> **⚠️ DEPRECATED**: This API is deprecated. Please use the [Computer API](computer.md) instead for window management functionality.

The Window class provides methods for managing windows in the AgentBay cloud environment, including listing windows, getting the active window, and manipulating window states.

## Overview

The Window class is accessed through a session instance and provides methods for window management in the cloud environment.

## Data Types


Represents a window in the system.


```typescript
interface Window {
    window_id: number;         // The unique identifier of the window
    title: string;             // The title of the window
    absolute_upper_left_x?: number; // The X coordinate of the upper left corner (optional)
    absolute_upper_left_y?: number; // The Y coordinate of the upper left corner (optional)
    width?: number;            // The width of the window (optional)
    height?: number;           // The height of the window (optional)
    pid?: number;              // The process ID of the process that owns the window (optional)
    pname?: string;            // The name of the process that owns the window (optional)
    child_windows?: Window[];  // The child windows of this window (optional)
}
```

## Methods

### listRootWindows

```typescript
async listRootWindows(timeoutMs?: number): Promise<WindowListResult>
```

**Parameters:**
- `timeoutMs` (number, optional): The timeout in milliseconds. Default is 3000ms.

**Returns:**
- `Promise<WindowListResult>`: A promise that resolves to a result object containing the list of root windows and request ID.


### getActiveWindow

```typescript
async getActiveWindow(): Promise<WindowInfoResult>
```

**Returns:
- `Promise<WindowInfoResult>`: A promise that resolves to a result object containing the active window and request ID.


### activateWindow

```typescript
async activateWindow(windowId: number): Promise<BoolResult>
```

**Parameters:
- `windowId` (number): The ID of the window to activate.

**Returns:**
- `Promise<BoolResult>`: A promise that resolves to a result object containing the success status and request ID.


### minimizeWindow

```typescript
async minimizeWindow(windowId: number): Promise<BoolResult>
```

**Parameters:
- `windowId` (number): The ID of the window to minimize.

**Returns:**
- `Promise<BoolResult>`: A promise that resolves to a result object containing the success status and request ID.


### maximizeWindow

```typescript
async maximizeWindow(windowId: number): Promise<BoolResult>
```

**Parameters:
- `windowId` (number): The ID of the window to maximize.

**Returns:**
- `Promise<BoolResult>`: A promise that resolves to a result object containing the success status and request ID.


```typescript
async restoreWindow(windowId: number): Promise<BoolResult>
```

**Parameters:**
- `windowId` (number): The ID of the window to restore.

**Returns:**
- `Promise<BoolResult>`: A promise that resolves to a result object containing the success status and request ID.


```typescript
async fullscreenWindow(windowId: number): Promise<BoolResult>
```

**Parameters:**
- `windowId` (number): The ID of the window to make fullscreen.

**Returns:**
- `Promise<BoolResult>`: A promise that resolves to a result object containing the success status and request ID.


```typescript
async resizeWindow(windowId: number, width: number, height: number): Promise<BoolResult>
```

**Parameters:**
- `windowId` (number): The ID of the window to resize.
- `width` (number): The new width of the window.
- `height` (number): The new height of the window.

**Returns:**
- `Promise<BoolResult>`: A promise that resolves to a result object containing the success status and request ID.


```typescript
async closeWindow(windowId: number): Promise<BoolResult>
```

**Parameters:**
- `windowId` (number): The ID of the window to close.

**Returns:**
- `Promise<BoolResult>`: A promise that resolves to a result object containing the success status and request ID.


```typescript
async focusMode(on: boolean): Promise<BoolResult>
```

**Parameters:**
- `on` (boolean): True to enable focus mode, False to disable it.

**Returns:**
- `Promise<BoolResult>`: A promise that resolves to a result object containing the success status and request ID.




# Mobile Class

The `Mobile` class provides mobile UI automation capabilities including touch operations, text input, app management, and UI element inspection for mobile environments.

## 📖 Related Tutorials

- [Mobile UI Automation Guide](../../../../docs/guides/mobile-use/mobile-ui-automation.md) - Detailed tutorial on mobile UI automation
- [Mobile Application Management Guide](../../../../docs/guides/mobile-use/mobile-application-management.md) - Tutorial on managing mobile applications

## Overview

The Mobile module is designed for mobile device automation tasks and requires sessions created with a mobile environment image (e.g., `mobile_latest`). It provides comprehensive mobile interaction capabilities through MCP tools.

## Properties

The Mobile class is accessible through the session object:

```typescript
session.mobile: Mobile  // Mobile automation instance
```

## Touch Operations

### tap()

Tap at specified coordinates on the mobile screen.

```typescript
async tap(x: number, y: number): Promise<BoolResult>
```

**Parameters:**
- `x` (number): X coordinate for the tap
- `y` (number): Y coordinate for the tap

**Returns:**
- `Promise<BoolResult>`: Result with success status and request ID

**Example:**
```typescript
// Verified: ✓ Works successfully
const result = await session.mobile.tap(100, 100);
if (result.success) {
    console.log('Tap executed successfully');
} else {
    console.log(`Tap failed: ${result.errorMessage}`);
}
```

### swipe()

Swipe from one position to another on the mobile screen.

```typescript
async swipe(startX: number, startY: number, endX: number, endY: number, durationMs?: number): Promise<BoolResult>
```

**Parameters:**
- `startX` (number): Starting X coordinate
- `startY` (number): Starting Y coordinate
- `endX` (number): Ending X coordinate
- `endY` (number): Ending Y coordinate
- `durationMs` (number, optional): Swipe duration in milliseconds. Default is 300

**Returns:**
- `Promise<BoolResult>`: Result with success status and request ID

**Example:**
```typescript
// Verified: ✓ Works successfully - swipe up gesture
const result = await session.mobile.swipe(200, 400, 200, 100, 300);
if (result.success) {
    console.log('Swipe gesture completed successfully');
}
```

## Text Input Operations

### inputText()

Input text at the current focus position.

```typescript
async inputText(text: string): Promise<BoolResult>
```

**Parameters:**
- `text` (string): Text to input

**Returns:**
- `Promise<BoolResult>`: Result with success status and request ID

**Example:**
```typescript
// Verified: ✓ Works successfully
const result = await session.mobile.inputText('Hello Mobile');
if (result.success) {
    console.log('Text input successfully');
}
```

### sendKey()

Send Android key code to the device.

```typescript
async sendKey(key: number): Promise<BoolResult>
```

**Parameters:**
- `key` (number): Android key code to send

**Common Android Key Codes:**
- `4`: KEYCODE_BACK - Back button
- `3`: KEYCODE_HOME - Home button  
- `82`: KEYCODE_MENU - Menu button
- `84`: KEYCODE_SEARCH - Search button
- `66`: KEYCODE_ENTER - Enter key

**Returns:**
- `Promise<BoolResult>`: Result with success status and request ID

**Example:**
```typescript
// Verified: ✗ Timeout occurred - may need longer session warmup
const result = await session.mobile.sendKey(4); // Back button
if (result.success) {
    console.log('Key sent successfully');
} else {
    console.log(`Send key failed: ${result.errorMessage}`);
    // Error seen: "mqtt message response timeout"
}
```

## UI Element Inspection

### getClickableUIElements()

Get all clickable UI elements on the current screen.

```typescript
async getClickableUIElements(timeoutMs?: number): Promise<UIElementsResult>
```

**Parameters:**
- `timeoutMs` (number, optional): Timeout in milliseconds. Default is 5000

**Returns:**
- `Promise<UIElementsResult>`: Result containing array of clickable UI elements

**UIElement Interface:**
```typescript
interface UIElement {
  text: string;        // Element text content
  className: string;   // Element class name
  bounds: {           // Element bounding rectangle
    left: number;
    top: number;
    right: number;
    bottom: number;
  };
}
```

**Example:**
```typescript
// Verified: ✗ Returns "No content in response" - needs investigation
const result = await session.mobile.getClickableUIElements(5000);
if (result.success) {
    console.log(`Found ${result.elements.length} clickable elements`);
    result.elements.forEach(element => {
        console.log(`Element: ${element.text} at (${element.bounds.left}, ${element.bounds.top})`);
    });
} else {
    console.log(`Failed to get clickable elements: ${result.errorMessage}`);
}
```

### getAllUIElements()

Get all UI elements on the current screen.

```typescript
async getAllUIElements(timeoutMs?: number): Promise<UIElementsResult>
```

**Parameters:**
- `timeoutMs` (number, optional): Timeout in milliseconds. Default is 3000

**Returns:**
- `Promise<UIElementsResult>`: Result containing array of all UI elements

**Example:**
```typescript
// Verified: ✗ Returns "No content in response" - needs investigation
const result = await session.mobile.getAllUIElements(3000);
if (result.success) {
    console.log(`Found ${result.elements.length} UI elements`);
} else {
    console.log(`Failed to get UI elements: ${result.errorMessage}`);
}
```

## App Management

### getInstalledApps()

Get list of installed applications on the device.

```typescript
async getInstalledApps(startMenu?: boolean, desktop?: boolean, ignoreSystemApps?: boolean): Promise<InstalledAppsResult>
```

**Parameters:**
- `startMenu` (boolean, optional): Include apps from start menu. Default is false
- `desktop` (boolean, optional): Include apps from desktop. Default is true
- `ignoreSystemApps` (boolean, optional): Exclude system apps. Default is true

**Returns:**
- `Promise<InstalledAppsResult>`: Result containing array of installed applications

**InstalledApp Interface:**
```typescript
interface InstalledApp {
  name: string;          // Application name
  startCmd: string;      // Command to start the app
  workDirectory: string; // Working directory
}
```

**Example:**
```typescript
// Verified: ✗ Returns "No content in response" - needs investigation
const result = await session.mobile.getInstalledApps();
if (result.success) {
    console.log(`Found ${result.apps.length} installed apps`);
    result.apps.forEach(app => {
        console.log(`App: ${app.name} - ${app.startCmd}`);
    });
} else {
    console.log(`Failed to get apps: ${result.errorMessage}`);
}
```

### startApp()

Start an application by its start command.

```typescript
async startApp(startCmd: string, workDirectory?: string, activity?: string): Promise<ProcessResult>
```

**Parameters:**
- `startCmd` (string): Command to start the application
- `workDirectory` (string, optional): Working directory for the app. Default is empty
- `activity` (string, optional): Specific activity to start. Default is empty

**Returns:**
- `Promise<ProcessResult>`: Result containing information about started processes

**Process Interface:**
```typescript
interface Process {
  pid: number;    // Process ID
  pname: string;  // Process name
}
```

**Example:**
```typescript
// Start a specific app
const result = await session.mobile.startApp('com.example.app/.MainActivity');
if (result.success) {
    console.log('App started successfully');
    result.processes.forEach(process => {
        console.log(`Process: ${process.pname} (PID: ${process.pid})`);
    });
}
```

### stopAppByPName()

Stop an application by its process name.

```typescript
async stopAppByPName(pname: string): Promise<BoolResult>
```

**Parameters:**
- `pname` (string): Process name of the application to stop

**Returns:**
- `Promise<BoolResult>`: Result with success status and request ID

**Example:**
```typescript
const result = await session.mobile.stopAppByPName('com.example.app');
if (result.success) {
    console.log('App stopped successfully');
}
```

## Screen Operations

### screenshot()

Take a screenshot of the current mobile screen.

```typescript
async screenshot(): Promise<ScreenshotResult>
```

**Returns:**
- `Promise<ScreenshotResult>`: Result containing screenshot URL

**ScreenshotResult Interface:**
```typescript
interface ScreenshotResult extends OperationResult {
  data: string; // Screenshot URL
}
```

**Example:**
```typescript
// Verified: ✓ Works successfully
const result = await session.mobile.screenshot();
if (result.success) {
    console.log('Screenshot taken successfully');
    // result.data contains the screenshot URL
    console.log(`Screenshot URL available: ${result.data ? 'Yes' : 'No'}`);
}
```

## Type Definitions

### BoolResult Interface

```typescript
interface BoolResult extends OperationResult {
  data?: boolean; // Operation result data
}
```

### UIElementsResult Interface

```typescript
interface UIElementsResult extends OperationResult {
  elements: UIElement[]; // Array of UI elements
}
```

### InstalledAppsResult Interface

```typescript
interface InstalledAppsResult extends OperationResult {
  apps: InstalledApp[]; // Array of installed applications
}
```

### ProcessResult Interface

```typescript
interface ProcessResult extends OperationResult {
  processes: Process[]; // Array of processes
}
```

## Complete Example

```typescript
import { AgentBay } from 'wuying-agentbay-sdk';

async function mobileAutomationExample() {
  const agentBay = new AgentBay();
  
  // Create session with mobile image for mobile use
  const sessionResult = await agentBay.create({ imageId: 'mobile_latest' });
  if (!sessionResult.success) {
    throw new Error(`Failed to create session: ${sessionResult.errorMessage}`);
  }
  
  const session = sessionResult.session;
  
  try {
    // Wait for mobile environment to be ready
    console.log('Waiting for mobile session to be ready...');
    await new Promise(resolve => setTimeout(resolve, 10000));
    
    // Take initial screenshot
    // Verified: ✓ Works successfully
    const screenshot = await session.mobile.screenshot();
    console.log('Screenshot taken:', screenshot.success);
    
    // Perform basic touch operations
    // Verified: ✓ Both operations work successfully
    await session.mobile.tap(150, 200);
    await session.mobile.swipe(200, 400, 200, 100, 300); // Swipe up
    
    // Input some text
    // Verified: ✓ Works successfully
    await session.mobile.inputText('Hello from Mobile API!');
    
    // Try to get installed apps (may need session warmup)
    const apps = await session.mobile.getInstalledApps();
    if (apps.success) {
      console.log(`Found ${apps.apps.length} installed apps`);
    } else {
      console.log('Could not retrieve apps - may need longer warmup time');
    }
    
    // Navigate back (may timeout - needs investigation)
    const backResult = await session.mobile.sendKey(4); // Back key
    if (!backResult.success) {
      console.log('Back key timeout - this is a known issue');
    }
    
  } finally {
    // Clean up
    await agentBay.delete(session);
  }
}
```

## Important Notes

1. **Image Requirement**: Mobile automation requires sessions created with a mobile environment image (e.g., `imageId: 'mobile_latest'`)

2. **Session Warmup**: Mobile sessions may need extra time (10+ seconds) to fully initialize before all APIs work properly.

3. **Coordinate System**: All coordinates are in device pixels with (0,0) at top-left corner.

4. **Known Issues**:
   - UI element retrieval (`getClickableUIElements()`, `getAllUIElements()`) returns "No content in response" - needs investigation
   - App management (`getInstalledApps()`) may return "No content in response" - may need longer session warmup
   - Key sending (`sendKey()`) may timeout with "mqtt message response timeout" - needs investigation

5. **Working Features**: 
   - ✓ Screenshot capture works reliably
   - ✓ Touch operations (tap, swipe) work successfully  
   - ✓ Text input works successfully

6. **Timeout Handling**: Mobile operations may take longer than desktop operations. Consider using longer timeouts for complex operations.

7. **Error Handling**: Always check the `success` property of results and handle `errorMessage` appropriately. Some operations may fail during session initialization period.

## Android Key Codes Reference

Common Android key codes for use with `sendKey()`:

| Key Code | Constant Name | Description |
|----------|---------------|-------------|
| 3 | KEYCODE_HOME | Home button |
| 4 | KEYCODE_BACK | Back button |
| 19 | KEYCODE_DPAD_UP | Directional pad up |
| 20 | KEYCODE_DPAD_DOWN | Directional pad down |
| 21 | KEYCODE_DPAD_LEFT | Directional pad left |
| 22 | KEYCODE_DPAD_RIGHT | Directional pad right |
| 23 | KEYCODE_DPAD_CENTER | Directional pad center |
| 66 | KEYCODE_ENTER | Enter key |
| 82 | KEYCODE_MENU | Menu button |
| 84 | KEYCODE_SEARCH | Search button |

## ADB Connection

### getAdbUrl()

Retrieves the ADB (Android Debug Bridge) connection URL for the mobile environment.

**Important:** This method is only supported in mobile environments. Using other environment types will result in an error.

```typescript
async getAdbUrl(adbkeyPub: string): Promise<AdbUrlResult>
```

**Parameters:**
- `adbkeyPub` (string): ADB public key for authentication

**Returns:**
- `Promise<AdbUrlResult>`: Result containing the ADB connection URL

**AdbUrlResult Interface:**
```typescript
interface AdbUrlResult {
  requestId: string;      // Request ID for tracking
  success: boolean;       // Whether the operation succeeded
  data?: string;          // ADB connection URL (e.g., "adb connect xx.xx.xx.xx:xxxxx")
  url?: string;           // Alias for data
  errorMessage: string;   // Error message if operation failed
}
```

**Example:**
```typescript
// Verified: ✓ Returns valid ADB connection URL
const adbkeyPub = "QAAAAM0muSn7yQCY...your_adb_public_key...EAAQAA=";

const result = await session.mobile.getAdbUrl(adbkeyPub);
if (result.success) {
    console.log(`ADB URL: ${result.data}`);
    // Example output: "adb connect xx.xx.xx.xx:xxxxx"
    console.log(`Request ID: ${result.requestId}`);
} else {
    console.error(`Error: ${result.errorMessage}`);
}
```

**Using the ADB Connection:**

Once you have the ADB URL, you can use it to connect to the mobile device:

```bash
# Connect to the mobile device
adb connect xx.xx.xx.xx:xxxxx

# Verify the connection
adb devices

# Now you can use standard ADB commands
adb shell
adb install app.apk
adb logcat
adb pull /sdcard/file.txt
adb push file.txt /sdcard/
```

**Error Handling:**

```typescript
const result = await session.mobile.getAdbUrl(adbkeyPub);
if (!result.success) {
    // Handle errors
    if (result.errorMessage.includes('mobile environment')) {
        console.error('Error: This method requires a mobile environment session');
    } else {
        console.error(`Error: ${result.errorMessage}`);
    }
}
```

**Requirements:**
- Session must be created with a mobile environment image
- Valid ADB public key is required for authentication
- The returned URL format is: `adb connect <IP>:<Port>`

**See Also:**
- [Mobile GetAdbUrl Example](../../examples/mobile-use/mobile-get-adb-url/README.md) - Complete working example



# TypeScript SDK Examples

This directory contains TypeScript examples demonstrating various features and capabilities of the AgentBay SDK.

## 📁 Directory Structure

The examples are organized by feature categories:

```
examples/
├── basic-usage.ts                 # Quick start single-file example
├── common-features/               # Features available across all environments
│   ├── basics/                    # Essential features
│   │   ├── session-creation/      # Session lifecycle management
│   │   ├── command-example/       # Command execution
│   │   ├── filesystem-example/    # File operations and monitoring
│   │   ├── context-management/    # Context creation and management
│   │   ├── data-persistence/      # Data persistence across sessions
│   │   ├── list_sessions/         # Session listing and filtering
│   │   └── get/                   # Session retrieval
│   └── advanced/                  # Advanced features
│       ├── agent-module-example/  # AI-powered automation
│       ├── vpc-session-example/   # Secure isolated network environments
│       └── archive-upload-mode-example/ # Archive upload mode
├── browser-use/                   # Browser automation (browser_latest)
│   ├── browser/                   # Browser automation examples
│   └── extension-example/         # Browser extension management
├── computer-use/                  # Windows desktop automation (windows_latest)
│   └── ui-example/                # UI automation
├── mobile-use/                    # Mobile UI automation (mobile_latest)
│   └── mobile-get-adb-url/        # ADB URL retrieval
└── codespace/                     # Code execution (code_latest)
    └── automation/                # Automation workflows
```

## 🚀 Quick Start

### Single-File Example

The fastest way to get started:

```bash
# Install dependencies
npm install wuying-agentbay-sdk

# Set your API key
export AGENTBAY_API_KEY=your_api_key_here

# Run the quick start example
npx ts-node basic-usage.ts
```

This example demonstrates:
- Initializing the AgentBay client
- Creating sessions
- Basic operations (commands, file operations)
- Session cleanup

## 📚 Feature Categories

### [Common Features](common-features/)

Features available across all environment types (browser, computer, mobile, codespace).

**Basics:**
- **Session Management**: Create, configure, and manage cloud sessions
- **Command Execution**: Execute shell commands in cloud environments
- **File Operations**: Read, write, and manage files
- **Context Management**: Persistent data storage across sessions
- **Data Persistence**: Cross-session data sharing and synchronization

**Advanced:**
- **Agent Module**: AI-powered task automation with natural language
- **VPC Sessions**: Secure isolated network environments
- **Archive Upload**: Archive upload mode configuration

### [Browser Use](browser-use/)

Cloud-based browser automation with Playwright integration.

**Key Features:**
- Cookie and session persistence
- Stealth mode to avoid detection
- CAPTCHA handling capabilities
- Browser extension support
- Proxy configuration
- Custom viewport and fingerprinting

### [Computer Use](computer-use/)

Windows desktop automation for application control and window management.

**Key Features:**
- UI automation
- Desktop workflows
- Screenshot capture

### [Mobile Use](mobile-use/)

Android mobile UI automation for app testing.

**Key Features:**
- ADB URL retrieval
- Mobile device connection
- Remote debugging

### [CodeSpace](codespace/)

Cloud-based development environment for code execution.

**Key Features:**
- Automation workflows
- Shell command execution
- File system operations

## 📋 Prerequisites

### Basic Requirements

- Node.js 16 or later
- TypeScript 4.5 or later
- Valid `AGENTBAY_API_KEY` environment variable

### Installation

```bash
# Install the SDK
npm install wuying-agentbay-sdk

# For browser examples, install Playwright
npm install playwright
npx playwright install chromium

# Install TypeScript and ts-node (if not already installed)
npm install -D typescript ts-node @types/node
```

## 🎯 Running Examples

```bash
# Set your API key
export AGENTBAY_API_KEY=your_api_key_here

# Run any example with ts-node
npx ts-node basic-usage.ts
npx ts-node common-features/basics/session-creation/session-creation.ts

# Or compile and run
tsc basic-usage.ts
node basic-usage.js
```

## 💡 Common Patterns

### Basic Session Creation

```typescript
import { AgentBay, CreateSessionParams } from 'wuying-agentbay-sdk';

async function main() {
  // Initialize client
  const apiKey = process.env.AGENTBAY_API_KEY!;
  const agentBay = new AgentBay(apiKey);
  
  // Create session
  const params: CreateSessionParams = {
    imageId: 'linux_latest',
  };
  
  const result = await agentBay.create(params);
  
  if (result.success) {
    const session = result.session;
    console.log(`Session created: ${session.sessionId}`);
    
    // Use session...
    
    // Cleanup
    await agentBay.delete(session);
  }
}

main().catch(console.error);
```

### File Operations

```typescript
// Write file
await session.fileSystem.writeFile('/tmp/test.txt', 'content');

// Read file
const result = await session.fileSystem.readFile('/tmp/test.txt');
if (result.success) {
  console.log(result.content);
}
```

### Command Execution

```typescript
const result = await session.command.executeCommand('ls -la');
if (result.success) {
  console.log(result.output);
}
```

### Browser Automation

```typescript
import { BrowserOption } from 'wuying-agentbay-sdk';
import { chromium } from 'playwright';

// Initialize browser
const option = new BrowserOption();
await session.browser.initializeAsync(option);

// Connect Playwright
const endpointUrl = session.browser.getEndpointUrl();
const browser = await chromium.connectOverCDP(endpointUrl);
const context = browser.contexts()[0];
const page = await context.newPage();

// Automate...
await page.goto('https://example.com');

await browser.close();
```

## 🎓 Learning Path

### For Beginners

1. Start with [basic-usage.ts](basic-usage.ts)
2. Explore [Common Features - Basics](common-features/basics/)
3. Try environment-specific examples based on your use case

### For Experienced Developers

1. Review [Common Features](common-features/) for SDK capabilities
2. Jump to your specific environment:
   - [Browser Use](browser-use/) for web automation
   - [Computer Use](computer-use/) for desktop automation
   - [Mobile Use](mobile-use/) for mobile automation
   - [CodeSpace](codespace/) for code execution
3. Explore [Advanced Features](common-features/advanced/) for integrations

## 📖 Best Practices

1. **Always Clean Up**: Delete sessions when done to free resources
2. **Error Handling**: Always check `result.success` before using data
3. **Async/Await**: Use async/await for cleaner asynchronous code
4. **Type Safety**: Leverage TypeScript's type system for better code quality
5. **Resource Limits**: Be aware of concurrent session limits

## 🔍 Example Index

### By Use Case

**Web Automation:**
- Browser stealth mode: `browser-use/browser/browser-stealth.ts`
- Cookie persistence: `browser-use/browser/browser-context-cookie-persistence.ts`
- CAPTCHA handling: `browser-use/browser/captcha_tongcheng.ts`

**Desktop Automation:**
- UI automation: `computer-use/ui-example/ui-example.ts`

**Mobile Automation:**
- ADB integration: `mobile-use/mobile-get-adb-url/index.ts`

**Code Execution:**
- Automation: `codespace/automation/automation-example.ts`

**Data Management:**
- File operations: `common-features/basics/filesystem-example/filesystem-example.ts`
- Context management: `common-features/basics/context-management/context-management.ts`
- Data persistence: `common-features/basics/data-persistence/data-persistence.ts`

**Advanced Features:**
- AI Agent: `common-features/advanced/agent-module-example/agent-module-example.ts`
- VPC sessions: `common-features/advanced/vpc-session-example/vpc-session-example.ts`

## 🆘 Troubleshooting

### Resource Creation Delay

If you see "The system is creating resources" message:
- Wait 90 seconds and retry
- This is normal for resource initialization

### API Key Issues

Ensure your API key is properly set:
```bash
export AGENTBAY_API_KEY=your_api_key_here
# Verify
echo $AGENTBAY_API_KEY
```

### Module Issues

If you get module errors:
```bash
# Ensure dependencies are installed
npm install

# Clear cache and reinstall
rm -rf node_modules package-lock.json
npm install
```

### TypeScript Compilation Errors

If you get TypeScript errors:
```bash
# Ensure TypeScript is installed
npm install -D typescript

# Check TypeScript version
npx tsc --version

# Compile with type checking
npx tsc --noEmit
```

## 📚 Related Documentation

- [TypeScript SDK Documentation](../../)
- [API Reference](../api/)
- [Quick Start Guide](../../../docs/quickstart/README.md)
- [Feature Guides](../../../docs/guides/README.md)

## 🤝 Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Documentation](../../../docs/README.md)

---

💡 **Tip**: Start with `basic-usage.ts` for a quick overview, then explore category-specific examples based on your needs.





# Archive Upload Mode Context Sync Example

This directory contains examples demonstrating the Archive upload mode functionality for context synchronization in the AgentBay SDK.

## Overview

The Archive upload mode is designed for efficient file transfer by compressing files before uploading them to the context storage. This is particularly useful when:

- Working with large files
- Dealing with many files
- Optimizing bandwidth usage
- Reducing upload time for compressible content

## Files

### `archive-upload-mode-example.ts`

A comprehensive example that demonstrates:

1. **Context Creation**: Creating a context for Archive upload mode
2. **Sync Policy Configuration**: Setting up sync policy with Archive uploadMode
3. **Session Management**: Creating and managing sessions with context sync
4. **File Operations**: Writing files to the context path
5. **Context Sync**: Synchronizing context before retrieving information
6. **Context Info**: Retrieving context status information
7. **File Listing**: Listing files in context sync directory
8. **Cleanup**: Proper session cleanup and error handling

## Key Features Demonstrated

### Archive Upload Mode Configuration

```typescript
import { UploadMode } from "wuying-agentbay-sdk";

// Configure sync policy with Archive upload mode
const syncPolicy = newSyncPolicy();
syncPolicy.uploadPolicy!.uploadMode = UploadMode.Archive; // Set to Archive mode

// Create context sync with Archive mode
const contextSync = newContextSync(
  contextId,
  "/tmp/archive-mode-test",
  syncPolicy
);
```

### Session Creation with Context Sync

```typescript
const sessionParams: CreateSessionParams = {
  labels: {
    example: `archive-mode-${uniqueId}`,
    type: "archive-upload-demo",
    uploadMode: UploadMode.Archive
  },
  contextSync: [contextSync]
};

const sessionResult = await agentBay.create(sessionParams);
```

### File Operations

```typescript
const fileSystem = new FileSystem(session);

// Write file to context path
const writeResult = await fileSystem.writeFile(filePath, fileContent, "overwrite");
```

### Context Sync and Information Retrieval

```typescript
// Call context sync before getting info
const syncResult = await session.context.sync();

// Get context status information after sync
const infoResult = await session.context.info();

// Display context status details
infoResult.contextStatusData.forEach((status, index) => {
  console.log(`Context ID: ${status.contextId}`);
  console.log(`Path: ${status.path}`);
  console.log(`Status: ${status.status}`);
  console.log(`Task Type: ${status.taskType}`);
});
```

### File Listing in Context Directory

```typescript
// List files in context sync directory
const listResult = await agentBay.context.listFiles(contextId, syncDirPath, 1, 10);

// Display file entries
listResult.entries.forEach((entry, index) => {
  console.log(`FilePath: ${entry.filePath}`);
  console.log(`FileType: ${entry.fileType}`);
  console.log(`FileName: ${entry.fileName}`);
  console.log(`Size: ${entry.size} bytes`);
});
```

## Running the Example

### Prerequisites

1. **Environment Setup**: Set your AgentBay API key
   ```bash
   export AGENTBAY_API_KEY="your-api-key-here"
   ```

2. **Dependencies**: Ensure you have the AgentBay SDK installed
   ```bash
   npm install
   ```

### Execution

```bash
# Navigate to the project root
cd /path/to/wuying-agentbay-sdk

# Run the example
npx ts-node docs/example/archive-upload-mode-example.ts
```

### Expected Output

The example will output detailed logs showing:

```
🚀 Archive Upload Mode Context Sync Example
============================================================

📦 Step 1: Creating context for Archive upload mode...
✅ Context created successfully!
   Context ID: ctx_xxxxx
   Request ID: req_xxxxx

⚙️  Step 2: Configuring sync policy with Archive upload mode...
✅ Sync policy configured with uploadMode: Archive

🔧 Step 3: Creating context sync configuration...
✅ Context sync created:
   Context ID: ctx_xxxxx
   Path: /tmp/archive-mode-test
   Upload Mode: Archive

🏗️  Step 4: Creating session with Archive mode context sync...
✅ Session created successfully!
   Session ID: sess_xxxxx
   Request ID: req_xxxxx
   App Instance ID: app_xxxxx

📝 Step 5: Creating test files in Archive mode context...
📄 Creating file: /tmp/archive-mode-test/test-file-5kb.txt
📊 File content size: 5120 bytes
✅ File write successful!
   Request ID: req_xxxxx

📊 Step 6: Testing context sync and info functionality...
🔄 Calling context sync before getting info...
✅ Context sync successful!
   Sync Request ID: req_xxxxx
📋 Calling context info after sync...
✅ Context info retrieved successfully!
   Info Request ID: req_xxxxx
   Context status data count: X

📋 Context status details:
   [0] Context ID: ctx_xxxxx
       Path: /tmp/archive-mode-test
       Status: Success
       Task Type: upload

🔍 Step 7: Listing files in context sync directory...
✅ List files successful!
   Request ID: req_xxxxx
   Total files found: X

📋 Files in context sync directory:
   [0] FilePath: /tmp/archive-mode-test/test-file-5kb.txt
       FileType: file
       FileName: test-file-5kb.txt
       Size: 5120 bytes

🎉 Archive upload mode example completed successfully!
✅ All operations completed without errors.

🧹 Step 8: Cleaning up session...
✅ Session deleted successfully!
   Success: true
   Request ID: req_xxxxx
```

## Related Documentation

- [Context Sync Documentation](../../../../docs/guides/common-features/basics/data-persistence.md)
- [Session Management Guide](../../../../docs/guides/common-features/basics/session-management.md)
- [File Operations Guide](../../../../docs/guides/common-features/basics/file-operations.md)

## Troubleshooting

### Common Issues

1. **API Key Not Set**
   ```
   Warning: AGENTBAY_API_KEY environment variable not set
   ```
   **Solution**: Set the environment variable or update the API key in the code

2. **Context Creation Failed**
   ```
   Context creation failed: [error message]
   ```
   **Solution**: Check your API key and network connectivity

3. **Session Creation Failed**
   ```
   Session creation failed: [error message]
   ```
   **Solution**: Verify context sync configuration and try again

4. **File Operation Failed**
   ```
   File write failed: [error message]
   ```
   **Solution**: Check file path permissions and available disk space

## Support

For additional help:
- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Documentation Home](../README.md)



# TypeScript Browser Examples

This directory contains TypeScript examples demonstrating browser automation capabilities of the AgentBay SDK.

## Prerequisites

1. **Install TypeScript SDK**:
   ```bash
   npm install @wuying-org/agentbay-sdk
   ```

2. **Install Playwright**:
   ```bash
   npm install playwright
   npx playwright install chromium
   ```

3. **Set API Key**:
   ```bash
   export AGENTBAY_API_KEY=your_api_key_here
   ```

## Examples

### 1. basic-usage.ts

A basic example showing how to:
- Create a session with a browser-enabled image
- Initialize the browser with default options
- Connect to the browser using Playwright over CDP
- Navigate to a website and interact with it
- Proper cleanup of resources

**Run:**
```bash
ts-node basic-usage.ts
```

**Key Features:**
- Session creation and management
- Browser initialization
- CDP connection with Playwright
- Basic navigation
- Resource cleanup

### 2. browser-viewport.ts

Demonstrates custom viewport and screen configuration:
- Setting custom user agent
- Configuring viewport dimensions
- Setting screen dimensions
- Verifying browser configuration

**Run:**
```bash
ts-node browser-viewport.ts
```

**Key Features:**
- Custom user agent
- Viewport configuration
- Screen dimensions
- Configuration verification

### 3. browser-stealth.ts

Shows how to use stealth mode for anti-detection:
- Enabling stealth mode
- Bypassing bot detection
- Accessing protected content

**Run:**
```bash
ts-node browser-stealth.ts
```

**Key Features:**
- Stealth mode configuration
- Anti-detection measures
- Protected content access

### 4. browser-proxies.ts

Demonstrates proxy configuration:
- Custom proxy setup
- WuYing proxy strategies (restricted/polling)
- Proxy authentication

**Run:**
```bash
ts-node browser-proxies.ts
```

**Key Features:**
- Custom proxy configuration
- WuYing proxy integration
- Proxy authentication
- IP rotation strategies

### 5. browser-context-cookie-persistence.ts

Demonstrates cookie persistence across sessions:
- Creating sessions with Browser Context
- Setting cookies manually using Playwright
- Deleting sessions with context synchronization
- Verifying cookie persistence in new sessions

**Run:**
```bash
ts-node browser-context-cookie-persistence.ts
```

**Key Features:**
- Browser Context configuration
- Cookie persistence
- Cross-session data sharing
- Resource cleanup

### 6. browser-type-example.ts

Comprehensive example demonstrating browser type selection:
- Chrome browser initialization
- Chromium browser initialization
- Default browser (undefined) usage
- Browser configuration verification
- Type-safe TypeScript patterns

**Run:**
```bash
# Run full example (tests all browser types)
ts-node browser-type-example.ts

# Run quick example (Chrome only)
ts-node browser-type-example.ts --quick

# Run type-safe example (demonstrates TypeScript types)
ts-node browser-type-example.ts --type-safe
```

**Key Features:**
- Browser type selection for Chrome, Chromium, and default
- TypeScript type safety demonstration
- Configuration validation
- Browser detection and verification
- Multiple usage patterns (BrowserOptionClass vs plain object)
- Command-line options for different test modes

### 7. Game Automation Examples

**run-2048.ts** and **run-sudoku.ts** demonstrate:
- Complex interaction patterns
- Agent-based automation for games
- Advanced browser control
- AI-powered game solving

**Run:**
```bash
ts-node run-2048.ts
ts-node run-sudoku.ts
```

## Browser Type Selection

When using computer use images, you can choose between Chrome and Chromium:

```typescript
import { BrowserOptionClass } from '@wuying-org/agentbay-sdk';

// Use Chrome
const option = new BrowserOptionClass(
  false,  // useStealth
  undefined,  // userAgent
  undefined,  // viewport
  undefined,  // screen
  undefined,  // fingerprint
  false,  // solveCaptchas
  undefined,  // proxies
  'chrome' as 'chrome'  // browserType
);

// Or use plain object
const option = { browserType: 'chrome' as 'chrome' };

// Use Chromium
const option = { browserType: 'chromium' as 'chromium' };

// Use default (undefined - let image decide)
const option = new BrowserOptionClass();
```

## Common Patterns

### Basic Browser Initialization

```typescript
import { AgentBay, CreateSessionParams, BrowserOptionClass } from '@wuying-org/agentbay-sdk';

const agentBay = new AgentBay(process.env.AGENTBAY_API_KEY!);
const params = new CreateSessionParams({ imageId: 'browser_latest' });
const result = await agentBay.create(params);

if (!result.success || !result.session) {
  throw new Error("Failed to create session");
}

const session = result.session;
const option = new BrowserOptionClass();
const success = await session.browser.initializeAsync(option);

if (!success) {
  throw new Error("Browser initialization failed");
}
```

### Connecting Playwright

```typescript
import { chromium } from 'playwright';

const endpointUrl = session.browser.getEndpointUrl();
const browser = await chromium.connectOverCDP(endpointUrl);
const context = browser.contexts()[0];
const page = await context.newPage();

// Use page...

await browser.close();
session.delete();
```

### Error Handling

```typescript
try {
  const success = await session.browser.initializeAsync(option);
  if (!success) {
    throw new Error("Initialization failed");
  }
  
  // Use browser...
  
} catch (error) {
  console.error(`Error: ${error.message}`);
} finally {
  session.delete();
}
```

### Type-Safe Configuration

```typescript
import { BrowserOption } from '@wuying-org/agentbay-sdk';

const option: BrowserOption = {
  browserType: 'chrome',  // Type-checked
  useStealth: true,
  viewport: { width: 1920, height: 1080 },
  fingerprint: {
    devices: ["desktop"],
    operatingSystems: ["windows", "macos"],
    locales: ["en-US"]
  }
};
```

## Troubleshooting

### "AGENTBAY_API_KEY not set"

Set your API key:
```bash
export AGENTBAY_API_KEY=your_api_key_here
```

### "Browser not initialized"

Ensure the browser is initialized before connecting:
```typescript
if (!session.browser.isInitialized()) {
  throw new Error("Browser must be initialized first");
}
```

### "Failed to connect over CDP"

Check that the browser initialization was successful:
```typescript
const success = await session.browser.initializeAsync(option);
console.log(`Initialization success: ${success}`);
```

### TypeScript Compilation Errors

Ensure you have the correct types:
```bash
npm install --save-dev @types/node
```

## Additional Resources

- [Browser API Reference](../../../api/browser-use/browser.md)
- [Browser Use Guide](../../../../../docs/guides/browser-use/README.md)
- [Core Features](../../../../../docs/guides/browser-use/core-features.md)
- [Advanced Features](../../../../../docs/guides/browser-use/advance-features.md)
- [Playwright Documentation](https://playwright.dev/docs/intro)

## Example Output

### Successful Execution

```
Creating session...
Session created: sess-xxxxx
Initializing browser...
Browser initialized successfully
CDP endpoint: ws://...
Connecting to browser...
Page title: Example Domain
Browser automation completed
Session deleted
```

### With Stealth Mode

```
Creating session with stealth mode...
Browser initialized with stealth enabled
Bypassing bot detection...
Successfully accessed protected content
```

### With Custom Configuration

```
Initializing browser with custom configuration...
User Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)...
Viewport: 1920 x 1080
Screen: 1920 x 1080
Configuration verified successfully
```




# Extension Management Example

This example demonstrates comprehensive browser extension management functionality using the Wuying AgentBay SDK for TypeScript.

## Overview

The extension management system allows you to:
- Upload browser extensions (.zip files) to cloud storage
- List and manage existing extensions  
- Create extension configurations for browser sessions
- Integrate extensions with browser automation workflows
- Handle multiple extensions in a single session
- Implement complete development workflows

## File Structure

```
extension-example/
├── extension-example.ts    # Comprehensive extension management examples
└── README.md             # This documentation file
```

## Key Components

### 1. Extension Class
Represents a browser extension with ID, name, and creation timestamp.

```typescript
const extension = new Extension('ext_123', 'my-extension.zip', '2023-01-01');
```

### 2. ExtensionOption Class
Configuration for browser extension integration, encapsulating context ID and extension IDs.

```typescript
const option = new ExtensionOption('context_123', ['ext_1', 'ext_2']);
```

### 3. ExtensionsService Class
Main service for managing extensions with automatic context handling.

```typescript
const service = new ExtensionsService(agentBay, 'my_extensions');
```

## Examples Included

The `extension-example.ts` file contains comprehensive examples demonstrating:

### 1. Basic Extension Management
- Upload a single extension
- Create extension options
- Integrate with browser sessions
- Basic error handling

### 2. Multiple Extensions Handling
- Upload multiple extensions
- Create sessions with multiple extensions
- Batch operations

### 3. Extension Development Workflow
- Complete development lifecycle
- Testing and validation patterns
- Extension updates
- Development context management

### 4. Error Handling and Validation
- Proper validation patterns
- Common error scenarios
- Best practices for error management

## Quick Start

### Prerequisites

1. **API Key**: Set your AgentBay API key
   ```bash
   export AGENTBAY_API_KEY="your-api-key-here"
   ```

2. **Extension Files**: Prepare your browser extension ZIP files
   - Extensions must be in ZIP format
   - Update file paths in the example code

### Running the Example

```bash
# Navigate to the TypeScript directory
cd typescript

# Install dependencies
npm install

# Build the project
npm run build

# Run the extension example
node docs/examples/extension-example/extension-example.js
```

### Code Example

```typescript
import { AgentBay, ExtensionsService } from "wuying-agentbay-sdk";
import { CreateSessionParams, BrowserContext } from "wuying-agentbay-sdk";

// Initialize AgentBay client
const agentBay = new AgentBay({
  apiKey: process.env.AGENTBAY_API_KEY,
});

// Create extensions service
const extensionsService = new ExtensionsService(agentBay, "browser_extensions");

try {
  // Upload extension
  const extension = await extensionsService.create("/path/to/extension.zip");
  
  // Create extension option
  const extOption = extensionsService.createExtensionOption([extension.id]);
  
  // Create browser session with extension
  const sessionParams = new CreateSessionParams()
    .withLabels({ purpose: "extension_demo" })
    .withBrowserContext(new BrowserContext(
      "browser_session",
      true,
      extOption
    ));
  
  const sessionResult = await agentBay.create(sessionParams.toJSON());
  const session = sessionResult.session;
  
  console.log(`Session created with extension: ${session.sessionId}`);
  
} finally {
  // Clean up resources
  await extensionsService.cleanup();
}
```

## Extension Integration

### Browser Context Integration

Extensions are automatically synchronized to `/tmp/extensions/` in browser sessions:

```typescript
// Extension option contains all necessary configuration
const extOption = extensionsService.createExtensionOption(['ext_1', 'ext_2']);

// Use with BrowserContext
const browserContext = new BrowserContext(
  "browser_session",
  true,          // auto-upload
  extOption      // extension configuration
);
```

### Context Management

The service supports two context modes:

1. **Named Context**: Provide a specific context name
   ```typescript
   new ExtensionsService(agentBay, "my_extensions")
   ```

2. **Auto-Generated Context**: Let the service generate a context name
   ```typescript
   new ExtensionsService(agentBay) // Generates: extensions-{timestamp}
   ```

## API Reference

### ExtensionsService Methods

- `create(localPath: string)` - Upload new extension
- `list()` - List all extensions in context
- `update(extensionId: string, newLocalPath: string)` - Update existing extension
- `delete(extensionId: string)` - Delete extension
- `createExtensionOption(extensionIds: string[])` - Create browser integration option
- `cleanup()` - Clean up auto-created contexts

### ExtensionOption Methods

- `validate()` - Validate configuration
- `toString()` - String representation
- `toDisplayString()` - Human-readable description

## Error Handling

The examples demonstrate comprehensive error handling:

```typescript
try {
  const extension = await extensionsService.create(extensionPath);
  // Handle success
} catch (error) {
  if (error.message.includes('File not found')) {
    console.log('Extension file does not exist');
  } else if (error.message.includes('Invalid format')) {
    console.log('Extension must be a ZIP file');
  } else {
    console.log('Upload failed:', error.message);
  }
}
```

## File Requirements

- **Format**: Extensions must be in ZIP format (.zip)
- **Structure**: Standard Chrome extension structure with manifest.json
- **Size**: Check AgentBay documentation for size limits
- **Permissions**: Ensure proper file permissions for reading

## Common Use Cases

1. **Extension Development**: Upload, test, and iterate on extensions
2. **Automated Testing**: Test extensions in cloud browser environments
3. **Batch Operations**: Manage multiple extensions simultaneously
4. **CI/CD Integration**: Automate extension deployment workflows

## Troubleshooting

### Common Issues

1. **File Not Found**: Ensure extension paths are correct
2. **Invalid Format**: Only ZIP files are supported
3. **API Key Missing**: Set AGENTBAY_API_KEY environment variable
4. **Context Conflicts**: Use unique context names for different projects

### Best Practices

1. **Always cleanup**: Use try/finally blocks for resource cleanup
2. **Validate inputs**: Check file existence before upload
3. **Handle errors**: Implement proper error handling for all operations
4. **Use descriptive names**: Name contexts and sessions clearly

## Next Steps

- Explore the complete API documentation at `typescript/docs/api/browser-use/extension.md`
- Check browser automation examples for integration patterns
- Review the AgentBay SDK documentation for advanced features
- Consider implementing custom validation and testing workflows

## Related Resources

- [Extension API Reference](../../../api/browser-use/extension.md) - Complete API documentation
- [Session API Reference](../../../api/common-features/basics/session.md) - Browser session management
- [Context API Reference](../../../api/common-features/basics/context.md) - Context management
- [AgentBay SDK Documentation](../../../api/common-features/basics/agentbay.md) - Core SDK features



# Agent Module Example

This example demonstrates how to use the Agent module to execute AI-powered tasks using natural language descriptions.

## Overview

The Agent module allows you to execute complex tasks using human-readable instructions, monitor task status, and terminate running tasks. This capability extends the functionality of cloud sessions by adding AI-powered automation.

## Running the Example

1. Ensure you have the AgentBay SDK installed
2. Set the `AGENTBAY_API_KEY` environment variable with your valid API key
3. Run the example:

```bash
cd docs/examples/typescript
npx ts-node agent-module-example.ts
```

## What the Example Does

1. Initializes the AgentBay client with your API key
2. Creates a new session
3. Executes a simple task using the Agent module ("Calculate the square root of 144")
4. Displays the task results
5. Cleans up by deleting the session

## Key Concepts

- **Session Creation**: All Agent operations happen within a session context
- **Task Execution**: Tasks are executed using natural language descriptions
- **Result Handling**: Task results include success status, output, and error information
- **Resource Management**: Sessions should be properly deleted when no longer needed

## Next Steps

Try modifying the task description to perform different operations, such as:
- "Find the current weather in New York City"
- "Calculate the factorial of 10"
- "List the prime numbers between 1 and 100"




# Archive Upload Mode Context Sync Example

This directory contains examples demonstrating the Archive upload mode functionality for context synchronization in the AgentBay SDK.

## Overview

The Archive upload mode is designed for efficient file transfer by compressing files before uploading them to the context storage. This is particularly useful when:

- Working with large files
- Dealing with many files
- Optimizing bandwidth usage
- Reducing upload time for compressible content

## Files

### `archive-upload-mode-example.ts`

A comprehensive example that demonstrates:

1. **Context Creation**: Creating a context for Archive upload mode
2. **Sync Policy Configuration**: Setting up sync policy with Archive uploadMode
3. **Session Management**: Creating and managing sessions with context sync
4. **File Operations**: Writing files to the context path
5. **Context Info**: Retrieving context status information
6. **File Verification**: Verifying file information and properties
7. **Cleanup**: Proper session cleanup and error handling

## Key Features Demonstrated

### Archive Upload Mode Configuration

```typescript
// Configure sync policy with Archive upload mode
const syncPolicy = newSyncPolicy();
syncPolicy.uploadPolicy!.uploadMode = "Archive"; // Set to Archive mode

// Create context sync with Archive mode
const contextSync = newContextSync(
  contextId,
  "/tmp/archive-mode-test",
  syncPolicy
);
```

### Session Creation with Context Sync

```typescript
const sessionParams: CreateSessionParams = {
  labels: {
    example: `archive-mode-${uniqueId}`,
    type: "archive-upload-demo",
    uploadMode: "Archive"
  },
  contextSync: [contextSync]
};

const sessionResult = await agentBay.create(sessionParams);
```

### File Operations

```typescript
const fileSystem = new FileSystem(session);

// Write file to context path
const writeResult = await fileSystem.writeFile(filePath, fileContent, "overwrite");

// Get file information
const fileInfoResult = await fileSystem.getFileInfo(filePath);
```

### Context Information Retrieval

```typescript
// Get context status information
const infoResult = await session.context.info();

// Display context status details
infoResult.contextStatusData.forEach((status, index) => {
  console.log(`Context ID: ${status.contextId}`);
  console.log(`Path: ${status.path}`);
  console.log(`Status: ${status.status}`);
  console.log(`Task Type: ${status.taskType}`);
});
```

## Running the Example

### Prerequisites

1. **Environment Setup**: Set your AgentBay API key
   ```bash
   export AGENTBAY_API_KEY="your-api-key-here"
   ```

2. **Dependencies**: Ensure you have the AgentBay SDK installed
   ```bash
   npm install
   ```

### Execution

```bash
# Navigate to the project root
cd /path/to/wuying-agentbay-sdk

# Run the example
npx ts-node docs/example/archive-upload-mode-example.ts
```

### Expected Output

The example will output detailed logs showing:

```
🚀 Archive Upload Mode Context Sync Example
============================================================

📦 Step 1: Creating context for Archive upload mode...
✅ Context created successfully!
   Context ID: ctx_xxxxx
   Request ID: req_xxxxx

⚙️  Step 2: Configuring sync policy with Archive upload mode...
✅ Sync policy configured with uploadMode: Archive

🔧 Step 3: Creating context sync configuration...
✅ Context sync created:
   Context ID: ctx_xxxxx
   Path: /tmp/archive-mode-test
   Upload Mode: Archive

🏗️  Step 4: Creating session with Archive mode context sync...
✅ Session created successfully!
   Session ID: sess_xxxxx
   Request ID: req_xxxxx
   App Instance ID: app_xxxxx

📝 Step 5: Creating test files in Archive mode context...
📄 Creating file: /tmp/archive-mode-test/test-file-5kb.txt
📊 File content size: 5120 bytes
✅ File write successful!
   Request ID: req_xxxxx

📊 Step 6: Testing context info functionality...
✅ Context info retrieved successfully!
   Request ID: req_xxxxx
   Context status data count: X

📋 Context status details:
   [0] Context ID: ctx_xxxxx
       Path: /tmp/archive-mode-test
       Status: Success
       Task Type: upload

🔍 Step 7: Verifying file information...
✅ File info retrieved successfully!
   Request ID: req_xxxxx
📄 File details:
   Size: 5120 bytes
   Is Directory: false
   Modified Time: 2025-10-22T09:52:00Z
   Mode: 644

🎉 Archive upload mode example completed successfully!
✅ All operations completed without errors.

🧹 Step 8: Cleaning up session...
✅ Session deleted successfully!
   Success: true
   Request ID: req_xxxxx
```

## Related Documentation

- [Context Sync Documentation](../../../../../../docs/guides/common-features/basics/data-persistence.md)
- [Session Management Guide](../../../../../../docs/guides/common-features/basics/session-management.md)
- [File Operations Guide](../../../../../../docs/guides/common-features/basics/file-operations.md)

## Troubleshooting

### Common Issues

1. **API Key Not Set**
   ```
   Warning: AGENTBAY_API_KEY environment variable not set
   ```
   **Solution**: Set the environment variable or update the API key in the code

2. **Context Creation Failed**
   ```
   Context creation failed: [error message]
   ```
   **Solution**: Check your API key and network connectivity

3. **Session Creation Failed**
   ```
   Session creation failed: [error message]
   ```
   **Solution**: Verify context sync configuration and try again

4. **File Operation Failed**
   ```
   File write failed: [error message]
   ```
   **Solution**: Check file path permissions and available disk space

## Support

For additional help:
- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Documentation Home](../../../../../../README.md)



# VPC Session Example

This example demonstrates how to create and use VPC (Virtual Private Cloud) sessions with the AgentBay SDK.

## Overview

VPC sessions provide enhanced security and networking capabilities by running your cloud sessions within a private network environment. This example shows how to create a VPC session and use its available modules.

## Running the Example

1. Ensure you have the AgentBay SDK installed
2. Set the `AGENTBAY_API_KEY` environment variable with your valid API key
3. Run the example:

```bash
cd docs/examples/typescript
npx ts-node vpc-session-example.ts
```

## What the Example Does

1. Initializes the AgentBay client with your API key
2. Creates a new VPC session with specific parameters
3. Tests FileSystem operations by writing and reading a file
4. Tests Command operations by executing system commands
5. Cleans up by deleting the session

## Key Concepts

- **VPC Session Creation**: VPC sessions are created by setting the `isVpc` parameter to `true`
- **Module Availability**: VPC sessions have limited module availability compared to standard sessions
- **Resource Management**: VPC sessions should be properly deleted when no longer needed
- **Security**: VPC sessions provide network isolation for sensitive operations

## Available Modules in VPC Sessions

1. **FileSystem**: File and directory operations
2. **Command**: Command execution
3. **System Tools**: Specialized system-level tools
4. **Browser Tools**: Browser automation capabilities

## Next Steps

Try modifying the example to:
- Use context synchronization with VPC sessions
- Test different command executions
- Implement error handling for unavailable modules



# Command Execution Example

This example demonstrates how to use the command execution features of the AgentBay SDK for TypeScript.

## Features Demonstrated

- Executing shell commands
- Setting custom timeouts for commands
- Running Python code
- Running JavaScript code
- Executing multi-line command sequences

## Running the Example

1. Make sure you have installed the AgentBay SDK:

```bash
npm install wuying-agentbay-sdk
```

2. Set your API key as an environment variable (recommended):

```bash
export AGENTBAY_API_KEY=your_api_key_here
```

3. Compile and run the example:

```bash
# Compile TypeScript
cd command-example
npx ts-node command-example.ts
```

## Code Explanation

The example demonstrates different ways to execute commands:

1. Basic shell command execution
2. Command execution with custom timeout
3. Running Python code
4. Running JavaScript code with custom timeout
5. Executing a multi-line shell command sequence

The code also demonstrates proper error handling and resource cleanup using try-finally.

For more details on command execution, see the [Command API Reference](../../../../api/common-features/basics/command.md) and [Command Execution Tutorial](../../../../../../docs/guides/common-features/basics/command-execution.md).




# Context Management Example

This example demonstrates how to use the Context Management features of the AgentBay SDK for TypeScript.

## Features Demonstrated

- Listing all contexts
- Getting or creating a context
- Creating a session with a context
- Updating a context
- Clearing context data (synchronous clear)
- Deleting a context

## Running the Example

1. Make sure you have installed the AgentBay SDK:

```bash
npm install wuying-agentbay-sdk
```

2. Set your API key as an environment variable (recommended):

```bash
export AGENTBAY_API_KEY=your_api_key_here
```

3. Compile and run the example:

```bash
# Compile TypeScript
cd context-management
npx ts-node context-management.ts
```

## Code Explanation

The example demonstrates a full lifecycle of context management:

1. Initialize the AgentBay client with an API key
2. List all existing contexts to see what's available
3. Get an existing context by name, or create it if it doesn't exist
4. Create a session using the context
5. Update the context's properties
6. Clear the context's persistent data (demonstrates synchronous clear method)
7. Clean up by deleting the session and context

Context management allows you to work with persistent storage areas that can be used across multiple sessions. This enables scenarios like:

- Preserving file system changes between sessions
- Maintaining application state across session restarts
- Sharing data between different sessions
- Creating templates for quick session initialization

For more details on context management, see the [Context API Reference](../../../../api/common-features/basics/context.md) and [Data Persistence Tutorial](../../../../../../docs/guides/common-features/basics/data-persistence.md).




# Data Persistence Examples

This directory contains examples demonstrating data persistence functionality in AgentBay SDK for TypeScript.

## Examples

### 1. `data-persistence.ts` - Basic Data Persistence

Demonstrates the fundamental data persistence features:

- Context creation for persistent storage
- File persistence across multiple sessions
- Context synchronization and file sharing
- Multi-session data verification

### 2. `context-sync-demo.ts` - Advanced Sync with Callbacks

Demonstrates the callback-based context synchronization:

- Async context sync operations
- Timing analysis and performance monitoring
- Status verification using `context.info()`
- Multiple sync operations and error handling
- Backward compatibility with traditional sync

### 3. `recycle-policy-example.ts` - Data Lifecycle Management

Demonstrates RecyclePolicy for controlling context data lifecycle:

- Using default RecyclePolicy (keeps data forever)
- Setting custom lifecycle durations (1 day, 3 days, etc.)
- Applying RecyclePolicy to specific paths
- Available lifecycle options

## Key Features

### Data Persistence

- **Context Creation**: Create persistent storage contexts
- **Cross-Session Persistence**: Data survives session deletion
- **File Synchronization**: Automatic sync of files to persistent storage
- **Multi-Session Access**: Access data from different sessions

### Context Sync Callbacks

- **Async Operations**: Non-blocking sync operations
- **Real-time Feedback**: Immediate notification on completion
- **Timing Information**: Detailed performance metrics
- **Error Handling**: Graceful handling of failures and timeouts
- **Status Monitoring**: Track sync progress and completion

### Data Lifecycle Management

- **RecyclePolicy**: Control how long context data is retained in the cloud
- **Lifecycle Options**: 1 day to forever (10 options available)
- **Path-Specific Policies**: Apply different lifecycles to different directories
- **Automatic Cleanup**: Data is automatically deleted after specified duration
- **Path Validation**: Ensures path safety (no wildcard patterns)

## Usage

### Basic Data Persistence

```bash
cd typescript/docs/examples/data-persistence
npx ts-node data-persistence.ts
```

### Context Sync Demo

```bash
cd typescript/docs/examples/data-persistence
npx ts-node context-sync-demo.ts
```

### RecyclePolicy Example

```bash
cd typescript/docs/examples/data-persistence
npx ts-node recycle-policy-example.ts
```

## Prerequisites

- AgentBay SDK installed
- Valid API key configured (via environment variable `AGENTBAY_API_KEY`)
- Network access to AgentBay services
- Node.js 16 or later
- TypeScript 4.5 or later

## Expected Behavior

All examples will:

1. Create a persistent context
2. Create a session with context synchronization
3. Write test data to the persistent storage
4. Demonstrate data persistence across sessions
5. Clean up resources

The callback example additionally shows:

- Async sync operations with timing
- Callback notifications
- Status monitoring
- Error handling scenarios

## Output

All examples provide detailed console output showing:

- Step-by-step progress
- Success/failure status for each operation
- Timing information (callback example)
- Data verification results
- Cleanup confirmation

## Notes

- Examples use temporary contexts that are cleaned up after execution
- File paths use `/tmp/` for demonstration purposes
- Timing may vary based on network conditions and file sizes
- The callback example includes timeout handling for robustness

## Related Documentation

- [Data Persistence Guide](../../../../../../docs/guides/common-features/basics/data-persistence.md) - Comprehensive guide on data persistence
- [Context Management](../context-management/README.md) - Context creation and management
- [File Operations](../filesystem-example/README.md) - File handling and management




# Context Sync Dual-Mode Example (TypeScript)

This example demonstrates the dual-mode `context.sync()` functionality in the TypeScript SDK, showing both asynchronous callback-based and synchronous await-based usage patterns.

## Features Demonstrated

- **Context Creation**: Creates persistent contexts for data storage
- **Test Data Generation**: Creates sample files and directories for sync testing
- **Dual-Mode Context Sync**: Shows both callback and await patterns
- **Session Management**: Proper session creation and cleanup
- **Error Handling**: Comprehensive error handling and cleanup
- **Timing Measurement**: Tracks sync operation duration
- **Concurrent Execution**: Demonstrates running multiple sync operations

## Usage Patterns

### 1. Async Mode with Callback

```typescript
// Immediate return with callback handling
const syncResult = await session.context.sync(
  undefined, // contextId
  undefined, // path
  undefined, // mode
  (success: boolean) => {
    if (success) {
      console.log("✅ Context sync completed successfully");
    } else {
      console.log("❌ Context sync completed with failures");
    }
  }
);
```

### 2. Sync Mode with Await

```typescript
// Wait for completion before returning
const syncResult = await session.context.sync();
if (syncResult.success) {
  console.log("✅ Context sync completed successfully");
} else {
  console.log("❌ Context sync completed with failures");
}
```

## Key Differences from Python Version

- **TypeScript/JavaScript**: Uses `Promise` and `async/await` instead of Python's `asyncio`
- **Callback Pattern**: Uses arrow functions for callbacks
- **Timing**: Uses `Date.now()` for millisecond precision timing
- **Error Handling**: Uses try/catch blocks with Promise-based error handling

## Running the Example

```bash
# From the typescript directory
npm run build
node dist/docs/examples/data-persistence/context-sync-demo.js
```

## Expected Output

```
🔄 AgentBay Context Sync Dual-Mode Example (TypeScript)

============================================================
🔄 Method 1: context_sync_with_callback (Async with callback)
============================================================
🔄 Starting context sync with callback demo...

📦 Creating context for persistent storage...
✅ Context created: sync-callback-demo

📦 Creating session with context sync...
✅ Session created: session-123

💾 Creating test data...
✅ Created file: /tmp/sync_data/test_files/small.txt
✅ Created file: /tmp/sync_data/test_files/medium.txt
✅ Created file: /tmp/sync_data/config.json
📊 Created 3/3 test files

📞 Calling context.sync() with callback...
📤 Sync initiation result: success=true, requestId=req-456
⏳ Waiting for callback to complete...
✅ Context sync completed successfully in 2000ms
🗑️  Deleting session from callback...
✅ Session deleted successfully from callback

⏳ Sleeping 3 seconds before next demo...

============================================================
🔄 Method 2: context_sync (Sync with await)
============================================================
🔄 Starting context sync demo...

📦 Creating context for persistent storage...
✅ Context created: sync-await-demo

📦 Creating session with context sync...
✅ Session created: session-789

💾 Creating test data...
✅ Created file: /tmp/sync_data/test_files/small.txt
✅ Created file: /tmp/sync_data/test_files/medium.txt
✅ Created file: /tmp/sync_data/config.json
📊 Created 3/3 test files

⏳ Calling context.sync() with await...
✅ Context sync completed successfully in 1500ms
📤 Sync result: success=true, requestId=req-101
🗑️  Deleting session...
✅ Session deleted successfully

⏳ Waiting for callback demo to complete...

✅ Context sync dual-mode example completed
```

## Configuration

The example uses default configuration values:

- **Max Retries**: 150 attempts
- **Retry Interval**: 1500ms (1.5 seconds)
- **Timeout**: ~5 minutes (150 × 1.5s)

## Error Handling

The example includes comprehensive error handling:

- Sync operation failures
- Session creation failures
- Session deletion failures
- Automatic cleanup on errors

## Integration with Session Deletion

The example demonstrates how `context.sync()` integrates with session deletion:

- Callback mode: Session deletion happens in the callback
- Await mode: Session deletion happens after sync completion
- Both modes avoid double-syncing by passing `false` to `session.delete()`




# Filesystem Operations Example

This example demonstrates how to use the AgentBay SDK to perform various filesystem operations within a session.

## Features Demonstrated

- Directory Operations:
  - Creating directories
  - Listing directory contents

- File Operations:
  - Writing files
  - Reading files
  - Getting file information
  - Editing file content
  - Moving/renaming files
  - Searching for files

- File Transfer Operations:
  - Uploading files from local to remote environment
  - Downloading files from remote to local environment
  - Progress tracking during file transfers

## Running the Examples

Make sure you have set your AgentBay API key as an environment variable:

```bash
export AGENTBAY_API_KEY="your-api-key-here"
```

### Basic Filesystem Operations

```bash
cd filesystem-example
npx ts-node filesystem-example.ts
```

### Directory Monitoring

```bash
cd filesystem-example
npx ts-node watch-directory-example.ts
```

### File Transfer Operations

```bash
cd filesystem-example
npx ts-node filesystem-filetransfer-example.ts
```

## Note

The example uses the `/tmp` directory for all operations to ensure it has the necessary permissions. Some operations might not be supported in all session types or environments. The example includes error handling to handle such cases gracefully.

File transfer operations require proper session context configuration for optimal performance. The examples demonstrate best practices for handling file transfers with progress tracking and error handling.



# Get API Example

This example demonstrates how to use the `get` API to retrieve a session by its ID.

## Description

The `get` API allows you to retrieve a session object by providing its session ID. This is useful when you have a session ID from a previous operation and want to access or manage that session.

## Prerequisites

- Node.js 16 or higher
- TypeScript 4.5 or higher
- Valid API key set in `AGENTBAY_API_KEY` environment variable
- wuying-agentbay-sdk package installed

## Installation

```bash
npm install wuying-agentbay-sdk
# or
yarn add wuying-agentbay-sdk
```

## Usage

```bash
# Set your API key
export AGENTBAY_API_KEY="your-api-key-here"

# Compile and run the example
npx ts-node main.ts
```

## Code Example

```typescript
import { AgentBay } from "wuying-agentbay-sdk";

async function main() {
  // Initialize AgentBay client
  const apiKey = process.env.AGENTBAY_API_KEY;
  const agentBay = new AgentBay({ apiKey });

  // Retrieve a session by ID
  const sessionId = "your-session-id";
  const result = await agentBay.get(sessionId);

  if (result.success && result.session) {
    console.log(`Retrieved session: ${result.session.sessionId}`);
    console.log(`Request ID: ${result.requestId}`);
    // Use the session for further operations
    // ...
  } else {
    console.error(`Failed to get session: ${result.errorMessage}`);
  }
}

main();
```

## API Reference

### get

```typescript
async get(sessionId: string): Promise<SessionResult>
```

Get a session by its ID.

**Parameters:**
- `sessionId` (string): The ID of the session to retrieve

**Returns:**
- `Promise<SessionResult>`: Promise resolving to result object containing:
  - `success` (boolean): Whether the operation succeeded
  - `session` (Session): The Session instance if successful
  - `requestId` (string): The API request ID
  - `errorMessage` (string): Error message if failed

## Expected Output

```
Creating a session...
Created session with ID: session-xxxxxxxxxxxxx

Retrieving session using Get API...
Successfully retrieved session:
  Session ID: session-xxxxxxxxxxxxx
  Request ID: DAD825FE-2CD8-19C8-BB30-CC3BA26B9398

Session is ready for use

Cleaning up...
Session session-xxxxxxxxxxxxx deleted successfully
```

## Notes

- The session ID must be valid and from an existing session
- The get API internally calls the GetSession API endpoint
- The returned session object can be used for all session operations (commands, files, etc.)
- Always clean up sessions when done to avoid resource waste

## Error Handling

The `get` method returns a `SessionResult` object with error information:

1. **Empty session_id**: Result will have `success: false`
   ```typescript
   const result = await agentBay.get("");
   if (!result.success) {
     console.error(`Error: ${result.errorMessage}`);  // "session_id is required"
   }
   ```

2. **Non-existent session**: Result will have `success: false`
   ```typescript
   const result = await agentBay.get("non-existent-session-id");
   if (!result.success) {
     console.error(`Error: ${result.errorMessage}`);  // "Failed to get session..."
   }
   ```

## TypeScript Support

This example is fully typed with TypeScript. The `get` method returns a typed `SessionResult` object with full IDE autocomplete support.

```typescript
import { AgentBay, Session } from "wuying-agentbay-sdk";

const agentBay = new AgentBay({ apiKey: "your-key" });
const session: Session = await agentBay.get("session-id");
// TypeScript knows all methods and properties of session
```





# List Sessions Example (TypeScript)

This example demonstrates how to use the `list()` API to query and filter sessions in AgentBay.

## Prerequisites

1. **Install dependencies**:
   ```bash
   npm install wuying-agentbay-sdk
   npm install -D typescript ts-node @types/node
   ```

2. **Set API Key**:
   ```bash
   export AGENTBAY_API_KEY='your-api-key-here'
   ```

## Running the Example

```bash
cd /path/to/wuying-agentbay-sdk/typescript/docs/examples/list_sessions
npx ts-node main.ts
```

## Key Features

- List all sessions
- Filter by single or multiple labels
- Pagination support
- Iterate through all pages

## API Usage

```typescript
import { AgentBay } from "wuying-agentbay-sdk";

const agentBay = new AgentBay(apiKey);

// List all sessions
const result = await agentBay.list();

// Filter by labels
const filtered = await agentBay.list({ project: "my-project" });

// With pagination
const page1 = await agentBay.list({ project: "my-project" }, 1, 10);
const page2 = await agentBay.list({ project: "my-project" }, 2, 10);
```

## Related Documentation

- [Session Management Guide](../../../../../../docs/guides/common-features/basics/session-management.md)
- [AgentBay API Reference](../../../../api/common-features/basics/agentbay.md)





# Session Creation and Management Example

This example demonstrates how to create, list, and delete sessions using the Wuying AgentBay SDK. It covers:

- Initializing the AgentBay client
- Creating a session with default parameters
- Listing all available sessions
- Creating multiple sessions
- Deleting sessions
- Verifying session deletion

This example is useful for understanding the session lifecycle and how to manage multiple sessions.

## Running the Example

```bash
cd session-creation
npx ts-node session-creation.ts
```

Make sure you have set the `AGENTBAY_API_KEY` environment variable or replace the placeholder in the code with your actual API key.

## Prerequisites

- Node.js installed
- TypeScript installed
- ts-node installed (`npm install -g ts-node`)
- Required dependencies installed (`npm install`)




# UI Interaction Example

This example demonstrates how to use the UI interaction features of the AgentBay SDK for TypeScript.

## Features Demonstrated

- Creating a session with a mobile image
- Taking screenshots
- Getting all UI elements
- Getting clickable UI elements
- Sending key events
- Inputting text
- Clicking on screen positions
- Performing swipe gestures
- Saving screenshots to local files

## Running the Example

1. Make sure you have installed the AgentBay SDK:

```bash
npm install wuying-agentbay-sdk
```

2. Set your API key as an environment variable (recommended):

```bash
export AGENTBAY_API_KEY=your_api_key_here
```

3. Compile and run the example:

```bash
# Compile TypeScript
cd ui-example
npx ts-node ui-example.ts
```

## Code Explanation

The example demonstrates UI interactions in a remote session:

1. Create a new session with a mobile image
2. Take screenshots of the remote environment
3. Get all UI elements from the screen
4. Find clickable UI elements
5. Send key events to the environment
6. Input text
7. Perform mouse click operations
8. Simulate touch and swipe gestures
9. Take a second screenshot after interactions
10. Clean up by deleting the session

The example also includes a helper function to parse bounds strings from UI elements, which helps determine element positions for interactions.

UI interaction capabilities are particularly useful for:

- Automated testing of mobile applications
- Building mobile app automation tools
- Creating mobile app demos
- Implementing mobile device control applications
- Developing UI testing frameworks

For more details on UI interaction, see the [UI API Reference](../../../api/computer-use/ui.md).




# Mobile GetAdbUrl Example

This example demonstrates how to retrieve an ADB (Android Debug Bridge) connection URL for a mobile session.

## Prerequisites

- Node.js 14 or higher
- AgentBay API key
- A mobile session (`mobile_latest` image)

## Installation

```bash
npm install @aliyun/wuying-agentbay-sdk
```

## Usage

1. Set your API key:
```bash
export AGENTBAY_API_KEY=your_api_key_here
```

2. Run the example:
```bash
npx ts-node index.ts
```

## Expected Output

```
=== Mobile GetAdbUrl Example ===

Creating mobile session...
✅ Session created successfully
   Session ID: session-xxxxx
   Image ID: mobile_latest

Getting ADB connection URL...
✅ ADB URL retrieved successfully
   URL: adb connect xx.xx.xx.xx:xxxxx
   Request ID: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx

You can now connect to the mobile device using:
   adb connect xx.xx.xx.xx:xxxxx

=== Example completed successfully ===

Cleaning up session...
✅ Session deleted successfully (RequestID: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)
```

## Using the ADB Connection

Once you have the ADB URL, you can connect to the mobile device:

```bash
# Connect to the device
adb connect xx.xx.xx.xx:xxxxx

# Verify the connection
adb devices

# Now you can use standard ADB commands
adb shell
adb install app.apk
adb logcat
adb pull /sdcard/file.txt
adb push file.txt /sdcard/
```

## Important Notes

1. **Environment Requirement**: This method only works with `mobile_latest` image sessions
2. **ADB Public Key**: You need to provide your ADB public key for authentication
3. **Connection URL Format**: The returned URL is in the format `adb connect <IP>:<Port>`
4. **Session Cleanup**: Always delete the session when done to avoid resource leaks

## Error Handling

The example includes proper error handling for common scenarios:
- Missing API key
- Session creation failure
- ADB URL retrieval failure
- Session deletion issues

## See Also

- [Mobile API Documentation](../../../api/mobile-use/mobile.md)
- [Session Management Guide](../../../../../docs/guides/common-features/basics/session-management.md)
- [Mobile Use Guide](../../../../../docs/guides/mobile-use/README.md)






# Golang SDK Documentation


# AgentBay SDK for Golang

> Execute commands, manipulate files, and run code in cloud environments

## 📦 Installation

```bash
go get github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay
```

## 🚀 Prerequisites

Before using the SDK, you need to:

1. Register an Alibaba Cloud account: [https://aliyun.com](https://aliyun.com)
2. Get API credentials: [AgentBay Console](https://agentbay.console.aliyun.com/service-management)
3. Set environment variable: `export AGENTBAY_API_KEY=your_api_key`

## 🚀 Quick Start
```go
package main

import (
    "fmt"
    "github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
)

func main() {
    // Create session
    client, err := agentbay.NewAgentBay("", nil)
    if err != nil {
        fmt.Printf("Initialization failed: %v\n", err)
        return
    }
    // Verified: ✓ Client initialized successfully

    result, err := client.Create(nil)
    if err != nil {
        fmt.Printf("Session creation failed: %v\n", err)
        return
    }
    // Verified: ✓ Session created with ID like "session-04bdwfj7u2a668axp"

    session := result.Session

    // Execute command
    cmdResult, err := session.Command.ExecuteCommand("ls -la")
    if err == nil {
        fmt.Printf("Command output: %s\n", cmdResult.Output)
    }
    // Verified: ✓ Command executed successfully
    // Sample output: "总计 100\ndrwxr-x--- 16 wuying wuying 4096..."

    // File operations
    session.FileSystem.WriteFile("/tmp/test.txt", "Hello World", "")
    fileResult, err := session.FileSystem.ReadFile("/tmp/test.txt")
    if err == nil {
        fmt.Printf("File content: %s\n", fileResult.Content)
    }
    // Verified: ✓ File written and read successfully
    // Output: "File content: Hello World"
}
```

## 📖 Complete Documentation

### 🆕 New Users
- [📚 Quick Start Tutorial](../docs/quickstart/README.md) - Get started in 5 minutes
- [🎯 Core Concepts](../docs/quickstart/basic-concepts.md) - Understanding cloud environments and sessions

### 🚀 Experienced Users
**Choose Your Cloud Environment:**
- 🌐 [Browser Use](../docs/guides/browser-use/README.md) - Web scraping, browser testing, form automation
- 🖥️ [Computer Use](../docs/guides/computer-use/README.md) - Windows desktop automation, UI testing
- 📱 [Mobile Use](../docs/guides/mobile-use/README.md) - Android UI testing, mobile app automation
- 💻 [CodeSpace](../docs/guides/codespace/README.md) - Code execution, development environments

**Additional Resources:**
- [📖 Feature Guides](../docs/guides/README.md) - Complete feature introduction
- [🔧 Go API Reference](docs/api/README.md) - Detailed API documentation
- [💻 Go Examples](docs/examples/README.md) - Complete example code
- [📋 Logging Configuration](../docs/guides/common-features/configuration/logging.md) - Configure logging levels and output

## 🔧 Core Features Quick Reference

### Session Management
```go
// Create session
result, _ := client.Create(nil)
session := result.Session
// Verified: ✓ Session created successfully
```

### File Operations
```go
// Read and write files
session.FileSystem.WriteFile("/path/file.txt", "content", "")
result, _ := session.FileSystem.ReadFile("/path/file.txt")
content := result.Content
// Verified: ✓ File operations work correctly
// Output: content contains the file's text content

// List directory
files, _ := session.FileSystem.ListDirectory("/path")
// Verified: ✓ Returns list of FileInfo objects
```

### Command Execution
```go
// Execute command
result, _ := session.Command.ExecuteCommand("go run script.go")
fmt.Println(result.Output)
// Verified: ✓ Command executed successfully
// Output contains the command's stdout
```

### Data Persistence
```go
// Create context
contextResult, _ := client.Context.Get("my-project", true)
context := contextResult.Context
// Verified: ✓ Context created or retrieved successfully

// Create session with context
policy := agentbay.NewSyncPolicy()
contextSync := agentbay.NewContextSync(context.ID, "/tmp/data", policy)
params := agentbay.NewCreateSessionParams().AddContextSyncConfig(contextSync)
sessionResult, _ := client.Create(params)
// Verified: ✓ Session created with context synchronization
// Data in /tmp/data will be synchronized to the context
```

## 🆘 Get Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Complete Documentation](../docs/README.md)

## 📄 License

This project is licensed under the Apache License 2.0 - see the [LICENSE](../LICENSE) file for details.




# AgentBay Golang SDK API Reference

Complete API reference documentation for the AgentBay Golang SDK.

## 📚 Common Features

APIs available across all environments:

### Basics
- [**AgentBay**](common-features/basics/agentbay.md) - Main client for creating and managing sessions
- [**Session**](common-features/basics/session.md) - Session lifecycle and operations management
- [**Command**](common-features/basics/command.md) - Execute shell commands in cloud environments
- [**FileSystem**](common-features/basics/filesystem.md) - File and directory operations
- [**Context**](common-features/basics/context.md) - Data persistence and context management
- [**ContextManager**](common-features/basics/context-manager.md) - Context operations and file synchronization
- [**Logging**](common-features/basics/logging.md) - Logging configuration and management

### Advanced
- [**Agent**](common-features/advanced/agent.md) - AI agent integration and MCP tools
- [**OSS**](common-features/advanced/oss.md) - Object Storage Service integration

## 🚀 Environment-Specific Features

### Browser Use (`browser_latest`)
- [**Browser**](browser-use/browser.md) - Browser initialization and CDP connection
  - `Initialize()` / `InitializeAsync()` - Initialize browser with configuration options
  - `GetEndpointURL()` - Get CDP WebSocket endpoint for Playwright/Puppeteer connection
  - Options: Stealth mode, proxy (custom/wuying), fingerprint, viewport, CAPTCHA solving
  - AI Agent: `Agent.Act()`, `Agent.Observe()`, `Agent.Extract()` for natural language automation

### Computer Use (`windows_latest`, `linux_latest`)
- [**Computer**](computer-use/computer.md) - Desktop automation operations
  - Mouse: `ClickMouse()`, `MoveMouse()`, `DragMouse()`, `Scroll()`, `GetCursorPosition()`
  - Keyboard: `InputText()`, `PressKeys()`, `ReleaseKeys()`
  - Screen: `Screenshot()`, `GetScreenSize()`
  - Window: `ListRootWindows()`, `GetActiveWindow()`, `ActivateWindow()`, `CloseWindow()`, `MaximizeWindow()`, `MinimizeWindow()`, `RestoreWindow()`, `ResizeWindow()`, `FullscreenWindow()`, `FocusMode()`
  - Application: `GetInstalledApps()`, `StartApp()`, `ListVisibleApps()`, `StopAppByPname()`, `StopAppByPid()`, `StopAppByCmd()`
- [**UI**](computer-use/ui.md) - ⚠️ Deprecated, use Computer or Mobile APIs instead
- [**Window**](computer-use/window.md) - ⚠️ Deprecated, use Computer API instead
- [**Application**](computer-use/application.md) - ⚠️ Deprecated, use Computer or Mobile APIs instead

### Mobile Use (`mobile_latest`)
- [**Mobile**](mobile-use/mobile.md) - Android mobile device automation
  - Touch: `Tap()`, `Swipe()`
  - Input: `InputText()`, `SendKey()` (with KeyCode constants)
  - UI Elements: `GetClickableUIElements()`, `GetAllUIElements()`
  - Application: `GetInstalledApps()`, `StartApp()`, `StopAppByCmd()`
  - Screen: `Screenshot()`

### CodeSpace (`code_latest`)
- [**Code**](codespace/code.md) - Execute code in cloud environment
  - `RunCode()` - Run Python or JavaScript code with timeout control
  - Supports: Python, JavaScript
  - Maximum execution time: 60 seconds (gateway limitation)

## 📘 Related Documentation

- [Feature Guides](../../../docs/guides/README.md) - Detailed usage guides and tutorials
- [Code Examples](../examples/README.md) - Complete example implementations
- [Quick Start](../../../docs/quickstart/README.md) - Get started in 5 minutes

---

**Need help?** Check out the [complete documentation](../../../docs/README.md) or [open an issue](https://github.com/aliyun/wuying-agentbay-sdk/issues).




# Browser API Reference

The Browser API provides methods for initializing and managing browser instances in the AgentBay cloud environment. It supports both headless and non-headless browsers with extensive configuration options including stealth mode, custom viewports, fingerprinting, proxies, and more.

## Overview

The Browser API is accessed through a session instance and provides methods for browser lifecycle management and connection to automation frameworks via Chrome DevTools Protocol (CDP).

```go
import "github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay/browser"

// Access browser through session
session := result.Session
browserAPI := session.Browser
```

## Data Types

### BrowserOption

Configuration options for initializing a browser instance.

```go
type BrowserOption struct {
    UseStealth         bool                `json:"useStealth,omitempty"`         // Enable stealth mode
    UserAgent          *string             `json:"userAgent,omitempty"`          // Custom user agent
    Viewport           *BrowserViewport    `json:"viewport,omitempty"`           // Viewport configuration
    Screen             *BrowserScreen      `json:"screen,omitempty"`             // Screen configuration
    Fingerprint        *BrowserFingerprint `json:"fingerprint,omitempty"`        // Fingerprint configuration
    SolveCaptchas      bool                `json:"solveCaptchas,omitempty"`      // Auto-solve captchas
    Proxies            []*BrowserProxy     `json:"proxies,omitempty"`            // Proxy configurations
    ExtensionPath      *string             `json:"extensionPath,omitempty"`      // Path to extensions directory
    BrowserType        *string             `json:"browserType,omitempty"`        // Browser type: "chrome" or "chromium"
    CmdArgs            []string            `json:"cmdArgs,omitempty"`            // Chrome/Chromium command-line arguments
    DefaultNavigateUrl *string             `json:"defaultNavigateUrl,omitempty"` // Default navigation URL after initialization
}
```

**Field Descriptions:**

- `UseStealth`: Enables stealth mode to avoid detection by anti-bot systems
- `UserAgent`: Custom user agent string for the browser
- `Viewport`: Browser viewport dimensions (affects the visible area)
- `Screen`: Screen dimensions (affects screen properties)
- `Fingerprint`: Browser fingerprint configuration for randomization
- `SolveCaptchas`: Automatically solve captchas during browsing
- `Proxies`: List of proxy configurations (maximum 1 proxy)
- `ExtensionPath`: Path to directory containing browser extensions
- `BrowserType`: Browser type selection - `"chrome"` or `"chromium"` (computer use images only), or `nil` for default
- `CmdArgs`: List of Chrome/Chromium command-line arguments to customize browser behavior
- `DefaultNavigateUrl`: URL that the browser automatically navigates to after initialization. Recommended to use Chrome internal pages (e.g., `"chrome://version/"`) to avoid timeout issues

### BrowserViewport

Defines the browser viewport dimensions.

```go
type BrowserViewport struct {
    Width  int `json:"width"`  // Viewport width in pixels
    Height int `json:"height"` // Viewport height in pixels
}
```

**Common Viewport Sizes:**
- Desktop: `1920x1080`, `1366x768`, `1280x720`
- Laptop: `1440x900`, `1366x768`
- Tablet: `1024x768`, `768x1024`
- Mobile: `375x667`, `414x896`

### BrowserScreen

Defines the screen dimensions (usually same or larger than viewport).

```go
type BrowserScreen struct {
    Width  int `json:"width"`  // Screen width in pixels
    Height int `json:"height"` // Screen height in pixels
}
```

### BrowserFingerprint

Configuration for browser fingerprint randomization.

```go
type BrowserFingerprint struct {
    Devices          []string `json:"devices,omitempty"`          // Device types
    OperatingSystems []string `json:"operatingSystems,omitempty"` // Operating systems
    Locales          []string `json:"locales,omitempty"`          // Locale strings
}
```

**Valid Values:**

- **Devices**: `"desktop"`, `"mobile"`
- **Operating Systems**: `"windows"`, `"macos"`, `"linux"`, `"android"`, `"ios"`
- **Locales**: Standard locale strings (e.g., `"en-US"`, `"zh-CN"`, `"ja-JP"`)

**Example:**
```go
fingerprint := &browser.BrowserFingerprint{
    Devices:          []string{"desktop"},
    OperatingSystems: []string{"windows", "macos"},
    Locales:          []string{"en-US", "en-GB"},
}
```

### BrowserProxy

Configuration for browser proxy settings.

```go
type BrowserProxy struct {
    Type         string  `json:"type"`                   // Proxy type: "custom" or "wuying"
    Server       *string `json:"server,omitempty"`       // Proxy server (for custom type)
    Username     *string `json:"username,omitempty"`     // Proxy username (optional)
    Password     *string `json:"password,omitempty"`     // Proxy password (optional)
    Strategy     *string `json:"strategy,omitempty"`     // Proxy strategy (for wuying type)
    PollSize     *int    `json:"pollSize,omitempty"`     // Poll size (for polling strategy)
}
```

**Proxy Types:**

1. **Custom Proxy** (`type: "custom"`):
   ```go
   server := "proxy.example.com:8080"
   username := "user"
   password := "pass"
   
   proxy := &browser.BrowserProxy{
       Type:     "custom",
       Server:   &server,
       Username: &username,
       Password: &password,
   }
   ```

2. **WuYing Proxy** (`type: "wuying"`):
   - **Restricted Strategy**: Uses a single dedicated IP
     ```go
     strategy := "restricted"
     proxy := &browser.BrowserProxy{
         Type:     "wuying",
         Strategy: &strategy,
     }
     ```
   
   - **Polling Strategy**: Rotates through a pool of IPs
     ```go
     strategy := "polling"
     pollSize := 10
     proxy := &browser.BrowserProxy{
         Type:     "wuying",
         Strategy: &strategy,
         PollSize: &pollSize,
     }
     ```

**Validation Rules:**
- Maximum 1 proxy allowed in the `Proxies` list
- `Server` is required for `custom` type
- `Strategy` is required for `wuying` type
- `PollSize` must be > 0 for `polling` strategy

## Methods

### NewBrowserOption

Creates a new BrowserOption with default values.

```go
func NewBrowserOption() *BrowserOption
```

**Returns:**
- `*BrowserOption`: A new BrowserOption instance with default values

**Default Values:**
- `UseStealth`: `false`
- `SolveCaptchas`: `false`
- `ExtensionPath`: `"/tmp/extensions/"`
- `BrowserType`: `nil` (lets browser image decide)

**Example:**
```go
option := browser.NewBrowserOption()
// Customize as needed
customUA := "Mozilla/5.0 ..."
option.UserAgent = &customUA
```

### Validate

Validates the BrowserOption configuration.

```go
func (o *BrowserOption) Validate() error
```

**Returns:**
- `error`: An error if validation fails, `nil` otherwise

**Validation Rules:**
- Maximum 1 proxy in `Proxies` list
- `ExtensionPath` cannot be empty if provided
- `BrowserType` must be `"chrome"`, `"chromium"`, or `nil`

**Example:**
```go
option := browser.NewBrowserOption()
if err := option.Validate(); err != nil {
    log.Fatalf("Invalid browser option: %v", err)
}
```

### ToMap

Converts BrowserOption to a map for API requests.

```go
func (o *BrowserOption) ToMap() map[string]interface{}
```

**Returns:**
- `map[string]interface{}`: A map representation of the browser options

**Example:**
```go
option := browser.NewBrowserOption()
optionMap := option.ToMap()
// optionMap can be used in API requests
```

### Initialize

Initializes the browser with the given options (synchronous).

```go
func (b *Browser) Initialize(option *BrowserOption) (bool, error)
```

**Parameters:**
- `option` (*BrowserOption): Browser configuration options

**Returns:**
- `bool`: `true` if initialization was successful
- `error`: An error if the operation fails

**Example:**
```go
option := browser.NewBrowserOption()

// Add custom configuration
customUA := "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)"
option.UserAgent = &customUA

option.Viewport = &browser.BrowserViewport{
    Width:  1920,
    Height: 1080,
}

// Initialize browser
success, err := session.Browser.Initialize(option)
if err != nil {
    log.Fatalf("Failed to initialize browser: %v", err)
}
if !success {
    log.Fatal("Browser initialization returned false")
}
```

### GetEndpointURL

Retrieves the CDP (Chrome DevTools Protocol) endpoint URL for connecting automation tools.

```go
func (b *Browser) GetEndpointURL() (string, error)
```

**Returns:**
- `string`: The CDP WebSocket endpoint URL (e.g., `ws://host:port/devtools/browser/...`)
- `error`: An error if the operation fails

**Example:**
```go
endpointURL, err := session.Browser.GetEndpointURL()
if err != nil {
    log.Fatalf("Failed to get endpoint URL: %v", err)
}

// Use with Playwright
browser, err := pw.Chromium.ConnectOverCDP(endpointURL)
```

### IsInitialized

Checks if the browser has been initialized.

```go
func (b *Browser) IsInitialized() bool
```

**Returns:**
- `bool`: `true` if the browser is initialized, `false` otherwise

**Example:**
```go
if session.Browser.IsInitialized() {
    fmt.Println("Browser is ready")
} else {
    fmt.Println("Browser needs initialization")
}
```

### GetOption

Retrieves the current browser configuration.

```go
func (b *Browser) GetOption() *BrowserOption
```

**Returns:**
- `*BrowserOption`: The current browser configuration, or `nil` if not initialized

**Example:**
```go
option := session.Browser.GetOption()
if option != nil {
    fmt.Printf("Browser type: %v\n", option.BrowserType)
}
```

## Complete Usage Example

### Basic Usage

```go
package main

import (
    "fmt"
    "log"
    "os"

    "github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
    "github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay/browser"
    "github.com/playwright-community/playwright-go"
)

func main() {
    // Initialize AgentBay
    agentBay := agentbay.NewAgentBay(os.Getenv("AGENTBAY_API_KEY"))

    // Create session
    params := &agentbay.CreateSessionParams{
        ImageId: "browser_latest",
    }
    result, err := agentBay.Create(params)
    if err != nil || !result.Success {
        log.Fatalf("Failed to create session: %v", err)
    }
    defer result.Session.Delete()

    // Initialize browser with default options
    option := browser.NewBrowserOption()
    success, err := result.Session.Browser.Initialize(option)
    if err != nil || !success {
        log.Fatalf("Browser initialization failed: %v", err)
    }

    // Get CDP endpoint
    endpoint, err := result.Session.Browser.GetEndpointURL()
    if err != nil {
        log.Fatalf("Failed to get endpoint: %v", err)
    }

    // Connect with Playwright
    pw, err := playwright.Run()
    if err != nil {
        log.Fatalf("Failed to start Playwright: %v", err)
    }
    defer pw.Stop()

    browserInstance, err := pw.Chromium.ConnectOverCDP(endpoint)
    if err != nil {
        log.Fatalf("Failed to connect: %v", err)
    }
    defer browserInstance.Close()

    // Use the browser
    page, err := browserInstance.Contexts()[0].NewPage()
    if err != nil {
        log.Fatalf("Failed to create page: %v", err)
    }

    _, err = page.Goto("https://example.com")
    if err != nil {
        log.Fatalf("Failed to navigate: %v", err)
    }

    title, _ := page.Title()
    fmt.Printf("Page title: %s\n", title)
}
```

### Advanced Configuration

```go
// Create custom browser configuration
option := browser.NewBrowserOption()

// Custom user agent
ua := "Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.0.0"
option.UserAgent = &ua

// Viewport and screen
option.Viewport = &browser.BrowserViewport{Width: 1920, Height: 1080}
option.Screen = &browser.BrowserScreen{Width: 1920, Height: 1080}

// Browser type (for computer use images)
chromeType := "chrome"
option.BrowserType = &chromeType

// Stealth mode
option.UseStealth = true

// Command-line arguments
option.CmdArgs = []string{
    "--disable-features=PrivacySandboxSettings4",
    "--disable-background-timer-throttling",
}

// Default navigation URL (recommended: Chrome internal pages)
defaultUrl := "chrome://version/"
option.DefaultNavigateUrl = &defaultUrl

// Fingerprint randomization
option.Fingerprint = &browser.BrowserFingerprint{
    Devices:          []string{"desktop"},
    OperatingSystems: []string{"windows", "macos"},
    Locales:          []string{"en-US"},
}

// Proxy configuration
proxyServer := "proxy.example.com:8080"
proxyUser := "username"
proxyPass := "password"
option.Proxies = []*browser.BrowserProxy{
    {
        Type:     "custom",
        Server:   &proxyServer,
        Username: &proxyUser,
        Password: &proxyPass,
    },
}

// Validate before use
if err := option.Validate(); err != nil {
    log.Fatalf("Invalid configuration: %v", err)
}

// Initialize with custom options
success, err := session.Browser.Initialize(option)
if err != nil || !success {
    log.Fatalf("Failed to initialize: %v", err)
}
```

## Error Handling

### Common Errors

1. **Browser Not Initialized**
   ```go
   endpoint, err := session.Browser.GetEndpointURL()
   if err != nil {
       // Error: "browser not initialized"
       log.Fatal("Initialize browser before getting endpoint")
   }
   ```

2. **Invalid Configuration**
   ```go
   option := browser.NewBrowserOption()
   invalidType := "firefox"
   option.BrowserType = &invalidType
   
   _, err := session.Browser.Initialize(option)
   // Error: "browserType must be 'chrome' or 'chromium'"
   ```

3. **Multiple Proxies**
   ```go
   option.Proxies = []*browser.BrowserProxy{proxy1, proxy2}
   err := option.Validate()
   // Error: "proxies list length must be limited to 1"
   ```

### Best Practices

```go
// Always check both success and error
success, err := session.Browser.Initialize(option)
if err != nil {
    log.Fatalf("Error: %v", err)
}
if !success {
    log.Fatal("Initialization failed without error")
}

// Validate options before initialization
if err := option.Validate(); err != nil {
    log.Fatalf("Invalid options: %v", err)
}

// Check initialization status
if !session.Browser.IsInitialized() {
    log.Fatal("Browser must be initialized first")
}

// Use defer for cleanup
defer session.Delete()
defer pw.Stop()
defer browserInstance.Close()
```

## Browser Type Selection

> **Note:** The `BrowserType` option is only available for **computer use images**. For standard browser images, the browser type is determined by the image.

### Choosing Browser Type

```go
// Use Chrome (Google Chrome)
chromeType := "chrome"
option := browser.NewBrowserOption()
option.BrowserType = &chromeType

// Use Chromium (open-source)
chromiumType := "chromium"
option := browser.NewBrowserOption()
option.BrowserType = &chromiumType

// Use default (nil - let browser image decide)
option := browser.NewBrowserOption()
// option.BrowserType is nil by default
```

### When to Use Each Type

**Chrome** (`"chrome"`):
- Need specific Chrome-only features
- Testing against actual Chrome browser
- Matching production Chrome environment

**Chromium** (`"chromium"`):
- Open-source preference
- Lighter resource usage
- Standard web automation

**Default** (`nil`):
- Let the platform choose optimal browser
- Maximum compatibility
- Recommended for most use cases

## Integration with Automation Tools

### Playwright

```go
import "github.com/playwright-community/playwright-go"

// Get endpoint
endpoint, err := session.Browser.GetEndpointURL()

// Connect Playwright
pw, err := playwright.Run()
defer pw.Stop()

browser, err := pw.Chromium.ConnectOverCDP(endpoint)
defer browser.Close()

page, err := browser.Contexts()[0].NewPage()
```

### Puppeteer (via Node.js)

```go
// Get endpoint
endpoint, err := session.Browser.GetEndpointURL()
fmt.Printf("Use this endpoint in Node.js: %s\n", endpoint)
```

```javascript
// In Node.js
const puppeteer = require('puppeteer-core');
const browser = await puppeteer.connect({
    browserWSEndpoint: 'ws://...' // endpoint from Go
});
```

## Performance Considerations

### Resource Usage

- **Stealth Mode**: Adds overhead for anti-detection measures
- **Fingerprinting**: Randomization has minimal performance impact
- **Proxies**: May add latency depending on proxy location
- **Extensions**: Each extension increases memory usage

### Optimization Tips

1. **Reuse Sessions**: Keep sessions alive for multiple operations
2. **Appropriate Viewport**: Use actual target viewport size
3. **Minimal Extensions**: Only load necessary extensions
4. **Connection Pooling**: Maintain persistent CDP connections

## Troubleshooting

### Browser Won't Initialize

```go
// Check session status
if !result.Success {
    log.Printf("Session creation failed: %s", result.ErrorMessage)
}

// Verify image supports browser
params := &agentbay.CreateSessionParams{
    ImageId: "browser_latest", // Ensure browser-enabled image
}

// Check initialization
success, err := session.Browser.Initialize(option)
log.Printf("Success: %v, Error: %v", success, err)
```

### CDP Connection Fails

```go
// Ensure browser is initialized
if !session.Browser.IsInitialized() {
    log.Fatal("Browser not initialized")
}

// Get and verify endpoint
endpoint, err := session.Browser.GetEndpointURL()
if err != nil {
    log.Fatalf("Cannot get endpoint: %v", err)
}
log.Printf("Endpoint: %s", endpoint)
```

### Configuration Issues

```go
// Validate before use
if err := option.Validate(); err != nil {
    log.Fatalf("Configuration error: %v", err)
}

// Check pointer fields
if option.UserAgent != nil {
    log.Printf("Using custom UA: %s", *option.UserAgent)
}

if option.BrowserType != nil {
    log.Printf("Browser type: %s", *option.BrowserType)
}
```

## See Also

- [Browser Use Guide](../../../../docs/guides/browser-use/README.md) - Complete guide with examples
- [Core Features](../../../../docs/guides/browser-use/core-features.md) - Essential browser features
- [Advanced Features](../../../../docs/guides/browser-use/advance-features.md) - Advanced configuration
- [Browser Examples](../../examples/browser-use/browser/README.md) - Runnable example code
- [Session Management](../common-features/basics/session.md) - Session lifecycle and management





# Code Module - Go

The Code module handles code execution operations in the AgentBay cloud environment.

## 📖 Related Tutorial

- [Code Execution Guide](../../../../docs/guides/codespace/code-execution.md) - Detailed tutorial on executing code in cloud environments

## Methods

### RunCode

Executes code in a specified programming language with a timeout.

```go
RunCode(code string, language string, timeoutS ...int) (*CodeResult, error)
```

**Parameters:**
- `code` (string): The code to execute.
- `language` (string): The programming language of the code. Must be either 'python' or 'javascript'.
- `timeoutS` (int, optional): The timeout for the code execution in seconds. Default is 60s. Note: Due to gateway limitations, each request cannot exceed 60 seconds.

**Returns:**
- `*CodeResult`: A result object containing the execution output and request ID.
- `error`: An error object if the operation fails.

**Important Note:**
The `RunCode` method requires a session created with the `code_latest` image to function properly. If you encounter errors indicating that the tool is not found, make sure to create your session with `ImageId: "code_latest"` in the `CreateSessionParams`.

**Usage Example:**

```go
package main

import (
    "fmt"
    "os"
    
    "github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
)

func main() {
    // Initialize AgentBay with API key
    client, err := agentbay.NewAgentBay("your_api_key", nil)
    if err != nil {
        fmt.Printf("Error initializing AgentBay client: %v\n", err)
        os.Exit(1)
    }

    // Create a session with code_latest image
    params := &agentbay.CreateSessionParams{
        ImageId: "code_latest",
    }
    sessionResult, err := client.Create(params)
    if err != nil {
        fmt.Printf("Error creating session: %v\n", err)
        os.Exit(1)
    }
    session := sessionResult.Session

    // Execute Python code
    pythonCode := `
print("Hello from Python!")
result = 2 + 3
print(f"Result: {result}")
`
    codeResult, err := session.Code.RunCode(pythonCode, "python")
    if err != nil {
        fmt.Printf("Error executing Python code: %v\n", err)
    } else {
        fmt.Printf("Python code output:\n%s\n", codeResult.Output)
        // Expected output:
        // Hello from Python!
        // Result: 5
        fmt.Printf("Request ID: %s\n", codeResult.RequestID)
        // Expected: A valid UUID-format request ID
    }

    // Execute JavaScript code with custom timeout
    jsCode := `
console.log("Hello from JavaScript!");
const result = 2 + 3;
console.log("Result:", result);
`
    jsResult, err := session.Code.RunCode(jsCode, "javascript", 30)
    if err != nil {
        fmt.Printf("Error executing JavaScript code: %v\n", err)
    } else {
        fmt.Printf("JavaScript code output:\n%s\n", jsResult.Output)
        // Expected output:
        // Hello from JavaScript!
        // Result: 5
        fmt.Printf("Request ID: %s\n", jsResult.RequestID)
        // Expected: A valid UUID-format request ID
    }
}
```

## Error Handling

The RunCode method returns an error if:
- The specified language is not supported (only 'python' and 'javascript' are supported)
- The code execution fails in the cloud environment
- Network or API communication errors occur

## Types

### CodeResult

```go
type CodeResult struct {
    ApiResponse  // Embedded ApiResponse containing RequestID
    Output string // The execution output
}
``` 



# Agent Class API Reference

The `Agent` type provides AI-powered capabilities for executing tasks, checking task status, and terminating tasks within a session. It enables natural language task execution and monitoring.

**⚠️ Important Note**: The Agent functionality is verified on the `windows_latest` system image.

## 📖 Related Tutorial

- [Agent Modules Guide](../../../../../docs/guides/common-features/advanced/agent-modules.md) - Detailed tutorial on AI-powered automation with Agent modules

## Constructor

### NewAgent

```go
func NewAgent(session McpSession) *Agent
```

**Parameters:**
- `session` (McpSession): The Session instance that this Agent belongs to.

**Returns:**
- `*Agent`: A new Agent instance.

## Methods

### ExecuteTask

Executes a specific task described in human language.

```go
ExecuteTask(task string, maxTryTimes int) *ExecutionResult
```

**Parameters:**
- `task` (string): Task description in human language.
- `maxTryTimes` (int): Maximum number of retry attempts.

**Returns:**
- `*ExecutionResult`: Result object containing success status, task ID, task status, and error message if any.

**Example:**
```go
package main

import (
	"fmt"
	"os"

	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
)

func main() {
	// Initialize the SDK
	client, err := agentbay.NewAgentBay("your_api_key", nil)
	if err != nil {
		fmt.Printf("Error initializing AgentBay client: %v\n", err)
		os.Exit(1)
	}

	// Create a session with Windows image (required for Agent functionality)
	params := agentbay.NewCreateSessionParams().WithImageId("windows_latest")
	sessionResult, err := client.Create(params)
	if err != nil {
		fmt.Printf("Error creating session: %v\n", err)
		os.Exit(1)
	}

	session := sessionResult.Session

	// Execute a task using the Agent
	taskDescription := "Find the current weather in New York City"
	executionResult := session.Agent.ExecuteTask(taskDescription, 10)

	if executionResult.Success {
		fmt.Printf("Task completed successfully with status: %s\n", executionResult.TaskStatus)
		fmt.Printf("Task ID: %s\n", executionResult.TaskID)
	} else {
		fmt.Printf("Task failed: %s\n", executionResult.ErrorMessage)
	}
}

// Output:
// Task completed successfully with status: finished
// Task ID: task-12345
```

### GetTaskStatus

Gets the status of the task with the given task ID.

```go
GetTaskStatus(taskID string) *QueryResult
```

**Parameters:**
- `taskID` (string): Task ID

**Returns:**
- `*QueryResult`: Result object containing success status, output, and error message if any.

**Example:**
```go
// Get the status of a specific task
taskID := "task-12345"
statusResult := session.Agent.GetTaskStatus(taskID)

if statusResult.Success {
	fmt.Printf("Task output: %s\n", statusResult.Output)
} else {
	fmt.Printf("Failed to get task status: %s\n", statusResult.ErrorMessage)
}

// Output:
// Task output: {"task_id":"task-12345","status":"finished","result":"Today is Thursday, October 3rd, 2025.","product":""}
```

### TerminateTask

Terminates a task with a specified task ID.

```go
TerminateTask(taskID string) *ExecutionResult
```

**Parameters:**
- `taskID` (string): The ID of the running task.

**Returns:**
- `*ExecutionResult`: Result object containing success status, task ID, task status, and error message if any.

**Example:**
```go
// Terminate a running task
taskID := "task-12345"
terminateResult := session.Agent.TerminateTask(taskID)

if terminateResult.Success {
	fmt.Printf("Task terminated successfully with status: %s\n", terminateResult.TaskStatus)
} else {
	fmt.Printf("Failed to terminate task: %s\n", terminateResult.ErrorMessage)
}

// Output:
// Task terminated successfully with status: terminated
```



# OSS API Reference

The OSS (Object Storage Service) module provides functionality for interacting with cloud storage services.

## 📖 Related Tutorial

- [OSS Integration Guide](../../../../../docs/guides/common-features/advanced/oss-integration.md) - Detailed tutorial on integrating with Object Storage Service

## Oss Struct

The `Oss` struct provides methods for OSS operations.

### EnvInit

Creates and initializes OSS environment variables with the specified credentials.

```go
func (o *Oss) EnvInit(accessKeyId, accessKeySecret, securityToken, endpoint, region string) (*EnvInitResult, error)
```

**Parameters:**
- `accessKeyId`: The Access Key ID for OSS authentication.
- `accessKeySecret`: The Access Key Secret for OSS authentication.
- `securityToken`: The security token for OSS authentication.
- `endpoint`: The OSS service endpoint. If not specified, the default is used.
- `region`: The OSS region. If not specified, the default is used.

**Returns:**
- `*EnvInitResult`: A result object containing the initialization result and RequestID.
- `error`: An error if the operation fails.

**EnvInitResult Structure:**
```go
type EnvInitResult struct {
    RequestID string // Unique request identifier for debugging
    Result    string // The result of the environment initialization operation
}
```

**Example:**
```go
package main

import (
	"fmt"
	"os"

	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
)

func main() {
	// Initialize the SDK
	client, err := agentbay.NewAgentBay("your_api_key", nil)
	if err != nil {
		fmt.Printf("Error initializing AgentBay client: %v\n", err)
		os.Exit(1)
	}

	// Create a session first
	sessionResult, err := client.Create(agentbay.NewCreateSessionParams())
	if err != nil {
		fmt.Printf("Error creating session: %v\n", err)
		os.Exit(1)
	}
	session := sessionResult.Session

	// Initialize OSS environment
	result, err := session.Oss.EnvInit(
		"your_access_key_id",
		"your_access_key_secret",
		"your_security_token",
		"oss-cn-hangzhou.aliyuncs.com",
		"cn-hangzhou",
	)
	if err != nil {
		fmt.Printf("Error initializing OSS environment: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("OSS environment initialized successfully, request ID: %s\n", result.RequestID)
}
```

### Upload

**Note:** Before calling this API, you must call `EnvInit` to initialize the OSS environment.

Uploads a local file or directory to OSS.

```go
func (o *Oss) Upload(bucket, object, path string) (*UploadResult, error)
```

**Parameters:**
- `bucket`: OSS bucket name.
- `object`: Object key in OSS.
- `path`: Local file or directory path to upload.

**Returns:**
- `*UploadResult`: A result object containing the upload URL and RequestID.
- `error`: An error if the operation fails.

**UploadResult Structure:**
```go
type UploadResult struct {
    RequestID string // Unique request identifier for debugging
    URL       string // The URL of the uploaded file
}
```

**Example:**
```go
package main

import (
	"fmt"
	"os"

	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
)

func main() {
	// Initialize the SDK
	client, err := agentbay.NewAgentBay("your_api_key", nil)
	if err != nil {
		fmt.Printf("Error initializing AgentBay client: %v\n", err)
		os.Exit(1)
	}

	// Create a session first
	sessionResult, err := client.Create(agentbay.NewCreateSessionParams())
	if err != nil {
		fmt.Printf("Error creating session: %v\n", err)
		os.Exit(1)
	}
	session := sessionResult.Session

	// Step 1: Initialize OSS environment
	_, err = session.Oss.EnvInit(
		"your_access_key_id",
		"your_access_key_secret",
		"your_security_token",
		"oss-cn-hangzhou.aliyuncs.com",
		"cn-hangzhou",
	)
	if err != nil {
		fmt.Printf("Error initializing OSS environment: %v\n", err)
		os.Exit(1)
	}

	// Step 2: Upload file to OSS
	result, err := session.Oss.Upload("my-bucket", "my-object", "/path/to/local/file")
	if err != nil {
		fmt.Printf("Error uploading file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("File uploaded successfully, URL: %s, request ID: %s\n", result.URL, result.RequestID)
}
```

### UploadAnonymous

**Note:** Before calling this API, you must call `EnvInit` to initialize the OSS environment.

Uploads a local file or directory to a URL anonymously.

```go
func (o *Oss) UploadAnonymous(url, path string) (*UploadResult, error)
```

**Parameters:**
- `url`: The HTTP/HTTPS URL to upload the file to.
- `path`: Local file or directory path to upload.

**Returns:**
- `*UploadResult`: A result object containing the upload URL and RequestID.
- `error`: An error if the operation fails.

**Example:**
```go
package main

import (
	"fmt"
	"os"

	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
)

func main() {
	// Initialize the SDK
	client, err := agentbay.NewAgentBay("your_api_key", nil)
	if err != nil {
		fmt.Printf("Error initializing AgentBay client: %v\n", err)
		os.Exit(1)
	}

	// Create a session first
	sessionResult, err := client.Create(agentbay.NewCreateSessionParams())
	if err != nil {
		fmt.Printf("Error creating session: %v\n", err)
		os.Exit(1)
	}
	session := sessionResult.Session

	// Step 1: Initialize OSS environment
	_, err = session.Oss.EnvInit(
		"your_access_key_id",
		"your_access_key_secret",
		"your_security_token",
		"oss-cn-hangzhou.aliyuncs.com",
		"cn-hangzhou",
	)
	if err != nil {
		fmt.Printf("Error initializing OSS environment: %v\n", err)
		os.Exit(1)
	}

	// Step 2: Upload file anonymously
	result, err := session.Oss.UploadAnonymous("https://example.com/upload", "/path/to/local/file")
	if err != nil {
		fmt.Printf("Error uploading file anonymously: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("File uploaded anonymously successfully, URL: %s, request ID: %s\n", result.URL, result.RequestID)
}
```

### Download

**Note:** Before calling this API, you must call `EnvInit` to initialize the OSS environment.

Downloads an object from OSS to a local file.

```go
func (o *Oss) Download(bucket, object, path string) (*DownloadResult, error)
```

**Parameters:**
- `bucket`: OSS bucket name.
- `object`: Object key in OSS.
- `path`: Local path to save the downloaded file.

**Returns:**
- `*DownloadResult`: A result object containing the local file path and RequestID.
- `error`: An error if the operation fails.

**DownloadResult Structure:**
```go
type DownloadResult struct {
    RequestID string // Unique request identifier for debugging
    LocalPath string // The local path where the file was downloaded
}
```

**Example:**
```go
package main

import (
	"fmt"
	"os"

	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
)

func main() {
	// Initialize the SDK
	client, err := agentbay.NewAgentBay("your_api_key", nil)
	if err != nil {
		fmt.Printf("Error initializing AgentBay client: %v\n", err)
		os.Exit(1)
	}

	// Create a session first
	sessionResult, err := client.Create(agentbay.NewCreateSessionParams())
	if err != nil {
		fmt.Printf("Error creating session: %v\n", err)
		os.Exit(1)
	}
	session := sessionResult.Session

	// Step 1: Initialize OSS environment
	_, err = session.Oss.EnvInit(
		"your_access_key_id",
		"your_access_key_secret",
		"your_security_token",
		"oss-cn-hangzhou.aliyuncs.com",
		"cn-hangzhou",
	)
	if err != nil {
		fmt.Printf("Error initializing OSS environment: %v\n", err)
		os.Exit(1)
	}

	// Step 2: Download file from OSS
	result, err := session.Oss.Download("my-bucket", "my-object", "/path/to/local/file")
	if err != nil {
		fmt.Printf("Error downloading file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("File downloaded successfully to: %s, request ID: %s\n", result.LocalPath, result.RequestID)
}
```

### DownloadAnonymous

**Note:** Before calling this API, you must call `EnvInit` to initialize the OSS environment.

Downloads a file from a URL anonymously to a local file.

```go
func (o *Oss) DownloadAnonymous(url, path string) (*DownloadResult, error)
```

**Parameters:**
- `url`: The HTTP/HTTPS URL to download the file from.
- `path`: The full local file path to save the downloaded file.

**Returns:**
- `*DownloadResult`: A result object containing the local file path and RequestID.
- `error`: An error if the operation fails.

**Example:**
```go
package main

import (
	"fmt"
	"os"

	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
)

func main() {
	// Initialize the SDK
	client, err := agentbay.NewAgentBay("your_api_key", nil)
	if err != nil {
		fmt.Printf("Error initializing AgentBay client: %v\n", err)
		os.Exit(1)
	}

	// Create a session first
	sessionResult, err := client.Create(agentbay.NewCreateSessionParams())
	if err != nil {
		fmt.Printf("Error creating session: %v\n", err)
		os.Exit(1)
	}
	session := sessionResult.Session

	// Step 1: Initialize OSS environment
	_, err = session.Oss.EnvInit(
		"your_access_key_id",
		"your_access_key_secret",
		"your_security_token",
		"oss-cn-hangzhou.aliyuncs.com",
		"cn-hangzhou",
	)
	if err != nil {
		fmt.Printf("Error initializing OSS environment: %v\n", err)
		os.Exit(1)
	}

	// Step 2: Download file anonymously
	result, err := session.Oss.DownloadAnonymous("https://example.com/file.txt", "/path/to/local/file.txt")
	if err != nil {
		fmt.Printf("Error downloading file anonymously: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("File downloaded anonymously successfully to: %s, request ID: %s\n", result.LocalPath, result.RequestID)
}
```

## Related Resources

- [Filesystem API Reference](../basics/filesystem.md)
- [Session API Reference](../basics/session.md)



# AgentBay Class API Reference

The `AgentBay` class is the main entry point for interacting with the AgentBay cloud environment. It provides methods for creating, retrieving, listing, and deleting sessions.

## 📖 Related Tutorials

- [SDK Configuration Guide](../../../../../docs/guides/common-features/configuration/sdk-configuration.md) - Detailed tutorial on configuring the SDK
- [VPC Sessions Guide](../../../../../docs/guides/common-features/advanced/vpc-sessions.md) - Tutorial on creating sessions in VPC environments
- [Session Link Access Guide](../../../../../docs/guides/common-features/advanced/session-link-access.md) - Tutorial on accessing sessions via links

## Constructor

### NewAgentBay

```go
func NewAgentBay(apiKey string, opts ...Option) (*AgentBay, error)
```

**Parameters:**
- `apiKey` (string): The API key for authentication. If empty, the SDK will look for the `AGENTBAY_API_KEY` environment variable.
- `opts` (...Option, optional): Optional configuration options. Use `WithConfig(*Config)` to provide custom configuration containing RegionID, Endpoint, and TimeoutMs. If not provided, default configuration is used.

**Returns:**
- `*AgentBay`: A new AgentBay instance.
- `error`: An error if initialization fails.

**Raises:**
- `error`: If no API key is provided and `AGENTBAY_API_KEY` environment variable is not set.

## Properties

### Context

The `Context` field provides access to a `ContextService` instance for managing persistent contexts. See the [Context API Reference](context.md) for more details.

## Methods


Creates a new session in the AgentBay cloud environment.


```go
Create(params *CreateSessionParams) (*SessionResult, error)
```

**Parameters:**
- `params` (*CreateSessionParams, optional): Parameters for session creation. If nil, default parameters will be used.

**Returns:**
- `*SessionResult`: A result object containing the new Session instance and RequestID.
- `error`: An error if the session creation fails.

**Behavior:**
- When `params` includes valid `PersistenceDataList`, after creating the session, the API will check `session.Context.Info()` to retrieve ContextStatusData.
- It will continuously monitor all data items' Status in ContextStatusData until all items show either "Success" or "Failed" status, or until the maximum retry limit (150 times with 2-second intervals) is reached.
- Any "Failed" status items will have their error messages printed.
- The Create operation only returns after context status checking completes.

**Example:**
```go
package main

import (
	"fmt"
	"os"

	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
)

func main() {
	// Initialize the SDK with default configuration
	client, err := agentbay.NewAgentBay("")
	if err != nil {
		fmt.Printf("Error initializing AgentBay client: %v\n", err)
		os.Exit(1)
	}
	// Result: Success: Created client with default config

	// Or initialize with custom configuration
	config := &agentbay.Config{
		RegionID:  "cn-hangzhou",
		Endpoint:  "",
		TimeoutMs: 30000,
	}
	clientWithConfig, err := agentbay.NewAgentBay("", agentbay.WithConfig(config))
	if err != nil {
		fmt.Printf("Error initializing AgentBay client: %v\n", err)
		os.Exit(1)
	}
	// Result: Success: Created client with custom config (RegionID: cn-hangzhou)

	// Create a session with default parameters
	defaultResult, err := client.Create(nil)
	if err != nil {
		fmt.Printf("Error creating session: %v\n", err)
		os.Exit(1)
	}
	fmt.Printf("Created session with ID: %s\n", defaultResult.Session.SessionID)
	// Result: Success: Created session with ID: session-xxxxxxxxxxxxxxx
	// Result: Request ID: XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX

	// Create a session with custom parameters
	labels := map[string]string{
		"project":     "demo",
		"environment": "testing",
	}
	params := &agentbay.CreateSessionParams{
		ImageId: "windows_latest",
		Labels:  labels,
	}
	customResult, err := client.Create(params)
	if err != nil {
		fmt.Printf("Error creating custom session: %v\n", err)
		os.Exit(1)
	}
	fmt.Printf("Created custom session with ID: %s\n", customResult.Session.SessionID)
	// Result: Success: Created custom session with ID: session-xxxxxxxxxxxxxxx
	// Result: Image ID: windows_latest
	// Result: Request ID: XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX

	// RECOMMENDED: Create a session with context synchronization
	// First, create a context
	contextResult, err := client.Context.Create("my-context")
	if err != nil {
		fmt.Printf("Error creating context: %v\n", err)
		os.Exit(1)
	}
	// Result: Success: Created context with ID: SdkCtx-xxxxxxxxxxxxxxx

	contextSync := &agentbay.ContextSync{
		ContextID: contextResult.ContextID,
		Path:      "/home/wuying",
		Policy:    agentbay.NewSyncPolicy(),
	}
	syncParams := &agentbay.CreateSessionParams{
		ImageId:     "windows_latest",
		ContextSync: []*agentbay.ContextSync{contextSync},
	}
	syncResult, err := client.Create(syncParams)
	if err != nil {
		fmt.Printf("Error creating session with context sync: %v\n", err)
		os.Exit(1)
	}
	fmt.Printf("Created session with context sync: %s\n", syncResult.Session.SessionID)
	// Result: Waiting for context synchronization to complete...
	// Result: Context SdkCtx-xxxxxxxxxxxxxxx status: Preparing, path: /home/wuying
	// Result: Context SdkCtx-xxxxxxxxxxxxxxx status: Success, path: /home/wuying
	// Result: Context synchronization completed successfully
	// Result: Success: Created session with context sync: session-xxxxxxxxxxxxxxx

	// Create a mobile session with extra configurations
	appRule := &models.AppManagerRule{
		RuleType: "White",
		AppPackageNameList: []string{
			"com.android.settings",
			"com.example.trusted.app",
			"com.system.essential.service",
		},
	}
	mobileConfig := &models.MobileExtraConfig{
		LockResolution:      true,  // Lock screen resolution for consistent testing
		AppManagerRule:      appRule,
		HideNavigationBar:   true,  // Hide navigation bar for immersive experience
		UninstallBlacklist: []string{  // Protect critical apps from uninstallation
			"com.android.systemui",
			"com.android.settings",
			"com.google.android.gms",
		},
	}
	extraConfigs := &models.ExtraConfigs{Mobile: mobileConfig}
	mobileParams := &agentbay.CreateSessionParams{
		ImageId:      "mobile_latest",
		Labels:       map[string]string{"project": "mobile-testing", "config_type": "whitelist"},
		ExtraConfigs: extraConfigs,
	}
	mobileResult, err := client.Create(mobileParams)
	if err != nil {
		fmt.Printf("Error creating mobile session: %v\n", err)
		os.Exit(1)
	}
	fmt.Printf("Created mobile session with whitelist: %s\n", mobileResult.Session.SessionID)

	// Create a mobile session with blacklist configuration
	appBlacklistRule := &models.AppManagerRule{
		RuleType: "Black",
		AppPackageNameList: []string{
			"com.malware.suspicious",
			"com.unwanted.adware",
			"com.social.distraction",
		},
	}
	mobileSecurityConfig := &models.MobileExtraConfig{
		LockResolution:      false,  // Allow adaptive resolution
		AppManagerRule:      appBlacklistRule,
		HideNavigationBar:   false,  // Show navigation bar (default behavior)
		UninstallBlacklist: []string{"com.android.systemui"},  // Protect system UI from uninstallation
	}
	securityExtraConfigs := &models.ExtraConfigs{Mobile: mobileSecurityConfig}
	mobileSecurityParams := &agentbay.CreateSessionParams{
		ImageId:      "mobile_latest",
		Labels:       map[string]string{"project": "mobile-security", "config_type": "blacklist", "security": "enabled"},
		ExtraConfigs: securityExtraConfigs,
	}
	securityResult, err := client.Create(mobileSecurityParams)
	if err != nil {
		fmt.Printf("Error creating secure mobile session: %v\n", err)
		os.Exit(1)
	}
	fmt.Printf("Created secure mobile session with blacklist: %s\n", securityResult.Session.SessionID)
}
```

### Get

Retrieves a session by its ID.

```go
Get(sessionID string) (*SessionResult, error)
```

**Parameters:**
- `sessionID` (string): The ID of the session to retrieve.

**Returns:**
- `*SessionResult`: A result object containing the Session instance, request ID, success status, and error message if any.
- `error`: Always returns nil. Errors are indicated via SessionResult.Success and SessionResult.ErrorMessage fields.

**Example:**
```go
package main

import (
	"fmt"
	"log"

	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
)

func main() {
	client, err := agentbay.NewAgentBay("")
	if err != nil {
		log.Fatalf("Failed to initialize AgentBay client: %v", err)
	}

	createResult, err := client.Create(nil)
	if err != nil {
		log.Fatalf("Failed to create session: %v", err)
	}
	sessionID := createResult.Session.SessionID
	fmt.Printf("Created session with ID: %s\n", sessionID)
	// Output: Created session with ID: session-xxxxxxxxxxxxxx

	result, err := client.Get(sessionID)
	if err != nil {
		log.Fatalf("Failed to get session: %v", err)
	}
	
	if result.Success {
		fmt.Printf("Successfully retrieved session: %s\n", result.Session.SessionID)
		// Output: Successfully retrieved session: session-xxxxxxxxxxxxxx
		fmt.Printf("Request ID: %s\n", result.RequestID)
		// Output: Request ID: XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
		
		deleteResult, err := result.Session.Delete()
		if err != nil {
			log.Fatalf("Failed to delete session: %v", err)
		}
		if deleteResult.Success {
			fmt.Printf("Session %s deleted successfully\n", sessionID)
			// Output: Session session-xxxxxxxxxxxxxx deleted successfully
		}
	} else {
		fmt.Printf("Failed to get session: %s\n", result.ErrorMessage)
	}
}
```


Lists all available sessions cached in the current client instance.




Lists sessions filtered by the provided labels. It returns sessions that match all the specified labels. This method supports pagination to handle large result sets efficiently.


```go
ListByLabels(params *ListSessionParams) (*SessionListResult, error)
```

**Parameters:**
- `params` (*ListSessionParams, optional): Parameters for filtering sessions by labels. If nil, all sessions will be returned.

**Returns:**
- `*SessionListResult`: A result object containing the filtered sessions, pagination information, and RequestID.
- `error`: An error if the session listing fails.

**Example:**
```go
package main

import (
	"fmt"
	"os"

	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
)

func main() {
	// Initialize the SDK
	client, err := agentbay.NewAgentBay("your_api_key", nil)
	if err != nil {
		fmt.Printf("Error initializing AgentBay client: %v\n", err)
		os.Exit(1)
	}

	// Create pagination parameters
	labels := map[string]string{
		"environment": "production",
		"project":     "demo",
	}
	params := &agentbay.ListSessionParams{
		MaxResults: 10,
		NextToken:  "",
		Labels:     labels,
	}

	// Get the first page of results
	result, err := client.ListByLabels(params)
	if err != nil {
		fmt.Printf("Error listing sessions by labels: %v\n", err)
		os.Exit(1)
	}
	// Result: API Call: ListSession
	// Result: Request: Labels={"environment":"production","project":"demo"}, MaxResults=10

	// Process the results
	fmt.Printf("Found %d sessions:\n", len(result.Sessions))
	for _, session := range result.Sessions {
		fmt.Printf("Session ID: %s\n", session.SessionID)
	}
	// Result: Found N sessions (depends on actual sessions matching the labels)

	// Print pagination information
	fmt.Printf("Total count: %d\n", result.TotalCount)
	fmt.Printf("Max results per page: %d\n", result.MaxResults)
	fmt.Printf("Next token: %s\n", result.NextToken)
	// Result: Request ID: XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX

	// If there is a next page, retrieve it
	if result.NextToken != "" {
		params.NextToken = result.NextToken
		nextPageResult, err := client.ListByLabels(params)
		if err != nil {
			fmt.Printf("Error retrieving next page: %v\n", err)
			os.Exit(1)
		}
		// Process the next page...
	}
}
```

### List

Returns paginated list of Sessions filtered by labels.

```go
List(labels map[string]string, page *int, limit *int32) (*SessionListResult, error)
```

**Parameters:**
- `labels` (map[string]string, optional): Labels to filter Sessions. Can be nil for no filtering (returns all sessions).
- `page` (*int, optional): Page number for pagination (starting from 1). nil or 0 returns the first page.
- `limit` (*int32, optional): Maximum number of items per page. nil or 0 uses default of 10.

**Returns:**
- `*SessionListResult`: Paginated list of session IDs that match the labels, including RequestID and pagination information.
- `error`: An error if the operation fails.

**Key Features:**
- **Simple Interface**: Pass labels directly as a map parameter
- **Pagination Support**: Use `page` and `limit` parameters for easy pagination
- **Request ID**: All responses include a RequestID for tracking and debugging
- **Flexible Filtering**: Filter by any combination of labels or list all sessions

**Example:**
```go
package main

import (
	"fmt"
	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
)

func main() {
	client, _ := agentbay.NewAgentBay("your_api_key", nil)

	// List all sessions
	result, err := client.List(nil, nil, nil)

	// List sessions with specific labels
	result, err = client.List(map[string]string{"project": "demo"}, nil, nil)

	// List sessions with pagination (page 2, 10 items per page)
	page := 2
	limit := int32(10)
	result, err = client.List(map[string]string{"my-label": "my-value"}, &page, &limit)

	if err == nil {
		for _, sessionId := range result.SessionIds {
			fmt.Printf("Session ID: %s\n", sessionId)
		}
		fmt.Printf("Total count: %d\n", result.TotalCount)
		fmt.Printf("Request ID: %s\n", result.RequestID)
	}
}
```

### Delete

Deletes a session from the AgentBay cloud environment.

```go
Delete(session *Session, syncContext ...bool) (*DeleteResult, error)
```

**Parameters:**
- `session` (*Session): The session to delete.
- `syncContext` (bool, optional): If true, the API will trigger a file upload via `session.Context.Sync()` before actually releasing the session. Default is false.

**Returns:**
- `*DeleteResult`: A result object containing success status and RequestID.
- `error`: An error if the session deletion fails.

**Behavior:**
- When `syncContext` is true, the API will first call `session.Context.Sync()` to trigger file upload.
- It will then check `session.Context.Info()` to retrieve ContextStatusData and monitor all data items' Status.
- The API waits until all items show either "Success" or "Failed" status, or until the maximum retry limit (150 times with 2-second intervals) is reached.
- Any "Failed" status items will have their error messages printed.
- The session deletion only proceeds after context sync status checking completes.

**Example:**
```go
package main

import (
	"fmt"
	"os"

	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
)

func main() {
	// Initialize the SDK
	client, err := agentbay.NewAgentBay("your_api_key", nil)
	if err != nil {
		fmt.Printf("Error initializing AgentBay client: %v\n", err)
		os.Exit(1)
	}

	// Create a context first
	contextResult, err := client.Context.Create("test-context")
	if err != nil {
		fmt.Printf("Error creating context: %v\n", err)
		os.Exit(1)
	}
	// Result: Success: Created context with ID: SdkCtx-xxxxxxxxxxxxxxx

	// Create a session with context synchronization
	contextSync := &agentbay.ContextSync{
		ContextID: contextResult.ContextID,
		Path:      "/home/wuying",
		Policy:    agentbay.NewSyncPolicy(),
	}
	params := &agentbay.CreateSessionParams{
		ImageId:     "windows_latest",
		ContextSync: []*agentbay.ContextSync{contextSync},
	}

	createResult, err := client.Create(params)
	if err != nil {
		fmt.Printf("Error creating session: %v\n", err)
		os.Exit(1)
	}

	session := createResult.Session
	fmt.Printf("Created session with ID: %s\n", session.SessionID)
	// Result: Created session with context sync: session-xxxxxxxxxxxxxxx

	// Use the session for operations...

	// Delete the session with context synchronization
	deleteResult, err := client.Delete(session, true)
	if err != nil {
		fmt.Printf("Error deleting session: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("Session deleted successfully with synchronized context")
	fmt.Printf("Request ID: %s\n", deleteResult.RequestID)
	// Result: Triggering context synchronization before session deletion...
	// Result: Context sync completed successfully
	// Result: Success: Session deleted successfully with synchronized context
	// Result: Request ID: XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
}
```



# Command Class API Reference

The `Command` class provides methods for executing commands within a session in the AgentBay cloud environment.

## 📖 Related Tutorial

- [Command Execution Guide](../../../../../docs/guides/common-features/basics/command-execution.md) - Detailed tutorial on executing shell commands

## Methods

### ExecuteCommand

Executes a shell command in the cloud environment.

```go
ExecuteCommand(command string, timeoutMs ...int) (*CommandResult, error)
```

**Parameters:**
- `command` (string): The command to execute.
- `timeoutMs` (int, optional): The timeout for the command execution in milliseconds. Default is 1000ms.

**Returns:**
- `*CommandResult`: A result object containing the command output and RequestID.
- `error`: An error if the command execution fails.

**CommandResult Structure:**
```go
type CommandResult struct {
    // Embedded API response with RequestID and common methods
    models.ApiResponse
    // Output contains the command execution output
    Output    string
}
```

**Note:** `CommandResult` embeds `models.ApiResponse` which provides the `RequestID` field and common API response methods.

**Usage Examples:**

```go
package main

import (
    "fmt"
    agentbay "github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
)

func main() {
    // Initialize AgentBay and create session
    ab, err := agentbay.NewAgentBay("your-api-key", nil)
    if err != nil {
        panic(err)
    }
    // Use code_latest image which supports command execution
    sessionParams := agentbay.NewCreateSessionParams().WithImageId("code_latest")
    sessionResult, err := ab.Create(sessionParams)
    if err != nil {
        panic(err)
    }
    session := sessionResult.Session

    // Execute a command with default timeout (1000ms)
    result, err := session.Command.ExecuteCommand("ls -la")
    if err != nil {
        fmt.Printf("Error executing command: %v\n", err)
        return
    }
    fmt.Printf("Command output:\n%s\n", result.Output)
    // Expected output: Directory listing showing files and folders
    // Sample output: "总计 100\ndrwxr-x--- 16 wuying wuying 4096..."
    fmt.Printf("Request ID: %s\n", result.RequestID)
    // Expected: A valid UUID-format request ID

    // Execute a command with custom timeout (5000ms)
    resultWithTimeout, err := session.Command.ExecuteCommand("sleep 2 && echo 'Done'", 5000)
    if err != nil {
        fmt.Printf("Error executing command: %v\n", err)
        return
    }
    fmt.Printf("Command output: %s\n", resultWithTimeout.Output)
    // Expected output: "Done\n"
    // The command waits 2 seconds then outputs "Done"
    fmt.Printf("Request ID: %s\n", resultWithTimeout.RequestID)
    // Expected: A valid UUID-format request ID
    
    // Note: If a command exceeds its timeout, it will return an error
    // Example: session.Command.ExecuteCommand("sleep 3", 1000)
    // Returns error: "command execution failed: Execution failed. Error code:-1 Error message: [timeout]"
}
```

## Related Resources

- [Session Class](session.md): The session class that provides access to the Command class.
- [Code Class](../../codespace/code.md): For executing Python and JavaScript code.
- [FileSystem Class](filesystem.md): Provides methods for file operations within a session.



# ContextManager API Reference

The `ContextManager` class provides functionality for managing contexts within a session. It enables you to interact with the contexts that are synchronized to the session, including reading and writing data, and managing file operations.

## 📖 Related Tutorial

- [Data Persistence Guide](../../../../../docs/guides/common-features/basics/data-persistence.md) - Detailed tutorial on context management and data persistence

## Overview

The `ContextManager` is accessed through a session instance (`session.Context`) and provides functionality for managing contexts within that session.

## Data Types

```go
type ContextStatusData struct {
	ContextId    string  // The ID of the context
	Path         string  // The path where the context is mounted
	ErrorMessage string  // Error message if the operation failed
	Status       string  // Status of the synchronization task
	StartTime    int64   // Start time of the task (Unix timestamp)
	FinishTime   int64   // Finish time of the task (Unix timestamp)
	TaskType     string  // Type of the task (e.g., "upload", "download")
}
```

## Result Types

```go
type ContextInfoResult struct {
	models.ApiResponse              // Embedded ApiResponse struct
	ContextStatusData []ContextStatusData  // Array of context status data objects
}
```

```go
type ContextSyncResult struct {
	models.ApiResponse  // Embedded ApiResponse struct
	Success bool        // Indicates whether the synchronization was successful
}
```

## Methods

### Info

Gets information about context synchronization status for the current session.

```go
Info() (*ContextInfoResult, error)
```

**Returns:**
- `*ContextInfoResult`: A result object containing the context status data and RequestID.
- `error`: An error if the operation fails.

**Example:**
```go
package main

import (
	"fmt"
	"os"

	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
)

func main() {
	// Initialize the SDK
	client, err := agentbay.NewAgentBay(os.Getenv("AGENTBAY_API_KEY"), nil)
	if err != nil {
		fmt.Printf("Error initializing AgentBay client: %v\n", err)
		os.Exit(1)
	}

	// Create a session
	createResult, err := client.Create(nil)
	if err != nil {
		fmt.Printf("Error creating session: %v\n", err)
		os.Exit(1)
	}
	
	session := createResult.Session
	defer session.Delete()
	
	// Get context synchronization information
	infoResult, err := session.Context.Info()
	if err != nil {
		fmt.Printf("Error getting context info: %v\n", err)
		os.Exit(1)
	}
	
	fmt.Printf("Request ID: %s\n", infoResult.RequestID)
	fmt.Printf("Context status data count: %d\n", len(infoResult.ContextStatusData))
	for _, item := range infoResult.ContextStatusData {
		fmt.Printf("  Context %s: Status=%s, Path=%s, TaskType=%s\n",
			item.ContextId, item.Status, item.Path, item.TaskType)
	}
}

// Expected output:
// Request ID: 41FC3D61-4AFB-1D2E-A08E-5737B2313234
// Context status data count: 0
```

### InfoWithParams

Gets information about context synchronization status with optional filter parameters.

```go
InfoWithParams(contextId, path, taskType string) (*ContextInfoResult, error)
```

**Parameters:**
- `contextId` (string): Optional. The ID of the context to get information for.
- `path` (string): Optional. The path where the context is mounted.
- `taskType` (string): Optional. The type of task to get information for (e.g., "upload", "download").

**Returns:**
- `*ContextInfoResult`: A result object containing the context status data and RequestID.
- `error`: An error if the operation fails.

**Example:**
```go
// Get info for a specific context and path
infoResult, err := session.Context.InfoWithParams(
	"SdkCtx-04bdw8o39bq47rv1t",
	"/mnt/persistent",
	"",
)
if err != nil {
	fmt.Printf("Error getting context info: %v\n", err)
	os.Exit(1)
}

fmt.Printf("Request ID: %s\n", infoResult.RequestID)
for _, item := range infoResult.ContextStatusData {
	fmt.Printf("  Context %s: Status=%s\n", item.ContextId, item.Status)
}

// Expected output when no sync tasks are found:
// Request ID: EB18A2D5-3C51-1F50-9FF1-8543CA328772
// Context status data count: 0
```

### Sync

Synchronizes a context with the session (without waiting for completion).

```go
Sync() (*ContextSyncResult, error)
```

**Returns:**
- `*ContextSyncResult`: A result object containing success status and RequestID.
- `error`: An error if the operation fails.

**Example:**
```go
// Trigger context synchronization
syncResult, err := session.Context.Sync()
if err != nil {
	fmt.Printf("Error synchronizing context: %v\n", err)
	os.Exit(1)
}

fmt.Printf("Sync triggered - Success: %v\n", syncResult.Success)
fmt.Printf("Request ID: %s\n", syncResult.RequestID)

// Expected output:
// Sync triggered - Success: true
// Request ID: 8D845246-2279-13E5-8F15-9DE68CB1B686
```

### SyncWithParams

Synchronizes a context with the session with optional parameters (without waiting for completion).

```go
SyncWithParams(contextId, path, mode string) (*ContextSyncResult, error)
```

**Parameters:**
- `contextId` (string): Optional. The ID of the context to synchronize.
- `path` (string): Optional. The path where the context should be mounted.
- `mode` (string): Optional. The synchronization mode (e.g., "upload", "download"). Defaults to "upload" if empty.

**Returns:**
- `*ContextSyncResult`: A result object containing success status and RequestID.
- `error`: An error if the operation fails.

**Example:**
```go
package main

import (
	"fmt"
	"os"

	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
)

func main() {
	// Initialize the SDK
	client, err := agentbay.NewAgentBay(os.Getenv("AGENTBAY_API_KEY"), nil)
	if err != nil {
		fmt.Printf("Error initializing AgentBay client: %v\n", err)
		os.Exit(1)
	}

	// Create a session
	createResult, err := client.Create(nil)
	if err != nil {
		fmt.Printf("Error creating session: %v\n", err)
		os.Exit(1)
	}
	
	session := createResult.Session
	defer session.Delete()
	
	// Get or create a context
	contextResult, err := client.Context.Get("my-context", true)
	if err != nil {
		fmt.Printf("Error getting context: %v\n", err)
		os.Exit(1)
	}
	
	// Synchronize the context with specific parameters
	syncResult, err := session.Context.SyncWithParams(
		contextResult.ContextID,
		"/mnt/persistent",
		"upload",
	)
	if err != nil {
		fmt.Printf("Error synchronizing context: %v\n", err)
		os.Exit(1)
	}
	
	fmt.Printf("Sync triggered - Success: %v\n", syncResult.Success)
	fmt.Printf("Request ID: %s\n", syncResult.RequestID)
}

// Expected output:
// Sync triggered - Success: true
// Request ID: 8D845246-2279-13E5-8F15-9DE68CB1B686
```

### SyncWithCallback

Synchronizes a context with support for both synchronous (blocking) and asynchronous (callback) modes.

```go
SyncWithCallback(contextId, path, mode string, callback SyncCallback, maxRetries int, retryInterval int) (*ContextSyncResult, error)
```

**Parameters:**
- `contextId` (string): Optional. The ID of the context to synchronize.
- `path` (string): Optional. The path where the context should be mounted.
- `mode` (string): Optional. The synchronization mode (e.g., "upload", "download"). Defaults to "upload" if empty.
- `callback` (SyncCallback): Optional. If provided, the function runs in background and calls callback when complete. If nil, waits for completion before returning.
- `maxRetries` (int): Maximum number of retries for polling completion status.
- `retryInterval` (int): Milliseconds to wait between retries.

**Returns:**
- `*ContextSyncResult`: A result object containing success status and RequestID.
- `error`: An error if the operation fails.

**Example (Synchronous mode - waits for completion):**
```go
// Synchronous mode: callback is nil, so it waits for completion
syncResult, err := session.Context.SyncWithCallback(
	contextResult.ContextID,
	"/mnt/persistent",
	"upload",
	nil,  // No callback - synchronous mode
	10,   // maxRetries
	1000, // retryInterval in milliseconds
)
if err != nil {
	fmt.Printf("Error in SyncWithCallback: %v\n", err)
	os.Exit(1)
}

fmt.Printf("Sync completed - Success: %v\n", syncResult.Success)
fmt.Printf("Request ID: %s\n", syncResult.RequestID)

// Expected output:
// No sync tasks found
// Sync completed - Success: true
// Request ID: 39B00280-B9DA-17D1-BCBB-9C577E057F0A
```

**Example (Asynchronous mode - with callback):**
```go
// Asynchronous mode: with callback, returns immediately
syncResult, err := session.Context.SyncWithCallback(
	contextResult.ContextID,
	"/mnt/persistent",
	"upload",
	func(success bool) {
		if success {
			fmt.Println("Context sync completed successfully")
		} else {
			fmt.Println("Context sync failed or timed out")
		}
	},
	150,  // maxRetries
	1500, // retryInterval in milliseconds
)
if err != nil {
	fmt.Printf("Error in SyncWithCallback: %v\n", err)
	os.Exit(1)
}

fmt.Printf("Sync triggered - Success: %v\n", syncResult.Success)
fmt.Printf("Request ID: %s\n", syncResult.RequestID)
// ... callback will be called asynchronously when sync completes

// Expected output:
// Sync triggered - Success: true
// Request ID: 39B00280-B9DA-17D1-BCBB-9C577E057F0A
// Context sync completed successfully  (printed by callback after completion)
```

## Complete Usage Example

```go
package main

import (
	"fmt"
	"os"
	"time"

	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
)

func main() {
	// Initialize the SDK
	client, err := agentbay.NewAgentBay(os.Getenv("AGENTBAY_API_KEY"), nil)
	if err != nil {
		fmt.Printf("Error initializing AgentBay client: %v\n", err)
		os.Exit(1)
	}

	// Create a session
	createResult, err := client.Create(nil)
	if err != nil {
		fmt.Printf("Error creating session: %v\n", err)
		os.Exit(1)
	}
	
	session := createResult.Session
	defer session.Delete()
	
	fmt.Printf("Session created: %s\n", session.GetSessionId())
	
	// Get or create a context
	contextResult, err := client.Context.Get("my-persistent-context", true)
	if err != nil {
		fmt.Printf("Error getting context: %v\n", err)
		os.Exit(1)
	}
	
	fmt.Printf("Context ID: %s\n", contextResult.ContextID)
	
	// Check initial context status
	infoResult, err := session.Context.Info()
	if err != nil {
		fmt.Printf("Error getting context info: %v\n", err)
		os.Exit(1)
	}
	
	fmt.Printf("Initial context status data count: %d\n", len(infoResult.ContextStatusData))
	
	// Synchronize context and wait for completion
	syncResult, err := session.Context.SyncWithCallback(
		contextResult.ContextID,
		"/mnt/persistent",
		"upload",
		nil,  // nil callback means synchronous mode
		10,   // maxRetries
		1000, // retryInterval in ms
	)
	if err != nil {
		fmt.Printf("Error in sync: %v\n", err)
		os.Exit(1)
	}
	
	fmt.Printf("Sync completed - Success: %v\n", syncResult.Success)
	fmt.Printf("Request ID: %s\n", syncResult.RequestID)
	
	// Check final context status
	finalInfo, err := session.Context.InfoWithParams(
		contextResult.ContextID,
		"/mnt/persistent",
		"",
	)
	if err != nil {
		fmt.Printf("Error getting final context info: %v\n", err)
		os.Exit(1)
	}
	
	fmt.Printf("Final context status data count: %d\n", len(finalInfo.ContextStatusData))
	for _, item := range finalInfo.ContextStatusData {
		fmt.Printf("  Context %s: Status=%s, TaskType=%s\n",
			item.ContextId, item.Status, item.TaskType)
	}
}

// Expected output:
// Session created: session-04bdwfj7u1sew7t4f
// Context ID: SdkCtx-04bdw8o39bq47rv1t
// Initial context status data count: 0
// No sync tasks found
// Sync completed - Success: true
// Request ID: 39B00280-B9DA-17D1-BCBB-9C577E057F0A
// Final context status data count: 0
```

## Notes

- The `ContextManager` is designed to work with contexts synchronized to a session. It is different from the `ContextService` (accessible via `client.Context`) which manages contexts globally.
- `Info()` and `InfoWithParams()` return information about the current synchronization tasks for contexts in the session.
- `Sync()` and `SyncWithParams()` trigger the synchronization but return immediately without waiting for completion.
- `SyncWithCallback()` provides a dual-mode interface: if callback is nil, it waits for completion (synchronous mode); if callback is provided, it returns immediately and calls the callback when complete (asynchronous mode).
- Synchronization polling checks the status every `retryInterval` milliseconds for up to `maxRetries` attempts.
- Empty `ContextStatusData` arrays are normal when there are no active sync tasks.




# Context API Reference

The Context API provides functionality for managing persistent storage contexts in the AgentBay cloud environment. Contexts allow you to persist data across sessions and reuse it in future sessions.

## Context Struct

The `Context` struct represents a persistent storage context in the AgentBay cloud environment.

### Properties

```go
ID  // The unique identifier of the context
Name  // The name of the context
CreatedAt  // Date and time when the Context was created
LastUsedAt  // Date and time when the Context was last used
```

## ContextService Struct

The `ContextService` struct provides methods for managing persistent contexts in the AgentBay cloud environment.

### List

Lists all available contexts with pagination support.

```go
List(params *ContextListParams) (*ContextListResult, error)
```

**Parameters:**
- `params` (*ContextListParams, optional): Pagination parameters. If nil, default values are used (MaxResults=10).

**Returns:**
- `*ContextListResult`: A result object containing the list of Context objects, pagination info, and RequestID.
- `error`: An error if the operation fails.

**Example:**
```go
package main

import (
	"fmt"
	"os"

	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
)

func main() {
	// Initialize the SDK
	client, err := agentbay.NewAgentBay("your_api_key", nil)
	if err != nil {
		fmt.Printf("Error initializing AgentBay client: %v\n", err)
		os.Exit(1)
	}

	// List all contexts (using default pagination)
	result, err := client.Context.List(nil)
	if err != nil {
		fmt.Printf("Error listing contexts: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Found %d contexts:\n", len(result.Contexts))
	// Expected: Found X contexts (where X is the number of contexts, max 10 by default)
	fmt.Printf("Request ID: %s\n", result.RequestID)
	// Expected: A valid UUID-format request ID
	for i, context := range result.Contexts {
		if i < 3 { // Show first 3 contexts
			fmt.Printf("Context ID: %s, Name: %s\n", context.ID, context.Name)
			// Expected output: Context ID: SdkCtx-xxx, Name: xxx
		}
	}
}
```

### Get

Gets a context by name. Optionally creates it if it doesn't exist.

```go
Get(name string, create bool) (*ContextResult, error)
```

**Parameters:**
- `name` (string): The name of the context to get.
- `create` (bool): Whether to create the context if it doesn't exist.

**Returns:**
- `*ContextResult`: A result object containing the Context object and RequestID.
- `error`: An error if the operation fails.

**Example:**
```go
package main

import (
	"fmt"
	"os"

	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
)

func main() {
	// Initialize the SDK
	client, err := agentbay.NewAgentBay("your_api_key", nil)
	if err != nil {
		fmt.Printf("Error initializing AgentBay client: %v\n", err)
		os.Exit(1)
	}

	// Get a context, creating it if it doesn't exist
	result, err := client.Context.Get("my-persistent-context", true)
	if err != nil {
		fmt.Printf("Error getting context: %v\n", err)
		os.Exit(1)
	}

	context := result.Context
	fmt.Printf("Context ID: %s, Name: %s\n", context.ID, context.Name)
	// Expected output: Context ID: SdkCtx-xxx, Name: my-persistent-context
	fmt.Printf("Request ID: %s\n", result.RequestID)
	// Expected: A valid UUID-format request ID
}
```

### Create

Creates a new context.

```go
Create(name string) (*ContextCreateResult, error)
```

**Parameters:**
- `name` (string): The name of the context to create.

**Returns:**
- `*ContextCreateResult`: A result object containing the created Context ID and RequestID.
- `error`: An error if the operation fails.

**Example:**
```go
package main

import (
	"fmt"
	"os"

	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
)

func main() {
	// Initialize the SDK
	client, err := agentbay.NewAgentBay("your_api_key", nil)
	if err != nil {
		fmt.Printf("Error initializing AgentBay client: %v\n", err)
		os.Exit(1)
	}

	// Create a new context
	result, err := client.Context.Create("my-new-context")
	if err != nil {
		fmt.Printf("Error creating context: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Created context with ID: %s\n", result.ContextID)
	// Expected output: Created context with ID: SdkCtx-xxx
	fmt.Printf("Request ID: %s\n", result.RequestID)
	// Expected: A valid UUID-format request ID
}
```

### Update

Updates an existing context.

```go
Update(context *Context) (*ContextModifyResult, error)
```

**Parameters:**
- `context` (*Context): The context object to update.

**Returns:**
- `*ContextModifyResult`: A result object containing success status and RequestID.
- `error`: An error if the operation fails.

**Example:**
```go
package main

import (
	"fmt"
	"os"

	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
)

func main() {
	// Initialize the SDK
	client, err := agentbay.NewAgentBay("your_api_key", nil)
	if err != nil {
		fmt.Printf("Error initializing AgentBay client: %v\n", err)
		os.Exit(1)
	}

	// Get an existing context
	result, err := client.Context.Get("my-context", false)
	if err != nil {
		fmt.Printf("Error getting context: %v\n", err)
		os.Exit(1)
	}

	context := result.Context

	// Update the context name
	context.Name = "my-updated-context"

	// Save the changes
	updateResult, err := client.Context.Update(context)
	if err != nil {
		fmt.Printf("Error updating context: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Context updated successfully, Success: %v\n", updateResult.Success)
	// Expected output: Context updated successfully, Success: true
	fmt.Printf("Request ID: %s\n", updateResult.RequestID)
	// Expected: A valid UUID-format request ID
}
```

### Delete

Deletes a context.

```go
Delete(context *Context) (*ContextDeleteResult, error)
```

**Parameters:**
- `context` (*Context): The context object to delete.

**Returns:**
- `*ContextDeleteResult`: A result object containing success status and RequestID.
- `error`: An error if the operation fails.

**Example:**
```go
package main

import (
	"fmt"
	"os"

	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
)

func main() {
	// Initialize the SDK
	client, err := agentbay.NewAgentBay("your_api_key", nil)
	if err != nil {
		fmt.Printf("Error initializing AgentBay client: %v\n", err)
		os.Exit(1)
	}

	// Get an existing context
	result, err := client.Context.Get("my-context", false)
	if err != nil {
		fmt.Printf("Error getting context: %v\n", err)
		os.Exit(1)
	}

	context := result.Context

	// Delete the context
	deleteResult, err := client.Context.Delete(context)
	if err != nil {
		fmt.Printf("Error deleting context: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Context deleted successfully, Success: %v\n", deleteResult.Success)
	// Expected output: Context deleted successfully, Success: true
	fmt.Printf("Request ID: %s\n", deleteResult.RequestID)
	// Expected: A valid UUID-format request ID
}
```

### GetFileDownloadUrl

Gets a presigned download URL for a file in a context.

```go
GetFileDownloadUrl(contextID string, filePath string) (*ContextFileUrlResult, error)
```

**Parameters:**
- `contextID` (string): The ID of the context.
- `filePath` (string): The path to the file in the context.

**Returns:**
- `*ContextFileUrlResult`: A result object containing the presigned URL, expire time, and RequestID.
- `error`: An error if the operation fails.

### GetFileUploadUrl

Gets a presigned upload URL for a file in a context.

```go
GetFileUploadUrl(contextID string, filePath string) (*ContextFileUrlResult, error)
```

**Parameters:**
- `contextID` (string): The ID of the context.
- `filePath` (string): The path to the file in the context.

**Returns:**
- `*ContextFileUrlResult`: A result object containing the presigned URL, expire time, and RequestID.
- `error`: An error if the operation fails.

### ListFiles

Lists files under a specific folder path in a context.

```go
ListFiles(contextID string, parentFolderPath string, pageNumber int32, pageSize int32) (*ContextFileListResult, error)
```

**Parameters:**
- `contextID` (string): The ID of the context.
- `parentFolderPath` (string): The parent folder path to list files from.
- `pageNumber` (int32): The page number for pagination.
- `pageSize` (int32): The number of items per page.

**Returns:**
- `*ContextFileListResult`: A result object containing the list of files and RequestID.
- `error`: An error if the operation fails.

### ClearAsync

Asynchronously initiates a task to clear the context's persistent data.

```go
ClearAsync(contextID string) (*ContextClearResult, error)
```

**Parameters:**
- `contextID` (string): The unique identifier of the context to clear.

**Returns:**
- `*ContextClearResult`: A result object indicating the task has been successfully started, with status field set to "clearing".
- `error`: An error if the operation fails.

**Example:**
```go
package main

import (
	"fmt"
	"os"

	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
)

func main() {
	// Initialize the SDK
	client, err := agentbay.NewAgentBay("your_api_key", nil)
	if err != nil {
		fmt.Printf("Error initializing AgentBay client: %v\n", err)
		os.Exit(1)
	}

	// Get an existing context
	result, err := client.Context.Get("my-context", false)
	if err != nil {
		fmt.Printf("Error getting context: %v\n", err)
		os.Exit(1)
	}

	context := result.Context

	// Start clearing context data asynchronously
	clearResult, err := client.Context.ClearAsync(context.ID)
	if err != nil {
		fmt.Printf("Error starting context clear: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Clear task started: Success=%t, Status=%s\n",
		clearResult.Success, clearResult.Status)
	// Expected output: Clear task started: Success=true, Status=clearing
	fmt.Printf("Request ID: %s\n", clearResult.RequestID)
	// Expected: A valid UUID-format request ID
}
```

### GetClearStatus

Queries the status of the clearing task.

```go
GetClearStatus(contextID string) (*ContextClearResult, error)
```

**Parameters:**
- `contextID` (string): The unique identifier of the context to check.

**Returns:**
- `*ContextClearResult`: A result object containing the current task status.
- `error`: An error if the operation fails.

**State Transitions:**
- "clearing": Data clearing is in progress
- "available": Clearing completed successfully (final success state)
- "in-use": Context is being used
- "pre-available": Context is being prepared

**Example:**
```go
package main

import (
	"fmt"
	"os"

	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
)

func main() {
	// Initialize the SDK
	client, err := agentbay.NewAgentBay("your_api_key", nil)
	if err != nil {
		fmt.Printf("Error initializing AgentBay client: %v\n", err)
		os.Exit(1)
	}

	// Get an existing context
	result, err := client.Context.Get("my-context", false)
	if err != nil {
		fmt.Printf("Error getting context: %v\n", err)
		os.Exit(1)
	}

	context := result.Context

	// Check clearing status
	statusResult, err := client.Context.GetClearStatus(context.ID)
	if err != nil {
		fmt.Printf("Error getting clear status: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Current status: %s\n", statusResult.Status)
	fmt.Printf("Request ID: %s\n", statusResult.RequestID)
	// Expected: Current status: clearing/available/in-use/pre-available
}
```

### Clear

Synchronously clears the context's persistent data and waits for the final result.

```go
Clear(contextID string, timeoutSeconds int, pollIntervalSeconds float64) (*ContextClearResult, error)
```

**Parameters:**
- `contextID` (string): The unique identifier of the context to clear.
- `timeoutSeconds` (int, optional): Timeout in seconds to wait for task completion, default is 60 seconds.
- `pollIntervalSeconds` (float64, optional): Interval in seconds between status polls, default is 2.0 seconds.

**Returns:**
- `*ContextClearResult`: A result object containing the final task result. The status field will be "available" on success.
- `error`: An error if the task fails to complete within the specified timeout.

**State Transitions:**
- "clearing": Data clearing is in progress
- "available": Clearing completed successfully (final success state)
- "in-use": Context is being used
- "pre-available": Context is being prepared


### DeleteFile

Deletes a file in a context.

```go
DeleteFile(contextID string, filePath string) (*ContextFileDeleteResult, error)
```

**Parameters:**
- `contextID` (string): The ID of the context.
- `filePath` (string): The path to the file to delete.

**Returns:**
- `*ContextFileDeleteResult`: A result object containing success status and RequestID.
- `error`: An error if the operation fails.

## Related Resources

- [Session API Reference](session.md)
- [ContextManager API Reference](context-manager.md)



# FileSystem API Reference (Go)

The FileSystem module provides comprehensive file and directory operations within AgentBay sessions, including real-time directory monitoring capabilities.

## 📖 Related Tutorial

- [Complete Guide to File Operations](../../../../../docs/guides/common-features/basics/file-operations.md) - Detailed tutorial covering all file operation features

## Overview

The FileSystem interface enables you to:
- Perform standard file operations (read, write, create, delete)
- Monitor directories for real-time file changes
- Handle file uploads and downloads
- Manage file permissions and metadata

## Core Types

### FileChangeEvent

Represents a single file change event detected during directory monitoring.

```go
type FileChangeEvent struct {
    EventType string `json:"eventType"` // "create", "modify", "delete"
    Path      string `json:"path"`      // Full path to the changed file/directory
    PathType  string `json:"pathType"`  // "file" or "directory"
}
```

#### Methods

- `String() string` - Returns a string representation of the event
- `ToDict() map[string]string` - Converts the event to a dictionary
- `FileChangeEventFromDict(data map[string]interface{}) *FileChangeEvent` - Creates an event from dictionary data

### FileChangeResult

Contains the result of file change detection operations.

```go
type FileChangeResult struct {
    models.ApiResponse
    Events   []*FileChangeEvent
    RawData  string
}
```

#### Methods

- `HasChanges() bool` - Returns true if any changes were detected
- `GetModifiedFiles() []string` - Returns paths of modified files only
- `GetCreatedFiles() []string` - Returns paths of created files only
- `GetDeletedFiles() []string` - Returns paths of deleted files only

## Directory Monitoring Methods

### GetFileChange

Retrieves file changes that occurred in a directory since the last check.

```go
func (fs *FileSystem) GetFileChange(path string) (*FileChangeResult, error)
```

**Parameters:**
- `path` (string): Directory path to monitor

**Returns:**
- `*FileChangeResult`: Result containing detected file changes
- `error`: Error if the operation failed

**Example:**
```go
package main

import (
    "fmt"
    "log"
    "github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
)

func main() {
    // Initialize AgentBay
    agentBay, err := agentbay.NewAgentBay("your-api-key")
    if err != nil {
        log.Fatal(err)
    }

    // Create session
    sessionParams := &agentbay.CreateSessionParams{
        ImageId: "code_latest",
    }
    sessionResult, err := agentBay.Create(sessionParams)
    if err != nil {
        log.Fatal(err)
    }

    session := sessionResult.Session
    fileSystem := session.FileSystem

    // Check for file changes
    result, err := fileSystem.GetFileChange("/tmp/watch_dir")
    if err != nil {
        log.Fatal(err)
    }

    if result.HasChanges() {
        fmt.Printf("Detected %d changes:\n", len(result.Events))
        for _, event := range result.Events {
            fmt.Printf("- %s\n", event.String())
        }
    } else {
        fmt.Println("No changes detected")
    }
    // Output: No changes detected
    // RequestID: 478639BF-138A-1D9D-9844-146BF08E6DD9
}
```

### WatchDirectory

Continuously monitors a directory for file changes and executes a callback function when changes are detected.

```go
func (fs *FileSystem) WatchDirectory(
    path string,
    callback func([]*FileChangeEvent),
    interval time.Duration,
    stopChan <-chan struct{},
) *sync.WaitGroup
```

**Parameters:**
- `path` (string): Directory path to monitor
- `callback` (func([]*FileChangeEvent)): Function called when changes are detected
- `interval` (time.Duration): Polling interval as a time.Duration (e.g., 1*time.Second)
- `stopChan` (<-chan struct{}): Channel to signal when to stop monitoring

**Returns:**
- `*sync.WaitGroup`: WaitGroup that can be used to wait for monitoring to stop

**Example:**
```go
package main

import (
    "fmt"
    "log"
    "time"
    "github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
    "github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay/filesystem"
)

func main() {
    // Initialize AgentBay
    agentBay, err := agentbay.NewAgentBay("your-api-key")
    if err != nil {
        log.Fatal(err)
    }

    // Create session
    sessionParams := &agentbay.CreateSessionParams{
        ImageId: "code_latest",
    }
    sessionResult, err := agentBay.Create(sessionParams)
    if err != nil {
        log.Fatal(err)
    }

    session := sessionResult.Session
    fileSystem := session.FileSystem

    // Create test directory in cloud environment
    testDir := "/tmp/agentbay_watch_test"
    _, err = fileSystem.CreateDirectory(testDir)
    if err != nil {
        log.Printf("Error creating directory: %v", err)
    }

    // Set up callback function
    callback := func(events []*filesystem.FileChangeEvent) {
        fmt.Printf("Detected %d file changes:\n", len(events))
        for _, event := range events {
            fmt.Printf("- %s\n", event.String())
        }
    }

    // Create stop channel
    stopChan := make(chan struct{})

    // Start monitoring
    wg := fileSystem.WatchDirectory(testDir, callback, 1*time.Second, stopChan)

    // Simulate file operations
    time.Sleep(2 * time.Second)
    
    // Create a file in cloud environment
    testFile := testDir + "/test.txt"
    _, err = fileSystem.WriteFile(testFile, "Hello, AgentBay!", "overwrite")
    if err != nil {
        log.Printf("Error creating file: %v", err)
    }
    // Output: Detected 2 file changes:
    // - FileChangeEvent(eventType='modify', path='/tmp/agentbay_watch_test/test.txt', pathType='file')
    // - FileChangeEvent(eventType='create', path='/tmp/agentbay_watch_test/test.txt', pathType='file')

    // Wait for detection
    time.Sleep(2 * time.Second)

    // Modify the file
    _, err = fileSystem.WriteFile(testFile, "Modified content", "overwrite")
    if err != nil {
        log.Printf("Error modifying file: %v", err)
    }
    // Output: Detected 1 file changes:
    // - FileChangeEvent(eventType='modify', path='/tmp/agentbay_watch_test/test.txt', pathType='file')

    // Wait for detection
    time.Sleep(2 * time.Second)

    // Stop monitoring
    close(stopChan)
    wg.Wait()

    fmt.Println("Monitoring stopped")
}
```

## Helper Functions

### FileChangeEventFromDict

Creates a FileChangeEvent from dictionary data.

```go
func FileChangeEventFromDict(data map[string]interface{}) *FileChangeEvent
```

**Parameters:**
- `data` (map[string]interface{}): Dictionary containing event data

**Returns:**
- `*FileChangeEvent`: New FileChangeEvent instance

## Best Practices

### 1. Polling Interval

Choose an appropriate polling interval based on your needs:
- **High-frequency monitoring**: 100-500ms (higher CPU usage)
- **Normal monitoring**: 1000-2000ms (balanced)
- **Low-frequency monitoring**: 5000ms+ (lower CPU usage)

### 2. Error Handling

Always handle errors and implement proper cleanup:

```go
stopChan := make(chan struct{})
defer close(stopChan)

go func() {
    err := fileSystem.WatchDirectory(path, callback, 1000, stopChan)
    if err != nil {
        log.Printf("Watch error: %v", err)
    }
}()
```

### 3. Callback Function Design

Keep callback functions lightweight and handle errors gracefully:

```go
callback := func(events []*FileChangeEvent) {
    defer func() {
        if r := recover(); r != nil {
            log.Printf("Callback panic recovered: %v", r)
        }
    }()
    
    for _, event := range events {
        // Process event
        processFileChange(event)
    }
}
```

### 4. Resource Management

Always clean up resources and stop monitoring when done:

```go
// Use context for better control
ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
defer cancel()

stopChan := make(chan struct{})
go func() {
    select {
    case <-ctx.Done():
        close(stopChan)
    }
}()
```

## Common Use Cases

### 1. Development File Watcher

Monitor source code changes during development:

```go
callback := func(events []*FileChangeEvent) {
    for _, event := range events {
        if filepath.Ext(event.Path) == ".go" && event.EventType == "modify" {
            fmt.Printf("Go file modified: %s\n", event.Path)
            // Trigger rebuild or test
        }
    }
}
```

### 2. Log File Monitor

Monitor log files for new entries:

```go
callback := func(events []*FileChangeEvent) {
    for _, event := range events {
        if strings.Contains(event.Path, ".log") && event.EventType == "modify" {
            fmt.Printf("Log file updated: %s\n", event.Path)
            // Process new log entries
        }
    }
}
```

### 3. Configuration File Watcher

Monitor configuration files for changes:

```go
callback := func(events []*FileChangeEvent) {
    for _, event := range events {
        if strings.HasSuffix(event.Path, "config.json") {
            fmt.Printf("Configuration changed: %s\n", event.Path)
            // Reload configuration
        }
    }
}
```

## Troubleshooting

### Common Issues

1. **High CPU Usage**: Reduce polling frequency by increasing `intervalMs`
2. **Missing Events**: Ensure the directory exists and is accessible
3. **Callback Errors**: Implement proper error handling in callback functions
4. **Memory Leaks**: Always close stop channels and clean up goroutines

### Performance Considerations

- Use appropriate polling intervals
- Filter events in callback functions to reduce processing overhead
- Consider using multiple watchers for different directories with different intervals
- Monitor memory usage when watching large directories with frequent changes

## Limitations

- Polling-based detection (not real-time filesystem events)
- Performance depends on polling interval and directory size
- May miss very rapid file changes that occur between polls
- Requires active session connection to AgentBay service


```go
CreateDirectory(path string) (*FileDirectoryResult, error)
```

**Parameters:**
- `path` (string): The path of the directory to create.

**Returns:**
- `*FileDirectoryResult`: A result object containing success status and RequestID.
- `error`: An error if the directory creation fails.


```go
EditFile(path string, edits []map[string]string, dryRun bool) (*FileWriteResult, error)
```

**Parameters:**
- `path` (string): The path of the file to edit.
- `edits` ([]map[string]string): Array of edit operations, each containing oldText and newText.
- `dryRun` (bool): If true, preview changes without applying them.

**Returns:**
- `*FileWriteResult`: A result object containing success status and RequestID.
- `error`: An error if the file editing fails.


```go
GetFileInfo(path string) (*FileInfoResult, error)
```

**Parameters:**
- `path` (string): The path of the file or directory to inspect.

**Returns:**
- `*FileInfoResult`: A result object containing file information and RequestID.
- `error`: An error if getting the file information fails.


```go
ListDirectory(path string) (*DirectoryListResult, error)
```

**Parameters:**
- `path` (string): The path of the directory to list.

**Returns:**
- `*DirectoryListResult`: A result object containing directory entries and RequestID.
- `error`: An error if listing the directory fails.

**DirectoryListResult Structure:**
```go
type DirectoryListResult struct {
    RequestID string           // Unique request identifier for debugging
    Entries   []*DirectoryEntry // Array of directory entries
}

type DirectoryEntry struct {
    Name        string // Name of the file or directory
    IsDirectory bool   // Whether this entry is a directory
}
```


```go
MoveFile(source, destination string) (*FileWriteResult, error)
```

**Parameters:**
- `source` (string): The path of the source file or directory.
- `destination` (string): The path of the destination file or directory.

**Returns:**
- `*FileWriteResult`: A result object containing success status and RequestID.
- `error`: An error if moving the file fails.

**FileWriteResult Structure:**
```go
type FileWriteResult struct {
    RequestID string // Unique request identifier for debugging
    Success   bool   // Whether the file was written successfully
}
```


```go
ReadFile(path string) (*FileReadResult, error)
```

**Parameters:**
- `path` (string): The path of the file to read.

**Returns:**
- `*FileReadResult`: A result object containing the file content and RequestID.
- `error`: An error if the file reading fails.

**FileReadResult Structure:**
```go
type FileReadResult struct {
    RequestID string // Unique request identifier for debugging
    Content   string // The contents of the file
}
```

**Note:**
This method automatically handles both small and large files. For large files, it uses internal chunking with a default chunk size of 50KB to overcome API size limitations. No manual chunk size configuration is needed.


Reads the contents of multiple files.


```go
ReadMultipleFiles(paths []string) (map[string]string, error)
```

**Parameters:**
- `paths` ([]string): Array of paths to the files to read.

**Returns:**
- `map[string]string`: A map with file paths as keys and their contents as values.
- `error`: An error if reading the files fails.


```go
SearchFiles(path, pattern string, excludePatterns []string) (*SearchFilesResult, error)
```

**Parameters:**
- `path` (string): The path of the directory to start the search.
- `pattern` (string): Pattern to match.
- `excludePatterns` ([]string): Patterns to exclude.

**Returns:**
- `*SearchFilesResult`: A result object containing search results and RequestID.
- `error`: An error if the search fails.

**SearchFilesResult Structure:**
```go
type SearchFilesResult struct {
    RequestID string   // Unique request identifier for debugging
    Results   []string // Array of search results
}
```


```go
WriteFile(path, content string, mode string) (*FileWriteResult, error)
```

**Parameters:**
- `path` (string): The path of the file to write.
- `content` (string): Content to write to the file.
- `mode` (string): "overwrite" (default), "append", or "create_new".

**Returns:**
- `*FileWriteResult`: A result object containing success status and RequestID.
- `error`: An error if writing the file fails.

**FileWriteResult Structure:**
```go
type FileWriteResult struct {
    RequestID string // Unique request identifier for debugging
    Success   bool   // Whether the file was written successfully
}
```

**Note:**
This method automatically handles both small and large content. For large content, it uses internal chunking with a default chunk size of 50KB to overcome API size limitations. No manual chunk size configuration is needed.


**Deprecated Methods:**

The following methods have been removed in favor of the unified `ReadFile` and `WriteFile` methods:
- `ReadLargeFile` - Use `ReadFile` instead (automatic chunking)
- `WriteLargeFile` - Use `WriteFile` instead (automatic chunking)

## Usage Examples

### Basic File Operations

```go
package main

import (
    "fmt"
    "log"
    "github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
)

func main() {
    // Create a session
    agentBay, err := agentbay.NewAgentBay("your-api-key")
    if err != nil {
        log.Fatal(err)
    }
    sessionResult, err := agentBay.Create(nil)
    if err != nil {
        log.Fatal(err)
    }
    session := sessionResult.Session
    fileSystem := session.FileSystem

    // Create a directory
    createResult, err := fileSystem.CreateDirectory("/tmp/test")
    if err != nil {
        log.Printf("Error creating directory: %v", err)
    } else {
        fmt.Printf("Directory created: %t\n", createResult.Success)
    }
    // Output: Directory created: true
    // RequestID: 27152FAE-4E31-1578-9B50-A367C4848359

    // Write a file
    writeResult, err := fileSystem.WriteFile("/tmp/test/example.txt", "Hello, world!", "overwrite")
    if err != nil {
        log.Printf("Error writing file: %v", err)
    } else {
        fmt.Printf("File written successfully: %t\n", writeResult.Success)
    }
    // Output: File written successfully: true
    // RequestID: F97C3D43-2601-1654-9FF3-B6573B645844

    // Read a file
    readResult, err := fileSystem.ReadFile("/tmp/test/example.txt")
    if err != nil {
        log.Printf("Error reading file: %v", err)
    } else {
        fmt.Printf("File content: %s\n", readResult.Content)
    }
    // Output: File content: Hello, world!
    // RequestID: 6E4FEF65-BCE0-1898-AC2D-2AA1B12CDCCB

    // Edit a file
    edits := []map[string]string{
        {"oldText": "Hello", "newText": "Hi"},
    }
    editResult, err := fileSystem.EditFile("/tmp/test/example.txt", edits, false)
    if err != nil {
        log.Printf("Error editing file: %v", err)
    } else {
        fmt.Printf("File edited successfully: %t\n", editResult.Success)
    }
    // Output: File edited successfully: true
    // Diff output:
    // --- /tmp/test/example.txt
    // +++ /tmp/test/example.txt
    // - Hello, world!
    // + Hi, world!

    // Get file info
    fileInfoResult, err := fileSystem.GetFileInfo("/tmp/test/example.txt")
    if err != nil {
        log.Printf("Error getting file info: %v", err)
    } else {
        fmt.Printf("File size: %d bytes\n", fileInfoResult.FileInfo.Size)
        fmt.Printf("Is directory: %t\n", fileInfoResult.FileInfo.IsDirectory)
    }
    // Output: File size: 11 bytes
    // Output: Is directory: false

    // List directory
    listResult, err := fileSystem.ListDirectory("/tmp/test")
    if err != nil {
        log.Printf("Error listing directory: %v", err)
    } else {
        for _, entry := range listResult.Entries {
            entryType := "Directory"
            if !entry.IsDirectory {
                entryType = "File"
            }
            fmt.Printf("%s: %s\n", entryType, entry.Name)
        }
    }
    // Output: File: example.txt

    // Move a file
    moveResult, err := fileSystem.MoveFile("/tmp/test/example.txt", "/tmp/test/moved.txt")
    if err != nil {
        log.Printf("Error moving file: %v", err)
    } else {
        fmt.Printf("File moved successfully: %t\n", moveResult.Success)
    }
    // Output: File moved successfully: true
    // RequestID: 232965AD-A027-1D50-8A41-B266B0710937
}
```

## Related Resources

- [Session Class](session.md): The session class that provides access to the FileSystem class.
- [Command Class](command.md): Provides methods for executing commands within a session.



# Go Logging Configuration

## Overview

The Go SDK provides simple and efficient logging with support for multiple log levels, automatic sensitive data masking, and color detection for terminal output.

## Setting Log Level

### Priority System (Highest to Lowest)

1. **Code-level setup** - `agentbay.SetLogLevel()` can be called at any time
2. **Environment variables** - `AGENTBAY_LOG_LEVEL`
3. **.env file** - Automatically loaded from current directory or parent directories
4. **Default values** - INFO level

### Method 1: Environment Variable

**Option A: Using .env File (Recommended)**

Create a `.env` file in your project root:

```
# .env file
AGENTBAY_LOG_LEVEL=DEBUG
```

The SDK automatically searches for and loads `.env` files from:
- Current working directory
- Parent directories (recursive search up to root)
- Git repository root (if found)

**Option B: Command Line Environment Variable**

Set before running your program:

```bash
export AGENTBAY_LOG_LEVEL=DEBUG
go run main.go
```

### Method 2: Code-Level Setup (Can be done anytime)

Set in your code - this overrides environment variables:

```go
import "github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"

// Set in your code - has priority over environment variable
agentbay.SetLogLevel(agentbay.LOG_DEBUG)

// Check current level
currentLevel := agentbay.GetLogLevel()
```

**Important**: `SetLogLevel()` can be called at any time and will take priority over environment variables.

## Log Levels

| Constant | Level | Use Case |
|----------|-------|----------|
| **LOG_DEBUG** | 0 | Development - see everything |
| **LOG_INFO** | 1 | Default - important events |
| **LOG_WARN** | 2 | Issues but not failures |
| **LOG_ERROR** | 3 | Only failures |

Filter rule: **Only logs at your level or HIGHER severity are shown**.

## API Reference

### SetLogLevel

```go
agentbay.SetLogLevel(level int)
```

Set the global log level. Valid levels: LOG_DEBUG, LOG_INFO, LOG_WARN, LOG_ERROR.

### GetLogLevel

```go
level := agentbay.GetLogLevel() // Returns int
```

Get the current log level.

## File Logging

The Go SDK supports logging to files with automatic rotation.

### Basic File Logging

```go
import "github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"

// Configure file logging
agentbay.SetupLogger(agentbay.LoggerConfig{
    Level:   "DEBUG",
    LogFile: "/path/to/app.log",
})
```

### File Rotation

Configure automatic log file rotation when the file reaches a certain size:

```go
import "github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"

agentbay.SetupLogger(agentbay.LoggerConfig{
    Level:       "DEBUG",
    LogFile:     "/var/log/myapp.log",
    MaxFileSize: "100 MB",  // Rotate when file reaches 100 MB
})
```

Supported size units:
- `KB` - Kilobytes
- `MB` - Megabytes (default)
- `GB` - Gigabytes

Default max file size is 10 MB if not specified. When rotation occurs, the current log file is renamed to `<filename>.1`.

### Console and File Logging

You can control whether logs are written to console and/or file:

```go
import "github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"

func boolPtr(b bool) *bool {
    return &b
}

// Log to file only (disable console output)
agentbay.SetupLogger(agentbay.LoggerConfig{
    Level:         "DEBUG",
    LogFile:       "/var/log/app.log",
    EnableConsole: boolPtr(false),
})

// Log to both console and file (default)
agentbay.SetupLogger(agentbay.LoggerConfig{
    Level:         "DEBUG",
    LogFile:       "/var/log/app.log",
    EnableConsole: boolPtr(true),
})
```

### LoggerConfig Options

```go
type LoggerConfig struct {
    Level         string  // Log level: "DEBUG", "INFO", "WARN", "ERROR"
    LogFile       string  // Path to log file (empty = no file logging)
    MaxFileSize   string  // Max file size before rotation (e.g., "10 MB", "100 MB", "1 GB")
    EnableConsole *bool   // Enable/disable console output (nil = use default true)
}
```

## Sensitive Data Masking

The SDK automatically masks sensitive information:

```go
data := map[string]interface{}{
    "api_key": "sk_live_1234567890",
    "password": "secret123",
    "auth_token": "Bearer xyz",
}

masked := agentbay.MaskSensitiveData(data)
// Result: api_key masked, password masked, auth_token masked
```

Automatically masked fields:
- api_key, apikey, api-key
- password, passwd, pwd
- token, access_token, auth_token
- secret, private_key
- authorization

## Quick Reference

**Development (see everything)**:
```bash
export AGENTBAY_LOG_LEVEL=DEBUG
go run main.go
```

**Testing (important events only)**:
```bash
go run main.go
# Uses default INFO level
```

**Production (problems only)**:
```bash
export AGENTBAY_LOG_LEVEL=WARN
go run main.go
```

**Runtime control**:
```go
package main

import (
    "github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
)

func main() {
    // Set to DEBUG initially
    agentbay.SetLogLevel(agentbay.LOG_DEBUG)

    // Later in the program
    agentbay.SetLogLevel(agentbay.LOG_WARN)
}
```




# Session Struct

The `Session` struct represents a session in the AgentBay cloud environment. It provides methods for managing file systems, executing commands, and more.

## 📖 Related Tutorial

- [Session Management Guide](../../../../../docs/guides/common-features/basics/session-management.md) - Detailed tutorial on session lifecycle and management

## Properties

```go
AgentBay  // The AgentBay client instance
SessionID  // The ID of this session
ImageId  // The image ID used when creating this session
IsVpcEnabled  // Whether this session uses VPC resources
NetworkInterfaceIP  // Network interface IP for VPC sessions
HttpPortNumber  // HTTP port for VPC sessions
FileSystem  // The FileSystem instance for this session
Command  // The Command instance for this session
Code  // The Code instance for this session
Oss  // The Oss instance for this session
UI  // The UI instance for this session
Application  // The ApplicationManager instance for this session
Window  // The WindowManager instance for this session
Agent  // The Agent instance for this session
Context  // The ContextManager instance for this session
McpTools []McpTool  // MCP tools available for this session
```

**Accessor Methods:**
```go
IsVpc() bool  // Returns whether this session uses VPC resources
NetworkInterfaceIp() string  // Returns the network interface IP for VPC sessions
HttpPort() string  // Returns the HTTP port for VPC sessions
```

## Methods

### Delete

Deletes this session.

```go
Delete(syncContext ...bool) (*DeleteResult, error)
```

**Parameters:**
- `syncContext` (bool, optional): If true, the API will trigger a file upload via `Context.Sync()` before actually releasing the session. Default is false.

**Returns:**
- `*DeleteResult`: A result object containing success status and RequestID.
- `error`: An error if the session deletion fails.

**Behavior:**
- When `syncContext` is true, the API will first call `Context.Sync()` to trigger file upload.
- It will then check `Context.Info()` to retrieve ContextStatusData and monitor only upload task items' Status.
- The API waits until all upload tasks show either "Success" or "Failed" status, or until the maximum retry limit (150 times with 2-second intervals) is reached.
- Any "Failed" status upload tasks will have their error messages printed.
- The session deletion only proceeds after context sync status checking for upload tasks completes.

**Example:**
```go
package main

import (
	"fmt"
	"os"

	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
)

func main() {
	// Initialize the SDK
	client, err := agentbay.NewAgentBay("your_api_key")
	if err != nil {
		fmt.Printf("Error initializing AgentBay client: %v\n", err)
		os.Exit(1)
	}

	// Create a session
	createResult, err := client.Create(nil)
	if err != nil {
		fmt.Printf("Error creating session: %v\n", err)
		os.Exit(1)
	}

	session := createResult.Session
	fmt.Printf("Session created with ID: %s\n", session.SessionID)
	// Output: Session created with ID: session-04bdwfj7u20b0o113

	// Use the session...

	// Delete the session with context synchronization
	deleteResult, err := session.Delete(true)
	if err != nil {
		fmt.Printf("Error deleting session: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("Session deleted successfully with synchronized context")
	// Output: Session deleted successfully with synchronized context
	fmt.Printf("Request ID: %s\n", deleteResult.RequestID)
	// Output: Request ID: 863E5FCC-BBD2-12C2-BE98-8519BB5AF1F7
}
```

### SetLabels

Sets labels for this session.

```go
SetLabels(labels map[string]string) (*models.Response, error)
```

**Parameters:**
- `labels` (map[string]string): Key-value pairs representing the labels to set.

**Returns:**
- `*models.Response`: A response object containing RequestID and status information.
- `error`: An error if setting labels fails.

**Example:**
```go
// Set session labels
labels := map[string]string{
	"project":     "demo",
	"environment": "testing",
	"version":     "1.0.0",
}

response, err := session.SetLabels(labels)
if err != nil {
	fmt.Printf("Error setting labels: %v\n", err)
	os.Exit(1)
}

fmt.Println("Labels set successfully")
// Output: Labels set successfully
fmt.Printf("Request ID: %s\n", response.RequestID)
// Output: Request ID: 010A3CC9-F3FB-1EC3-A540-19E8BBEAEF42
```

### GetLabels

Gets the labels for this session.

```go
GetLabels() (*LabelResult, error)
```

**Returns:**
- `*LabelResult`: A result object containing the labels data, request ID, and success status.
- `error`: An error if getting labels fails.

**Example:**
```go
// Get session labels
result, err := session.GetLabels()
if err != nil {
	fmt.Printf("Error getting labels: %v\n", err)
	os.Exit(1)
}

fmt.Println("Session labels:")
// Parse the labels JSON string
var labels map[string]string
if err := json.Unmarshal([]byte(result.Labels), &labels); err == nil {
	for key, value := range labels {
		fmt.Printf("%s: %s\n", key, value)
	}
}
// Output: Session labels:
// environment: testing
// project: demo
// version: 1.0.0
```

### Info

Gets information about this session.

```go
Info() (*SessionInfo, error)
```

**Returns:**
- `*SessionInfo`: An object containing information about the session.
- `error`: An error if getting session information fails.

**Example:**
```go
// Get session information
infoResult, err := session.Info()
if err != nil {
	fmt.Printf("Error getting session info: %v\n", err)
	os.Exit(1)
}

fmt.Printf("Session ID: %s\n", infoResult.Info.SessionId)
// Output: Session ID: session-04bdwfj7u20b0o115
fmt.Printf("Resource URL: %s\n", infoResult.Info.ResourceUrl)
// Output: Resource URL: https://pre-myspace-wuying.aliyun.com/app/InnoArchClub/mcp_container/mcp.html?authcode=...
fmt.Printf("App ID: %s\n", infoResult.Info.AppId)
// Output: App ID: mcp-server-ubuntu
```

### GetLink

Gets a link for this session.

```go
GetLink(protocolType *string, port *int32) (*LinkResult, error)
```

**Parameters:**
- `protocolType` (*string): The protocol type for the link. If nil, the default protocol will be used.
- `port` (*int32): The port for the link. If nil, the default port will be used. **Port must be an integer in the range [30100, 30199]**.

**Returns:**
- `*LinkResult`: A result object containing the link and request ID.
- `error`: An error if getting the link fails or if the port is outside the valid range.

**Port Range Validation:**
- Valid port range: **[30100, 30199]**
- If a port outside this range is provided, the method will return an error with the message: `"invalid port value: {port}. Port must be an integer in the range [30100, 30199]"`
- Common ports like 80, 443, 8080, etc. are **not allowed** and will result in validation errors

**Example:**
```go
// Get link with specific protocol and valid port
// Note: For ComputerUse images, port must be explicitly specified
protocolType := "https"
var validPort int32 = 30150  // Valid port in range [30100, 30199]
linkResult, err := session.GetLink(&protocolType, &validPort)
if err != nil {
	fmt.Printf("Error getting link: %v\n", err)
	os.Exit(1)
}

fmt.Printf("Session link: %s (RequestID: %s)\n", linkResult.Link, linkResult.RequestID)
// Output: Session link: https://gw-cn-hangzhou-ai-linux.wuyinggw.com:8008/... (RequestID: 57D0226F-EF89-1C95-929F-577EC40A1F20)

// Example of invalid port usage (will fail)
var invalidPort int32 = 8080  // Invalid port - outside [30100, 30199] range
_, err = session.GetLink(nil, &invalidPort)
if err != nil {
	fmt.Printf("Expected error with invalid port: %v\n", err)
	// Output: invalid port value: 8080. Port must be an integer in the range [30100, 30199]
}
```

### ListMcpTools

Lists MCP tools available for this session.

```go
ListMcpTools() (*McpToolsResult, error)
```

**Returns:**
- `*McpToolsResult`: A result object containing the list of MCP tools and request ID.
- `error`: An error if listing MCP tools fails.

**Example:**
```go
// List MCP tools
toolsResult, err := session.ListMcpTools()
if err != nil {
	fmt.Printf("Error listing MCP tools: %v\n", err)
	os.Exit(1)
}

fmt.Printf("Found %d MCP tools\n", len(toolsResult.Tools))
// Output: Found 27 MCP tools
for i, tool := range toolsResult.Tools {
	if i < 3 {
		fmt.Printf("Tool: %s - %s\n", tool.Name, tool.Description)
	}
}
// Output: Tool: execute_command - Execute a command on the system
// Tool: read_file - Read contents of a file
// Tool: write_file - Write content to a file
```

## Session Creation with Extra Configurations

Sessions can be created with additional configurations for specific environments using the `ExtraConfigs` parameter in `CreateSessionParams`. This is particularly useful for mobile sessions that require app management rules and resolution settings.

### Mobile Session Configuration

For mobile sessions, you can configure app management rules and display settings using `MobileExtraConfig`:

```go
package main

import (
	"fmt"
	"os"

	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay/models"
)

func main() {
	// Initialize the SDK
	client, err := agentbay.NewAgentBay("your_api_key", nil)
	if err != nil {
		fmt.Printf("Error initializing AgentBay client: %v\n", err)
		os.Exit(1)
	}

	// Create mobile configuration with whitelist
	appRule := &models.AppManagerRule{
		RuleType: "White",
		AppPackageNameList: []string{
			"com.android.settings",
			"com.example.test.app",
			"com.trusted.service",
		},
	}
	mobileConfig := &models.MobileExtraConfig{
		LockResolution:     true,
		HideNavigationBar:  true,
		UninstallBlacklist: []string{"com.critical.app", "com.system.service"},
		AppManagerRule:     appRule,
	}
	extraConfigs := &models.ExtraConfigs{
		Mobile: mobileConfig,
	}

	// Create session parameters with mobile configuration
	params := agentbay.NewCreateSessionParams().
		WithImageId("mobile_latest").
		WithLabels(map[string]string{
			"project":     "mobile-testing",
			"config_type": "whitelist",
		}).
		WithExtraConfigs(extraConfigs)

	// Create the session
	result, err := client.Create(params)
	if err != nil {
		fmt.Printf("Error creating mobile session: %v\n", err)
		os.Exit(1)
	}

	session := result.Session
	fmt.Printf("Mobile session created with ID: %s\n", session.SessionID)

	// Use the session...

	// Clean up
	deleteResult, err := session.Delete()
	if err != nil {
		fmt.Printf("Error deleting session: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Session deleted (RequestID: %s)\n", deleteResult.RequestID)
}
```

### App Manager Rules

The `AppManagerRule` struct allows you to control which applications are allowed or blocked in mobile sessions:

#### Whitelist Configuration
```go
// Create whitelist rule - only specified apps are allowed
appRule := &models.AppManagerRule{
	RuleType: "White",
	AppPackageNameList: []string{
		"com.android.settings",
		"com.google.android.gms",
		"com.trusted.app",
	},
}
```

#### Blacklist Configuration
```go
// Create blacklist rule - specified apps are blocked
appRule := &models.AppManagerRule{
	RuleType: "Black",
	AppPackageNameList: []string{
		"com.malware.suspicious",
		"com.unwanted.adware",
		"com.blocked.app",
	},
}
```

### Mobile Extra Config Options

The `MobileExtraConfig` struct provides the following options:

- **`LockResolution`** (bool): When set to `true`, locks the display resolution to prevent changes during the session. When `false`, allows flexible resolution adjustments.
- **`HideNavigationBar`** (bool): Controls the visibility of the system navigation bar.
  - `true`: Hides the navigation bar for an immersive full-screen experience
  - `false`: Shows the navigation bar (default system behavior)
- **`UninstallBlacklist`** ([]string): A list of package names that should be protected from uninstallation. These applications will be added to the system's uninstall protection list, preventing accidental or malicious removal of critical apps.
- **`AppManagerRule`** (*AppManagerRule): Defines the application access control rules for the mobile session.

### JSON Serialization

Extra configurations are automatically serialized to JSON when creating sessions. You can also manually serialize them for inspection:

```go
// Serialize extra configs to JSON
jsonStr, err := extraConfigs.ToJSON()
if err != nil {
	fmt.Printf("Error serializing extra configs: %v\n", err)
	return
}
fmt.Printf("Extra configs JSON: %s\n", jsonStr)

// Get JSON from session parameters
params := agentbay.NewCreateSessionParams().WithExtraConfigs(extraConfigs)
paramsJSON, err := params.GetExtraConfigsJSON()
if err != nil {
	fmt.Printf("Error getting extra configs JSON: %v\n", err)
	return
}
fmt.Printf("Session params JSON: %s\n", paramsJSON)
```

### Advanced Mobile Configuration Example

Here's a comprehensive example demonstrating all mobile configuration options:

```go
package main

import (
	"fmt"
	"os"

	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
	"github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay/models"
)

func main() {
	// Initialize the SDK
	client, err := agentbay.NewAgentBay("your_api_key", nil)
	if err != nil {
		fmt.Printf("Error initializing AgentBay client: %v\n", err)
		os.Exit(1)
	}

	// Create comprehensive mobile configuration
	appRule := &models.AppManagerRule{
		RuleType: "White",
		AppPackageNameList: []string{
			"com.android.settings",
			"com.example.test.app",
			"com.trusted.service",
		},
	}

	mobileConfig := &models.MobileExtraConfig{
		LockResolution:     true,  // Lock resolution for consistent testing
		HideNavigationBar:  true,  // Hide navigation bar for immersive UI
		UninstallBlacklist: []string{
			"com.android.systemui",     // Protect system UI
			"com.android.settings",     // Protect settings app
			"com.google.android.gms",   // Protect Google services
			"com.critical.security.app", // Protect security app
		},
		AppManagerRule: appRule,
	}

	extraConfigs := &models.ExtraConfigs{
		Mobile: mobileConfig,
	}

	// Create session with comprehensive configuration
	params := agentbay.NewCreateSessionParams().
		WithImageId("mobile_latest").
		WithLabels(map[string]string{
			"project":     "mobile-automation",
			"config_type": "comprehensive",
			"features":    "navbar_hidden,uninstall_protected,app_whitelist",
		}).
		WithExtraConfigs(extraConfigs)

	result, err := client.Create(params)
	if err != nil {
		fmt.Printf("Error creating mobile session: %v\n", err)
		os.Exit(1)
	}

	session := result.Session
	fmt.Printf("Comprehensive mobile session created with ID: %s\n", session.SessionID)
	fmt.Println("Configuration applied:")
	fmt.Println("- Resolution locked for consistent testing")
	fmt.Println("- Navigation bar hidden for immersive experience")
	fmt.Println("- Critical system apps protected from uninstallation")
	fmt.Println("- App whitelist enabled for security")

	// Use the session for mobile automation...

	// Clean up
	deleteResult, err := session.Delete()
	if err != nil {
		fmt.Printf("Error deleting session: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Session deleted (RequestID: %s)\n", deleteResult.RequestID)
}
```

### Best Practices

1. **Use Appropriate Image IDs**: For mobile sessions with extra configs, use `mobile_latest` or specific mobile image IDs.

2. **Set Descriptive Labels**: Use labels to identify the configuration type and purpose:
   ```go
   WithLabels(map[string]string{
       "config_type": "whitelist",
       "security":    "enabled",
       "project":     "mobile-testing",
       "features":    "navbar_hidden,uninstall_protected",
   })
   ```

3. **Navigation Bar Configuration**: 
   - Use `HideNavigationBar: true` for immersive UI testing or kiosk-mode applications
   - Use `HideNavigationBar: false` for standard mobile app testing where navigation is needed

4. **Uninstall Protection Strategy**:
   - Always protect critical system apps like `com.android.systemui` and `com.android.settings`
   - Include security and management apps in the uninstall blacklist
   - Consider protecting Google Play Services (`com.google.android.gms`) for app compatibility

5. **Test Configurations**: Validate your app package names and configuration settings in a test environment before production use.

6. **Handle Errors Gracefully**: Always check for errors when creating sessions with extra configurations, as invalid configurations may cause session creation to fail.

## Related Resources

- [FileSystem API Reference](filesystem.md)
- [Command API Reference](command.md)
- [UI API Reference](../../computer-use/ui.md)
- [Window API Reference](../../computer-use/window.md)
- [OSS API Reference](../advanced/oss.md)
- [Application API Reference](../../computer-use/application.md)
- [Context API Reference](context-manager.md)




# Application Class

> **⚠️ DEPRECATED**: This API is deprecated. Please use the [Computer API](computer.md) instead for application management functionality.

The Application class provides methods for managing applications in the AgentBay cloud environment, including listing installed applications, starting applications, and stopping running processes.

## Overview

The Application class is accessed through a session instance and provides methods for application management in the cloud environment.

## Data Types


Represents an installed application.


```go
type InstalledApp struct {
    Name          string `json:"name"`
    StartCmd      string `json:"start_cmd"`
    StopCmd       string `json:"stop_cmd,omitempty"`
    WorkDirectory string `json:"work_directory,omitempty"`
}
```


Represents a running process.


```go
type Process struct {
    PName   string `json:"pname"`
    PID     int    `json:"pid"`
    CmdLine string `json:"cmdline,omitempty"`
}
```

## Methods


Retrieves a list of installed applications.


```go
func (am *ApplicationManager) GetInstalledApps(includeSystemApps bool, includeStoreApps bool, includeDesktopApps bool) (*InstalledAppsResult, error)
```

**Parameters:**
- `includeSystemApps` (bool): Whether to include system applications.
- `includeStoreApps` (bool): Whether to include store applications.
- `includeDesktopApps` (bool): Whether to include desktop applications.

**Returns:**
- `*InstalledAppsResult`: A result object containing the list of installed applications and RequestID.
- `error`: An error if the operation fails.

**InstalledAppsResult Structure:**
```go
type InstalledAppsResult struct {
    RequestID string         // Unique request identifier for debugging
    Apps      []*InstalledApp // Array of installed applications
}

type InstalledApp struct {
    Name        string // Application name
    Path        string // Application path
    Version     string // Application version
    Description string // Application description
}
```


Starts an application with the given command and optional working directory.


```go
func (am *ApplicationManager) StartApp(startCmd string, workDirectory string) (string, error)
```

**Parameters:**
- `startCmd` (string): The command used to start the application.
- `workDirectory` (string): The working directory for the application.

**Returns:**
- `string`: A JSON string containing the list of processes started.
- `error`: An error if the operation fails.


Stops an application by process name.


```go
func (am *ApplicationManager) StopAppByPName(pname string) (string, error)
```

**Parameters:**
- `pname` (string): The name of the process to stop.

**Returns:**
- `string`: A success message if the operation was successful.
- `error`: An error if the operation fails.


Stops an application by process ID.


```go
func (am *ApplicationManager) StopAppByPID(pid int) (string, error)
```

**Parameters:**
- `pid` (int): The process ID to stop.

**Returns:**
- `string`: A success message if the operation was successful.
- `error`: An error if the operation fails.


Stops an application by stop command.


```go
func (am *ApplicationManager) StopAppByCmd(stopCmd string) (string, error)
```

**Parameters:**
- `stopCmd` (string): The command used to stop the application.

**Returns:**
- `string`: A success message if the operation was successful.
- `error`: An error if the operation fails.


Lists all currently visible applications.


```go
func (am *ApplicationManager) ListVisibleApps() (*VisibleAppsResult, error)
```

**Returns:**
- `*VisibleAppsResult`: A result object containing the list of visible processes and RequestID.
- `error`: An error if the operation fails.

**VisibleAppsResult Structure:**
```go
type VisibleAppsResult struct {
    RequestID string     // Unique request identifier for debugging
    Processes []*Process // Array of visible processes
}

type Process struct {
    PName string // Process name
    PID   int    // Process ID
}
```

## Usage Examples

### Application Management

```go
package main

import (
    "fmt"
    "log"
)

func main() {
    // Create a session
    agentBay := agentbay.NewAgentBay("your-api-key")
    sessionResult, err := agentBay.Create(nil)
    if err != nil {
        log.Fatal(err)
    }
    session := sessionResult.Session

    // Get installed applications
    appsResult, err := session.Application.GetInstalledApps(true, false, true)
    if err != nil {
        log.Printf("Error getting installed apps: %v", err)
    } else {
        for _, app := range appsResult.Applications {
            fmt.Printf("Application: %s\n", app.Name)
        }
    }

    // Start an application
    processesResult, err := session.Application.StartApp("/usr/bin/google-chrome-stable")
    if err != nil {
        log.Printf("Error starting app: %v", err)
    } else {
        for _, process := range processesResult.Processes {
            fmt.Printf("Started process: %s (PID: %d)\n", process.PName, process.PID)
        }
    }

    // List visible applications
    visibleResult, err := session.Application.ListVisibleApps()
    if err != nil {
        log.Printf("Error listing visible apps: %v", err)
    } else {
        for _, app := range visibleResult.Processes {
            fmt.Printf("Visible application: %s (PID: %d)\n", app.PName, app.PID)
        }
    }

    // Stop an application by PID
    if len(processesResult.Processes) > 0 {
        success, err := session.Application.StopAppByPID(processesResult.Processes[0].PID)
        if err != nil {
            log.Printf("Error stopping app: %v", err)
        } else {
            fmt.Printf("Application stopped: %s\n", success)
        }
    }
}
```

## Related Resources

- [Computer API](computer.md): The recommended API for application management.
- [Window Class](window.md): The window class for managing windows in the cloud environment. 



# Computer Module

The Computer module provides comprehensive desktop UI automation capabilities for Windows environments in the AgentBay cloud platform. It enables mouse operations, keyboard input, screen capture, and window management.

## 📖 Related Tutorials

- [Computer UI Automation Guide](../../../../docs/guides/computer-use/computer-ui-automation.md) - Detailed tutorial on desktop UI automation
- [Window Management Guide](../../../../docs/guides/computer-use/window-management.md) - Tutorial on managing application windows

## Overview

The Computer module is designed for automating Windows desktop applications. It provides low-level input control, screen operations, and window management capabilities that are essential for desktop automation tasks.

**Requirements:**
- Session must be created with `windows_latest` image
- All methods use MCP (Model Context Protocol) tools under the hood

## Data Types

### MouseButton

Represents mouse button types for click operations.

```go
type MouseButton string

const (
    MouseButtonLeft       MouseButton = "left"       // Left mouse button
    MouseButtonRight      MouseButton = "right"      // Right mouse button
    MouseButtonMiddle     MouseButton = "middle"     // Middle mouse button
    MouseButtonDoubleLeft MouseButton = "double_left" // Double click with left button
)
```

### ScrollDirection

Represents scroll directions for mouse wheel operations.

```go
type ScrollDirection string

const (
    ScrollDirectionUp    ScrollDirection = "up"     // Scroll up
    ScrollDirectionDown  ScrollDirection = "down"   // Scroll down
    ScrollDirectionLeft  ScrollDirection = "left"   // Scroll left
    ScrollDirectionRight ScrollDirection = "right"  // Scroll right
)
```

### CursorPosition

Represents the cursor position on screen.

```go
type CursorPosition struct {
    models.ApiResponse
    X            int    // X coordinate
    Y            int    // Y coordinate
    ErrorMessage string // Error message if operation failed
}
```

### ScreenSize

Represents the screen dimensions.

```go
type ScreenSize struct {
    models.ApiResponse
    Width            int     // Screen width in pixels
    Height           int     // Screen height in pixels
    DpiScalingFactor float64 // DPI scaling factor
    ErrorMessage     string  // Error message if operation failed
}
```

### ScreenshotResult

Represents the result of a screenshot operation.

```go
type ScreenshotResult struct {
    models.ApiResponse
    Data         string // Screenshot URL or base64 data
    ErrorMessage string // Error message if operation failed
}
```

### BoolResult

Represents a boolean operation result.

```go
type BoolResult struct {
    models.ApiResponse
    Success      bool   // Whether the operation succeeded
    ErrorMessage string // Error message if operation failed
}
```

## Methods

### Mouse Operations

#### ClickMouse

Clicks the mouse at the specified coordinates with the given button.

```go
func (c *Computer) ClickMouse(x, y int, button MouseButton) *BoolResult
```

**Parameters:**
- `x` (int): X coordinate for the click
- `y` (int): Y coordinate for the click
- `button` (MouseButton): Mouse button to click (left, right, middle, double_left)

**Returns:**
- `*BoolResult`: Result indicating success or failure

**Validation:**
- Valid buttons: `left`, `right`, `middle`, `double_left`
- Invalid button values will return an error result

**Example:**
```go
// Left click at coordinates (100, 100)
// Verified: ✓ API response: "Mouse clicked at (100, 100) with left button successfully"
result := session.Computer.ClickMouse(100, 100, computer.MouseButtonLeft)
if result.Success {
    fmt.Println("Mouse clicked successfully")
}

// Right click at coordinates (200, 200)
// Verified: ✓ API response: "Mouse clicked at (200, 200) with right button successfully"
result = session.Computer.ClickMouse(200, 200, computer.MouseButtonRight)
```

---

#### MoveMouse

Moves the mouse cursor to specific coordinates.

```go
func (c *Computer) MoveMouse(x, y int) *BoolResult
```

**Parameters:**
- `x` (int): Target X coordinate
- `y` (int): Target Y coordinate

**Returns:**
- `*BoolResult`: Result indicating success or failure

**Example:**
```go
// Move mouse to coordinates (100, 100)
// Verified: ✓ API response: "Mouse moved to (100, 100) successfully"
result := session.Computer.MoveMouse(100, 100)
if result.Success {
    fmt.Println("Mouse moved successfully")
}
```

---

#### DragMouse

Drags the mouse from one point to another while holding a mouse button.

```go
func (c *Computer) DragMouse(fromX, fromY, toX, toY int, button MouseButton) *BoolResult
```

**Parameters:**
- `fromX` (int): Starting X coordinate
- `fromY` (int): Starting Y coordinate
- `toX` (int): Ending X coordinate
- `toY` (int): Ending Y coordinate
- `button` (MouseButton): Mouse button to hold during drag (left, right, middle)

**Returns:**
- `*BoolResult`: Result indicating success or failure

**Validation:**
- Valid buttons for drag: `left`, `right`, `middle` (double_left is not valid for drag)
- Invalid button values will return an error result

**Example:**
```go
// Drag from (100, 100) to (200, 200) with left button
// Verified: ✓ API response: "Mouse dragged from (100, 100) to (200, 200) with left button successfully"
result := session.Computer.DragMouse(100, 100, 200, 200, computer.MouseButtonLeft)
if result.Success {
    fmt.Println("Drag operation completed")
}
```

---

#### Scroll

Scrolls the mouse wheel at specific coordinates.

```go
func (c *Computer) Scroll(x, y int, direction ScrollDirection, amount int) *BoolResult
```

**Parameters:**
- `x` (int): X coordinate where to scroll
- `y` (int): Y coordinate where to scroll
- `direction` (ScrollDirection): Scroll direction (up, down, left, right)
- `amount` (int): Amount to scroll

**Returns:**
- `*BoolResult`: Result indicating success or failure

**Validation:**
- Valid directions: `up`, `down`, `left`, `right`
- Invalid direction values will return an error result

**Example:**
```go
// Scroll down 5 units at coordinates (500, 500)
// Verified: ✓ API response: "Mouse scrolled at (500, 500) direction: down amount: 5 successfully"
result := session.Computer.Scroll(500, 500, computer.ScrollDirectionDown, 5)
if result.Success {
    fmt.Println("Scrolled successfully")
}
```

---

#### GetCursorPosition

Gets the current cursor position on the screen.

```go
func (c *Computer) GetCursorPosition() *CursorPosition
```

**Returns:**
- `*CursorPosition`: Current cursor position with X and Y coordinates

**Example:**
```go
// Get current cursor position
// Verified: ✓ Returns actual coordinates {"x":512,"y":384}
position := session.Computer.GetCursorPosition()
if position.ErrorMessage == "" {
    fmt.Printf("Cursor at: (%d, %d)\n", position.X, position.Y)
}
```

---

### Keyboard Operations

#### InputText

Inputs text into the active field.

```go
func (c *Computer) InputText(text string) *BoolResult
```

**Parameters:**
- `text` (string): Text to input

**Returns:**
- `*BoolResult`: Result indicating success or failure

**Example:**
```go
// Type text into the currently focused field
// Verified: ✓ API response: "Text sent successfully. Characters: 14"
result := session.Computer.InputText("Hello AgentBay")
if result.Success {
    fmt.Println("Text input successfully")
}
```

---

#### PressKeys

Presses multiple keyboard keys simultaneously.

```go
func (c *Computer) PressKeys(keys []string, hold bool) *BoolResult
```

**Parameters:**
- `keys` ([]string): Array of key names to press (e.g., ["Ctrl", "C"])
- `hold` (bool): Whether to hold the keys (true) or press and release (false)

**Returns:**
- `*BoolResult`: Result indicating success or failure

**Important Notes:**
- Key names are **case-sensitive** and must use proper capitalization
- Common keys: `Ctrl`, `Alt`, `Shift`, `Enter`, `Escape`, `Tab`, `Backspace`, `Delete`
- Letter keys: use lowercase like `a`, `b`, `c`
- Function keys: `F1`, `F2`, etc.
- **Incorrect**: `ctrl`, `shift`, `alt` (lowercase will fail)
- **Correct**: `Ctrl`, `Shift`, `Alt` (proper capitalization)

**Example:**
```go
// Press Ctrl+C (copy)
// IMPORTANT: Use "Ctrl" not "ctrl"
// Verified: ✓ API response: "Keys pressed and released successfully"
result := session.Computer.PressKeys([]string{"Ctrl", "c"}, false)
if result.Success {
    fmt.Println("Ctrl+C pressed")
}

// Press Alt+F4 (close window)
result = session.Computer.PressKeys([]string{"Alt", "F4"}, false)

// Hold Shift key
result = session.Computer.PressKeys([]string{"Shift"}, true)
```

---

#### ReleaseKeys

Releases multiple keyboard keys that were previously held.

```go
func (c *Computer) ReleaseKeys(keys []string) *BoolResult
```

**Parameters:**
- `keys` ([]string): Array of key names to release

**Returns:**
- `*BoolResult`: Result indicating success or failure

**Example:**
```go
// Release Shift key after holding
// Verified: ✓ API response: "Keys released successfully"
result := session.Computer.ReleaseKeys([]string{"Shift"})
if result.Success {
    fmt.Println("Keys released")
}
```

---

### Screen Operations

#### GetScreenSize

Gets the size of the primary screen.

```go
func (c *Computer) GetScreenSize() *ScreenSize
```

**Returns:**
- `*ScreenSize`: Screen dimensions including width, height, and DPI scaling factor

**Example:**
```go
// Get screen size information
// Verified: ✓ Returns {"dpiScalingFactor":1.0,"height":768,"width":1024}
size := session.Computer.GetScreenSize()
if size.ErrorMessage == "" {
    fmt.Printf("Screen: %dx%d, DPI: %.2f\n",
        size.Width, size.Height, size.DpiScalingFactor)
}
```

---

#### Screenshot

Takes a screenshot of the current screen.

```go
func (c *Computer) Screenshot() *ScreenshotResult
```

**Returns:**
- `*ScreenshotResult`: Screenshot data (typically a URL to the image)

**Example:**
```go
// Capture screenshot
// Verified: ✓ Returns OSS URL to screenshot image (1035 bytes URL)
// Example: https://wuying-intelligence-service-cn-hangzhou.oss-cn-hangzhou.aliyuncs.com/mcp/...
screenshot := session.Computer.Screenshot()
if screenshot.ErrorMessage == "" {
    fmt.Printf("Screenshot URL: %s\n", screenshot.Data)
    // screenshot.Data contains a URL to download the image
}
```

---

### Window Management

The Computer module provides convenient wrapper methods for window operations. These methods internally use the WindowManager.

#### ListRootWindows

Lists all root windows.

```go
func (c *Computer) ListRootWindows(timeoutMs ...int) (*window.WindowListResult, error)
```

**Parameters:**
- `timeoutMs` (int, optional): Timeout in milliseconds

**Returns:**
- `*window.WindowListResult`: List of root windows
- `error`: Error if operation fails

**Example:**
```go
// List all root windows
// Verified: ✓ Returns [{"pid":7488,"pname":"explorer.exe","window_id":65906,"window_title":"Program Manager"}]
result, err := session.Computer.ListRootWindows()
if err == nil {
    for _, win := range result.Windows {
        fmt.Printf("Window: %s (ID: %d, PID: %d)\n",
            win.Title, win.WindowID, win.PID)
    }
}
```

---

#### GetActiveWindow

Gets the currently active window.

```go
func (c *Computer) GetActiveWindow(timeoutMs ...int) (*window.WindowDetailResult, error)
```

**Parameters:**
- `timeoutMs` (int, optional): Timeout in milliseconds

**Returns:**
- `*window.WindowDetailResult`: Details of the active window
- `error`: Error if operation fails

**Example:**
```go
// Get the active window
// Verified: ✓ Returns {"pid":7488,"pname":"explorer.exe","window_id":65906,"window_title":"Program Manager"}
result, err := session.Computer.GetActiveWindow()
if err == nil && result.Window != nil {
    fmt.Printf("Active: %s (ID: %d)\n",
        result.Window.Title, result.Window.WindowID)
}
```

---

#### ActivateWindow

Activates the specified window.

```go
func (c *Computer) ActivateWindow(windowID int) (*window.WindowResult, error)
```

**Parameters:**
- `windowID` (int): ID of the window to activate

**Returns:**
- `*window.WindowResult`: Result of the activation operation
- `error`: Error if operation fails

**Example:**
```go
// Activate window with ID 65906 (from ListRootWindows)
result, err := session.Computer.ActivateWindow(65906)
if err == nil {
    fmt.Println("Window activated")
}
```

---

#### CloseWindow

Closes the specified window.

```go
func (c *Computer) CloseWindow(windowID int) (*window.WindowResult, error)
```

**Parameters:**
- `windowID` (int): ID of the window to close

**Returns:**
- `*window.WindowResult`: Result of the close operation
- `error`: Error if operation fails

**Example:**
```go
// Close window with ID 65906 (from ListRootWindows)
result, err := session.Computer.CloseWindow(65906)
if err == nil {
    fmt.Println("Window closed")
}
```

---

#### MaximizeWindow

Maximizes the specified window.

```go
func (c *Computer) MaximizeWindow(windowID int) (*window.WindowResult, error)
```

**Parameters:**
- `windowID` (int): ID of the window to maximize

**Returns:**
- `*window.WindowResult`: Result of the maximize operation
- `error`: Error if operation fails

---

#### MinimizeWindow

Minimizes the specified window.

```go
func (c *Computer) MinimizeWindow(windowID int) (*window.WindowResult, error)
```

**Parameters:**
- `windowID` (int): ID of the window to minimize

**Returns:**
- `*window.WindowResult`: Result of the minimize operation
- `error`: Error if operation fails

---

#### RestoreWindow

Restores the specified window.

```go
func (c *Computer) RestoreWindow(windowID int) (*window.WindowResult, error)
```

**Parameters:**
- `windowID` (int): ID of the window to restore

**Returns:**
- `*window.WindowResult`: Result of the restore operation
- `error`: Error if operation fails

---

#### ResizeWindow

Resizes the specified window.

```go
func (c *Computer) ResizeWindow(windowID int, width int, height int) (*window.WindowResult, error)
```

**Parameters:**
- `windowID` (int): ID of the window to resize
- `width` (int): New width in pixels
- `height` (int): New height in pixels

**Returns:**
- `*window.WindowResult`: Result of the resize operation
- `error`: Error if operation fails

**Example:**
```go
// Resize window to 800x600 (use window ID from ListRootWindows)
result, err := session.Computer.ResizeWindow(65906, 800, 600)
```

---

#### FullscreenWindow

Makes the specified window fullscreen.

```go
func (c *Computer) FullscreenWindow(windowID int) (*window.WindowResult, error)
```

**Parameters:**
- `windowID` (int): ID of the window to make fullscreen

**Returns:**
- `*window.WindowResult`: Result of the fullscreen operation
- `error`: Error if operation fails

---

#### FocusMode

Toggles focus mode on or off.

```go
func (c *Computer) FocusMode(on bool) (*window.WindowResult, error)
```

**Parameters:**
- `on` (bool): true to enable focus mode, false to disable

**Returns:**
- `*window.WindowResult`: Result of the operation
- `error`: Error if operation fails

---

## Complete Usage Example

This example demonstrates a complete workflow of computer automation:

```go
package main

import (
    "fmt"
    "os"

    "github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
)

func main() {
    // Initialize client
    client, err := agentbay.NewAgentBay("", nil)
    if err != nil {
        fmt.Printf("Error: %v\n", err)
        os.Exit(1)
    }

    // Create Windows session
    // Verified: ✓ Session ID example: session-04bdw8o39qewm36xz
    params := agentbay.NewCreateSessionParams().
        WithImageId("windows_latest")

    result, err := client.Create(params)
    if err != nil {
        fmt.Printf("Error: %v\n", err)
        os.Exit(1)
    }

    session := result.Session
    fmt.Printf("Session created: %s\n", session.SessionID)

    defer client.Delete(session)

    // Get screen information
    // Verified: ✓ Returns {"dpiScalingFactor":1.0,"height":768,"width":1024}
    size := session.Computer.GetScreenSize()
    fmt.Printf("Screen: %dx%d, DPI: %.2f\n",
        size.Width, size.Height, size.DpiScalingFactor)

    // Capture initial screenshot
    // Verified: ✓ Returns OSS URL (1035 bytes)
    screenshot := session.Computer.Screenshot()
    if screenshot.ErrorMessage == "" {
        fmt.Println("Screenshot captured:", screenshot.Data)
    }

    // Get cursor position
    // Verified: ✓ Returns {"x":512,"y":384}
    cursor := session.Computer.GetCursorPosition()
    fmt.Printf("Cursor at: (%d, %d)\n", cursor.X, cursor.Y)

    // Move mouse
    // Verified: ✓ API response: "Mouse moved to (100, 100) successfully"
    session.Computer.MoveMouse(100, 100)

    // Click at position
    // Verified: ✓ API response: "Mouse clicked at (100, 100) with left button successfully"
    session.Computer.ClickMouse(100, 100, "left")

    // Input text
    // Verified: ✓ API response: "Text sent successfully. Characters: 14"
    session.Computer.InputText("Hello AgentBay")

    // Press Ctrl+C
    // Verified: ✓ API response: "Keys pressed and released successfully"
    session.Computer.PressKeys([]string{"Ctrl", "c"}, false)

    // List windows
    // Verified: ✓ Returns [{"pid":7488,"pname":"explorer.exe","window_id":65906,"window_title":"Program Manager"}]
    windows, err := session.Computer.ListRootWindows()
    if err == nil {
        fmt.Printf("Found %d windows\n", len(windows.Windows))
        for _, win := range windows.Windows {
            fmt.Printf("  - %s (ID: %d)\n", win.Title, win.WindowID)
        }
    }

    // Get active window
    // Verified: ✓ Returns {"pid":7488,"pname":"explorer.exe","window_id":65906,"window_title":"Program Manager"}
    activeWin, err := session.Computer.GetActiveWindow()
    if err == nil && activeWin.Window != nil {
        fmt.Printf("Active window: %s\n", activeWin.Window.Title)
    }
}
```

## Best Practices

1. **Session Image**: This module has been verified with the `windows_latest` image
2. **Error Checking**: Check `ErrorMessage` field for operation results
3. **Coordinates**: Ensure coordinates are within screen bounds (use `GetScreenSize()` to check)
4. **Key Names**: Use proper capitalization for key names (`Ctrl` not `ctrl`)
5. **Window IDs**: Use `ListRootWindows()` or `GetActiveWindow()` to get valid window IDs
6. **Screenshot Data**: The screenshot data is typically a URL that can be downloaded

## Related Resources

- [Session API Reference](../common-features/basics/session.md)
- [Window API Reference](window.md)
- [UI API Reference](ui.md)




# UI Class API Reference

> **⚠️ DEPRECATED**: This API is deprecated. Please use the [Computer API](computer.md) or [Mobile API](../mobile-use/mobile.md) instead for UI automation functionality.

The `UI` class provides methods for interacting with UI elements in the AgentBay cloud environment. This includes retrieving UI elements, sending key events, inputting text, performing gestures, and taking screenshots.

## Properties

###

- `KeyCode`: Constants for key codes that can be used with the `send_key` method.
  - `HOME`: Home key (3)
  - `BACK`: Back key (4)
  - `VOLUME_UP`: Volume up key (24)
  - `VOLUME_DOWN`: Volume down key (25)
  - `POWER`: Power key (26)
  - `MENU`: Menu key (82)

## Methods


Retrieves all clickable UI elements within the specified timeout.


```go
GetClickableUIElements(timeoutMs int) (*UIElementsResult, error)
```

**Parameters:**
- `timeoutMs` (int): The timeout in milliseconds. If <= 0, default is 2000ms.

**Returns:**
- `*UIElementsResult`: A result object containing clickable UI elements and RequestID.
- `error`: An error if the operation fails.

**UIElementsResult Structure:**
```go
type UIElementsResult struct {
    RequestID string      // Unique request identifier for debugging
    Elements  []*UIElement // Array of UI elements
}

type UIElement struct {
    Bounds     string       // Bounds of the element
    ClassName  string       // CSS class name
    Text       string       // Text content
    Type       string       // Element type
    ResourceId string       // Resource ID
    Index      int          // Element index
    IsParent   bool         // Whether this element is a parent
    Children   []*UIElement // Child elements
}
```


Retrieves all UI elements within the specified timeout.


```go
GetAllUIElements(timeoutMs int) (*UIElementsResult, error)
```

**Parameters:**
- `timeoutMs` (int): The timeout in milliseconds. If <= 0, default is 2000ms.

**Returns:**
- `*UIElementsResult`: A result object containing all UI elements and RequestID.
- `error`: An error if the operation fails.


Sends a key press event.


```go
SendKey(key int) (*KeyActionResult, error)
```

**Parameters:**
- `key` (int): The key code to send. Use the `KeyCode` constants.

**Returns:**
- `*KeyActionResult`: A result object containing success status and RequestID.
- `error`: An error if the operation fails.

**KeyActionResult Structure:**
```go
type KeyActionResult struct {
    RequestID string // Unique request identifier for debugging
    Success   bool   // Whether the key press was successful
}
```


Inputs text into the active field.


```go
InputText(text string) (*TextInputResult, error)
```

**Parameters:**
- `text` (string): The text to input.

**Returns:**
- `*TextInputResult`: A result object containing the input text and RequestID.
- `error`: An error if the operation fails.

**TextInputResult Structure:**
```go
type TextInputResult struct {
    RequestID string // Unique request identifier for debugging
    Text      string // The text that was input
}
```


Performs a swipe gesture on the screen.


```go
Swipe(startX, startY, endX, endY, durationMs int) (*SwipeResult, error)
```

**Parameters:**
- `startX` (int): The starting X coordinate.
- `startY` (int): The starting Y coordinate.
- `endX` (int): The ending X coordinate.
- `endY` (int): The ending Y coordinate.
- `durationMs` (int): The duration of the swipe in milliseconds.

**Returns:**
- `*SwipeResult`: A result object containing success status and RequestID.
- `error`: An error if the operation fails.

**SwipeResult Structure:**
```go
type SwipeResult struct {
    RequestID string // Unique request identifier for debugging
    Success   bool   // Whether the swipe was successful
}
```


Clicks on the screen at the specified coordinates.


```go
Click(x, y int, button string) (*UIResult, error)
```

**Parameters:**
- `x` (int): The X coordinate.
- `y` (int): The Y coordinate.
- `button` (string): The mouse button to use. If empty, default is 'left'.

**Returns:**
- `*UIResult`: A result object containing success status and RequestID.
- `error`: An error if the operation fails.

**UIResult Structure:**
```go
type UIResult struct {
    RequestID  string // Unique request identifier for debugging
    ComponentID string // Component ID (if applicable)
    Success    bool   // Whether the operation was successful
}
```


Takes a screenshot of the current screen.


```go
Screenshot() (*UIResult, error)
```

**Returns:**
- `*UIResult`: A result object containing success status and RequestID.
- `error`: An error if the operation fails.

## UI Element Structure

UI elements returned by `GetClickableUIElements` and `GetAllUIElements` have the following structure:

```go
type UIElement struct {
    Bounds      string      `json:"bounds"`
    ClassName   string      `json:"className"`
    Text        string      `json:"text"`
    Type        string      `json:"type"`
    ResourceID  string      `json:"resourceId"`
    Index       int         `json:"index"`
    IsParent    bool        `json:"isParent"`
    Children    []UIElement `json:"children"`
}
```

## Usage Examples

### UI Interactions

```go
package main

import (
    "fmt"
    "log"
)

func main() {
    // Create a session
    agentBay := agentbay.NewAgentBay("your-api-key")
    sessionResult, err := agentBay.Create(nil)
    if err != nil {
        log.Fatal(err)
    }
    session := sessionResult.Session

    // Take a screenshot
    screenshotResult, err := session.UI.Screenshot()
    if err != nil {
        log.Printf("Error taking screenshot: %v", err)
    } else {
        fmt.Printf("Screenshot taken successfully: %t\n", screenshotResult.Success)
    }

    // Get all UI elements
    elementsResult, err := session.UI.GetAllUIElements(2000)
    if err != nil {
        log.Printf("Error getting UI elements: %v", err)
    } else {
        fmt.Printf("Retrieved %d UI elements\n", len(elementsResult.Elements))
    }

    // Get clickable UI elements
    clickableResult, err := session.UI.GetClickableUIElements(2000)
    if err != nil {
        log.Printf("Error getting clickable elements: %v", err)
    } else {
        fmt.Printf("Retrieved %d clickable UI elements\n", len(clickableResult.Elements))
    }

    // Send a key press
    keyResult, err := session.UI.SendKey(3) // HOME key
    if err != nil {
        log.Printf("Error sending key: %v", err)
    } else {
        fmt.Printf("Key sent successfully: %t\n", keyResult.Success)
    }

    // Input text
    inputResult, err := session.UI.InputText("Hello, world!")
    if err != nil {
        log.Printf("Error inputting text: %v", err)
    } else {
        fmt.Printf("Text input successfully: %t\n", inputResult.Success)
    }

    // Perform a swipe gesture
    swipeResult, err := session.UI.Swipe(100, 500, 100, 100, 500)
    if err != nil {
        log.Printf("Error performing swipe: %v", err)
    } else {
        fmt.Printf("Swipe performed successfully: %t\n", swipeResult.Success)
    }

    // Click on the screen
    clickResult, err := session.UI.Click(200, 300, "left")
    if err != nil {
        log.Printf("Error clicking: %v", err)
    } else {
        fmt.Printf("Click performed successfully: %t\n", clickResult.Success)
    }
}
```

## Related Resources

- [Session Class](../common-features/basics/session.md): The Session class that provides access to the UI class.



# Window Class

> **⚠️ DEPRECATED**: This API is deprecated. Please use the [Computer API](computer.md) instead for window management functionality.

The Window class provides methods for managing windows in the AgentBay cloud environment, including listing windows, getting the active window, and manipulating window states.

## Overview

The Window class is accessed through a session instance and provides methods for window management in the cloud environment.

## Data Types


Represents a window in the system.


```go
type Window struct {
    WindowID           int      `json:"window_id"`
    Title              string   `json:"title"`
    AbsoluteUpperLeftX int      `json:"absolute_upper_left_x,omitempty"`
    AbsoluteUpperLeftY int      `json:"absolute_upper_left_y,omitempty"`
    Width              int      `json:"width,omitempty"`
    Height             int      `json:"height,omitempty"`
    PID                int      `json:"pid,omitempty"`
    PName              string   `json:"pname,omitempty"`
    ChildWindows       []Window `json:"child_windows,omitempty"`
}
```

## Methods


Lists all root windows in the system.


```go
func (wm *WindowManager) ListRootWindows() (*WindowListResult, error)
```

**Returns:**
- `*WindowListResult`: A result object containing the list of root windows and request ID.
- `error`: An error if the operation fails.


Gets the currently active window.


```go
func (wm *WindowManager) GetActiveWindow() (*WindowDetailResult, error)
```

**Returns:**
- `*WindowDetailResult`: A result object containing the active window and request ID.
- `error`: An error if the operation fails.


Activates (brings to front) a window by ID.


```go
func (wm *WindowManager) ActivateWindow(windowID int) (*WindowResult, error)
```

**Parameters:**
- `windowID` (int): The ID of the window to activate.

**Returns:**
- `*WindowResult`: A result object containing the success status and request ID.
- `error`: An error if the operation fails.


Minimizes a window by ID.


```go
func (wm *WindowManager) MinimizeWindow(windowID int) (*WindowResult, error)
```

**Parameters:**
- `windowID` (int): The ID of the window to minimize.

**Returns:**
- `*WindowResult`: A result object containing the success status and request ID.
- `error`: An error if the operation fails.


Maximizes a window by ID.


```go
func (wm *WindowManager) MaximizeWindow(windowID int) (*WindowResult, error)
```

**Parameters:**
- `windowID` (int): The ID of the window to maximize.

**Returns:**
- `*WindowResult`: A result object containing the success status and request ID.
- `error`: An error if the operation fails.


Restores a window by ID (from minimized or maximized state).


```go
func (wm *WindowManager) RestoreWindow(windowID int) (*WindowResult, error)
```

**Parameters:**
- `windowID` (int): The ID of the window to restore.

**Returns:**
- `*WindowResult`: A result object containing the success status and request ID.
- `error`: An error if the operation fails.


Makes a window fullscreen by ID.


```go
func (wm *WindowManager) FullscreenWindow(windowID int) (*WindowResult, error)
```

**Parameters:**
- `windowID` (int): The ID of the window to make fullscreen.

**Returns:**
- `*WindowResult`: A result object containing the success status and request ID.
- `error`: An error if the operation fails.


Resizes a window by ID to the specified width and height.


```go
func (wm *WindowManager) ResizeWindow(windowID, width, height int) (*WindowResult, error)
```

**Parameters:**
- `windowID` (int): The ID of the window to resize.
- `width` (int): The new width of the window.
- `height` (int): The new height of the window.

**Returns:**
- `*WindowResult`: A result object containing the success status and request ID.
- `error`: An error if the operation fails.


Closes a window by ID.


```go
func (wm *WindowManager) CloseWindow(windowID int) (*WindowResult, error)
```

**Parameters:**
- `windowID` (int): The ID of the window to close.

**Returns:**
- `*WindowResult`: A result object containing the success status and request ID.
- `error`: An error if the operation fails.


Enables or disables focus mode, which prevents window switching.


```go
func (wm *WindowManager) FocusMode(on bool) (*WindowResult, error)
```

**Parameters:**
- `on` (bool): True to enable focus mode, False to disable it.

**Returns:**
- `*WindowResult`: A result object containing the success status and request ID.
- `error`: An error if the operation fails.

## Usage Examples

### Window Management

```go
package main

import (
    "fmt"
    "log"
)

func main() {
    // Create a session
    agentBay := agentbay.NewAgentBay("your-api-key")
    sessionResult, err := agentBay.Create(nil)
    if err != nil {
        log.Fatal(err)
    }
    session := sessionResult.Session

    // List root windows
    windowsResult, err := session.Window.ListRootWindows(3000)
    if err != nil {
        log.Printf("Error listing windows: %v", err)
    } else {
        for _, window := range windowsResult.Windows {
            fmt.Printf("Window: %s (ID: %d, Process: %s, PID: %d)\n", 
                window.Title, window.WindowID, window.PName, window.PID)
        }
    }

    // Get active window
    activeResult, err := session.Window.GetActiveWindow(3000)
    if err != nil {
        log.Printf("Error getting active window: %v", err)
    } else {
        fmt.Printf("Active window: %s (ID: %d)\n", 
            activeResult.Window.Title, activeResult.Window.WindowID)
    }

    // Manipulate windows
    if len(windowsResult.Windows) > 0 {
        windowID := windowsResult.Windows[0].WindowID
        
        // Maximize window
        err = session.Window.MaximizeWindow(windowID)
        if err != nil {
            log.Printf("Error maximizing window: %v", err)
        } else {
            fmt.Println("Window maximized")
        }
        
        // Restore window
        err = session.Window.RestoreWindow(windowID)
        if err != nil {
            log.Printf("Error restoring window: %v", err)
        } else {
            fmt.Println("Window restored")
        }
        
        // Resize window
        err = session.Window.ResizeWindow(windowID, 800, 600)
        if err != nil {
            log.Printf("Error resizing window: %v", err)
        } else {
            fmt.Println("Window resized")
        }
        
        // Activate window
        err = session.Window.ActivateWindow(windowID)
        if err != nil {
            log.Printf("Error activating window: %v", err)
        } else {
            fmt.Println("Window activated")
        }
    }
}
```

## Related Resources

- [Computer API](computer.md): The recommended API for window management.
- [Application Class](application.md): The application class for managing applications in the cloud environment. 



# Mobile Module

The Mobile module provides comprehensive mobile UI automation capabilities for Android environments in the AgentBay cloud platform. It enables touch operations, UI element interactions, text input, application management, and screenshot capture.

## 📖 Related Tutorials

- [Mobile UI Automation Guide](../../../../docs/guides/mobile-use/mobile-ui-automation.md) - Detailed tutorial on mobile UI automation
- [Mobile Application Management Guide](../../../../docs/guides/mobile-use/mobile-application-management.md) - Tutorial on managing mobile applications

## Overview

The Mobile module is designed for automating Android mobile applications. It provides touch gestures, UI element discovery, application lifecycle management, and input control capabilities that are essential for mobile automation tasks.

**Requirements:**
- Session must be created with a mobile environment image (e.g., `mobile_latest`)
- All methods use MCP (Model Context Protocol) tools under the hood

## Data Types

### UIElement

Represents a UI element in the mobile interface.

```go
type UIElement struct {
    Bounds      *UIBounds // Element bounds (position and size)
    ClassName   string    // Element class name
    ContentDesc string    // Content description (accessibility)
    ElementID   string    // Element identifier
    Package     string    // Package name
    ResourceID  string    // Resource identifier
    Text        string    // Element text content
    Type        string    // Element type
}
```

### UIBounds

Represents the bounds (position and size) of a UI element.

```go
type UIBounds struct {
    Bottom int // Bottom coordinate
    Left   int // Left coordinate
    Right  int // Right coordinate
    Top    int // Top coordinate
}
```

### UIElementsResult

Represents the result containing UI elements.

```go
type UIElementsResult struct {
    models.ApiResponse
    Elements     []*UIElement // List of UI elements
    ErrorMessage string       // Error message if operation failed
}
```

### InstalledApp

Represents an installed application.

```go
type InstalledApp struct {
    Name          string // Application name
    StartCmd      string // Command to start the application
    StopCmd       string // Command to stop the application (optional)
    WorkDirectory string // Working directory (optional)
}
```

### Process

Represents a running process.

```go
type Process struct {
    PName   string // Process name
    PID     int    // Process ID
    CmdLine string // Command line (optional)
}
```

### InstalledAppListResult

Wraps installed app list and RequestID.

```go
type InstalledAppListResult struct {
    models.ApiResponse
    Apps         []InstalledApp // List of installed applications
    ErrorMessage string         // Error message if operation failed
}
```

### ProcessListResult

Wraps process list and RequestID.

```go
type ProcessListResult struct {
    models.ApiResponse
    Processes    []Process // List of running processes
    ErrorMessage string    // Error message if operation failed
}
```

### BoolResult

Represents a boolean operation result.

```go
type BoolResult struct {
    models.ApiResponse
    Success      bool   // Whether the operation succeeded
    ErrorMessage string // Error message if operation failed
}
```

### AdbUrlResult

Represents the result of ADB URL retrieval operation.

```go
type AdbUrlResult struct {
    models.ApiResponse
    URL          string // ADB connection URL (e.g., "adb connect xx.xx.xx.xx:xxxxx")
    Success      bool   // Whether the operation succeeded
    ErrorMessage string // Error message if operation failed
}
```

### ScreenshotResult

Represents the result of a screenshot operation.

```go
type ScreenshotResult struct {
    models.ApiResponse
    Data         string // Screenshot URL or base64 data
    ErrorMessage string // Error message if operation failed
}
```

## Methods

### Touch Operations

#### Tap

Taps on the screen at specific coordinates.

```go
func (m *Mobile) Tap(x, y int) *BoolResult
```

**Parameters:**
- `x` (int): X coordinate for the tap
- `y` (int): Y coordinate for the tap

**Returns:**
- `*BoolResult`: Result indicating success or failure

**Example:**
```go
// Tap at coordinates (500, 500)
// Verified: ✓ Successfully taps at specified coordinates
result := session.Mobile.Tap(500, 500)
if result.Success {
    fmt.Println("Tap successful")
}
```

---

#### Swipe

Performs a swipe gesture on the screen.

```go
func (m *Mobile) Swipe(startX, startY, endX, endY, durationMs int) *BoolResult
```

**Parameters:**
- `startX` (int): Starting X coordinate
- `startY` (int): Starting Y coordinate
- `endX` (int): Ending X coordinate
- `endY` (int): Ending Y coordinate
- `durationMs` (int): Duration of the swipe in milliseconds

**Returns:**
- `*BoolResult`: Result indicating success or failure

**Example:**
```go
// Swipe from left to right
// Verified: ✓ Successfully performs swipe gesture
result := session.Mobile.Swipe(100, 500, 900, 500, 300)
if result.Success {
    fmt.Println("Swipe successful")
}

// Swipe up (scroll down)
result = session.Mobile.Swipe(500, 1000, 500, 200, 500)

// Swipe down (scroll up)
result = session.Mobile.Swipe(500, 200, 500, 1000, 500)
```

---

### Input Operations

#### InputText

Inputs text into the currently active field.

```go
func (m *Mobile) InputText(text string) *BoolResult
```

**Parameters:**
- `text` (string): Text to input

**Returns:**
- `*BoolResult`: Result indicating success or failure

**Example:**
```go
// Input text into focused field
// Verified: ✓ Successfully inputs text
result := session.Mobile.InputText("Hello Mobile")
if result.Success {
    fmt.Println("Text input successful")
}
```

---

#### SendKey

Sends a key press event using Android key codes.

```go
func (m *Mobile) SendKey(key int) *BoolResult
```

**Parameters:**
- `key` (int): Android key code (e.g., 4 for BACK, 3 for HOME, 82 for MENU)

**Returns:**
- `*BoolResult`: Result indicating success or failure

**Common Android Key Codes:**
- `3` - HOME
- `4` - BACK
- `24` - VOLUME_UP
- `25` - VOLUME_DOWN
- `26` - POWER
- `82` - MENU
- `84` - SEARCH
- `85` - PLAY_PAUSE

**Example:**
```go
// Press BACK button (key code 4)
result := session.Mobile.SendKey(4)
if result.Success {
    fmt.Println("BACK key sent")
}

// Press HOME button (key code 3)
result = session.Mobile.SendKey(3)
```

---

### UI Element Discovery

#### GetClickableUIElements

Retrieves all clickable UI elements within the specified timeout.

```go
func (m *Mobile) GetClickableUIElements(timeoutMs int) *UIElementsResult
```

**Parameters:**
- `timeoutMs` (int): Timeout in milliseconds to wait for UI elements

**Returns:**
- `*UIElementsResult`: Result containing list of clickable UI elements

**Example:**
```go
// Get all clickable elements with 5 second timeout
// Verified: ✓ Returns list of clickable UI elements (may be empty if no elements)
result := session.Mobile.GetClickableUIElements(5000)
if result.ErrorMessage == "" {
    fmt.Printf("Found %d clickable elements\n", len(result.Elements))
    for _, elem := range result.Elements {
        fmt.Printf("  - Text: %s, ResourceID: %s\n",
            elem.Text, elem.ResourceID)
    }
}
```

---

#### GetAllUIElements

Retrieves all UI elements within the specified timeout.

```go
func (m *Mobile) GetAllUIElements(timeoutMs int) *UIElementsResult
```

**Parameters:**
- `timeoutMs` (int): Timeout in milliseconds to wait for UI elements

**Returns:**
- `*UIElementsResult`: Result containing list of all UI elements

**Example:**
```go
// Get all UI elements with 5 second timeout
// Verified: ✓ Returns list of all UI elements
result := session.Mobile.GetAllUIElements(5000)
if result.ErrorMessage == "" {
    fmt.Printf("Found %d total elements\n", len(result.Elements))
    for _, elem := range result.Elements {
        if elem.Bounds != nil {
            fmt.Printf("  - Element: %s at (%d, %d, %d, %d)\n",
                elem.ClassName,
                elem.Bounds.Left, elem.Bounds.Top,
                elem.Bounds.Right, elem.Bounds.Bottom)
        }
    }
}
```

---

### Application Management

#### GetInstalledApps

Retrieves a list of installed applications.

```go
func (m *Mobile) GetInstalledApps(startMenu, desktop, ignoreSystemApps bool) *InstalledAppListResult
```

**Parameters:**
- `startMenu` (bool): Include apps from start menu
- `desktop` (bool): Include apps from desktop
- `ignoreSystemApps` (bool): Whether to exclude system applications

**Returns:**
- `*InstalledAppListResult`: Result containing list of installed applications

**Example:**
```go
// Get all user-installed apps (excluding system apps)
// Verified: ✓ Returns list of installed applications
result := session.Mobile.GetInstalledApps(true, true, true)
if result.ErrorMessage == "" {
    fmt.Printf("Found %d installed apps\n", len(result.Apps))
    for _, app := range result.Apps {
        fmt.Printf("  - %s: %s\n", app.Name, app.StartCmd)
    }
}

// Get all apps including system apps
result = session.Mobile.GetInstalledApps(true, true, false)
```

---

#### StartApp

Starts a specified application.

```go
func (m *Mobile) StartApp(startCmd, workDirectory, activity string) *ProcessListResult
```

**Parameters:**
- `startCmd` (string): Command to start the application
- `workDirectory` (string): Working directory for the application
- `activity` (string): Android activity to launch (for Android apps)

**Returns:**
- `*ProcessListResult`: Result containing list of processes for the started app

**Example:**
```go
// Start an Android app by package and activity
result := session.Mobile.StartApp(
    "com.example.app",           // Package name
    "",                          // Work directory (empty for default)
    "com.example.app.MainActivity" // Activity name
)
if result.ErrorMessage == "" {
    fmt.Printf("App started with %d processes\n", len(result.Processes))
    for _, proc := range result.Processes {
        fmt.Printf("  - Process: %s (PID: %d)\n", proc.PName, proc.PID)
    }
}
```

---

#### StopAppByPName

Stops an application by its process name.

```go
func (m *Mobile) StopAppByPName(pname string) *BoolResult
```

**Parameters:**
- `pname` (string): Process name of the application to stop

**Returns:**
- `*BoolResult`: Result indicating success or failure

**Example:**
```go
// Stop an app by process name
result := session.Mobile.StopAppByPName("com.example.app")
if result.Success {
    fmt.Println("App stopped successfully")
}
```

---

### Screen Operations

#### Screenshot

Takes a screenshot of the current mobile screen.

```go
func (m *Mobile) Screenshot() *ScreenshotResult
```

**Returns:**
- `*ScreenshotResult`: Screenshot data (typically a URL to the image)

**Example:**
```go
// Capture mobile screenshot
// Verified: ✓ Returns OSS URL to screenshot image (1035 bytes URL)
screenshot := session.Mobile.Screenshot()
if screenshot.ErrorMessage == "" {
    fmt.Printf("Screenshot URL: %s\n", screenshot.Data)
    // screenshot.Data contains a URL to download the image
}
```

---

### ADB Connection

#### GetAdbUrl

Retrieves the ADB (Android Debug Bridge) connection URL for the mobile environment.

**Important:** This method is only supported in mobile environments. Using other environment types will result in an error.

```go
func (m *Mobile) GetAdbUrl(adbkeyPub string) *AdbUrlResult
```

**Parameters:**
- `adbkeyPub` (string): ADB public key for authentication

**Returns:**
- `*AdbUrlResult`: Result containing the ADB connection URL

**Example:**
```go
// Get ADB URL with public key
// Verified: ✓ Returns valid ADB connection URL
adbkeyPub := "QAAAAM0muSn7yQCY...your_adb_public_key...EAAQAA="

result := session.Mobile.GetAdbUrl(adbkeyPub)
if result.Success {
    fmt.Printf("ADB URL: %s\n", result.URL)
    // Example output: "adb connect xx.xx.xx.xx:xxxxx"
    fmt.Printf("Request ID: %s\n", result.RequestID)
} else {
    fmt.Printf("Error: %s\n", result.ErrorMessage)
}
```

**Using the ADB Connection:**

Once you have the ADB URL, you can use it to connect to the mobile device:

```bash
# Connect to the mobile device
adb connect xx.xx.xx.xx:xxxxx

# Verify the connection
adb devices

# Now you can use standard ADB commands
adb shell
adb install app.apk
adb logcat
adb pull /sdcard/file.txt
adb push file.txt /sdcard/
```

**Error Handling:**

```go
result := session.Mobile.GetAdbUrl(adbkeyPub)
if !result.Success {
    // Handle errors
    if strings.Contains(result.ErrorMessage, "mobile environment") {
        fmt.Println("Error: This method requires a mobile environment session")
    } else {
        fmt.Printf("Error: %s\n", result.ErrorMessage)
    }
}
```

**Requirements:**
- Session must be created with a mobile environment image
- Valid ADB public key is required for authentication
- The returned URL format is: `adb connect <IP>:<Port>`

---

## Complete Usage Example

This example demonstrates a complete workflow of mobile automation:

```go
package main

import (
    "fmt"
    "os"

    "github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
)

func main() {
    // Initialize client
    client, err := agentbay.NewAgentBay("", nil)
    if err != nil {
        fmt.Printf("Error: %v\n", err)
        os.Exit(1)
    }

    // Create mobile session
    // Verified: ✓ Session creates successfully with mobile_latest image
    params := agentbay.NewCreateSessionParams().
        WithImageId("mobile_latest")

    result, err := client.Create(params)
    if err != nil {
        fmt.Printf("Error: %v\n", err)
        os.Exit(1)
    }

    session := result.Session
    fmt.Printf("Session created: %s\n", session.SessionID)

    defer client.Delete(session)

    // Take initial screenshot
    // Verified: ✓ Returns OSS URL
    screenshot := session.Mobile.Screenshot()
    fmt.Println("Screenshot:", screenshot.Data)

    // Tap on screen center
    // Verified: ✓ Successfully taps
    session.Mobile.Tap(500, 500)

    // Swipe left to right
    // Verified: ✓ Successfully swipes
    session.Mobile.Swipe(100, 500, 900, 500, 300)

    // Input text
    // Verified: ✓ Successfully inputs text
    session.Mobile.InputText("Search query")

    // Press BACK button
    session.Mobile.SendKey(4)

    // Get clickable UI elements
    // Verified: ✓ Returns list of elements
    elements := session.Mobile.GetClickableUIElements(5000)
    fmt.Printf("Found %d clickable elements\n", len(elements.Elements))

    // Find and interact with specific element
    for _, elem := range elements.Elements {
        if elem.Text == "Login" {
            // Tap on the element center
            if elem.Bounds != nil {
                centerX := (elem.Bounds.Left + elem.Bounds.Right) / 2
                centerY := (elem.Bounds.Top + elem.Bounds.Bottom) / 2
                session.Mobile.Tap(centerX, centerY)
            }
            break
        }
    }

    // Get all UI elements
    // Verified: ✓ Returns all elements
    allElements := session.Mobile.GetAllUIElements(5000)
    fmt.Printf("Found %d total elements\n", len(allElements.Elements))

    // Get installed apps
    // Verified: ✓ Returns list of apps
    apps := session.Mobile.GetInstalledApps(true, true, true)
    fmt.Printf("Found %d apps\n", len(apps.Apps))
    for _, app := range apps.Apps {
        fmt.Printf("  - %s\n", app.Name)
    }

    // Start an app (example)
    if len(apps.Apps) > 0 {
        app := apps.Apps[0]
        processes := session.Mobile.StartApp(app.StartCmd, app.WorkDirectory, "")
        if processes.ErrorMessage == "" {
            fmt.Printf("Started app with %d processes\n", len(processes.Processes))

            // Stop the app
            if len(processes.Processes) > 0 {
                session.Mobile.StopAppByPName(processes.Processes[0].PName)
            }
        }
    }
}
```

## UI Element Interaction Pattern

A common pattern for interacting with UI elements:

```go
// 1. Get clickable elements
elements := session.Mobile.GetClickableUIElements(5000)

// 2. Find element by various criteria
var targetElement *mobile.UIElement

// Find by text
for _, elem := range elements.Elements {
    if elem.Text == "Submit" {
        targetElement = elem
        break
    }
}

// Find by resource ID
for _, elem := range elements.Elements {
    if elem.ResourceID == "com.example:id/button_login" {
        targetElement = elem
        break
    }
}

// Find by content description
for _, elem := range elements.Elements {
    if elem.ContentDesc == "Login button" {
        targetElement = elem
        break
    }
}

// 3. Tap on element center
if targetElement != nil && targetElement.Bounds != nil {
    centerX := (targetElement.Bounds.Left + targetElement.Bounds.Right) / 2
    centerY := (targetElement.Bounds.Top + targetElement.Bounds.Bottom) / 2
    session.Mobile.Tap(centerX, centerY)
}
```

## Common Mobile Gestures

```go
// Scroll down (swipe up)
session.Mobile.Swipe(500, 1200, 500, 300, 400)

// Scroll up (swipe down)
session.Mobile.Swipe(500, 300, 500, 1200, 400)

// Scroll left (swipe right)
session.Mobile.Swipe(200, 600, 800, 600, 400)

// Scroll right (swipe left)
session.Mobile.Swipe(800, 600, 200, 600, 400)

// Quick tap
session.Mobile.Tap(500, 500)

// Long press (use longer swipe duration at same position)
session.Mobile.Swipe(500, 500, 500, 500, 1000)
```

## Best Practices

1. **Session Image**: Always use a mobile environment image (e.g., `mobile_latest`) for Mobile module operations
2. **Error Checking**: Check `ErrorMessage` field for operation results
3. **Timeout Values**: Use appropriate timeout values for UI element discovery (typically 5000-10000ms)
4. **Element Bounds**: Always check if `Bounds` is not nil before accessing coordinates
5. **Screenshots**: Take screenshots before and after critical operations for debugging
6. **Wait Strategy**: After tapping or swiping, add small delays or wait for UI updates
7. **Key Codes**: Refer to Android KeyEvent documentation for key codes
8. **App Management**: Use `GetInstalledApps()` to discover available applications

## Limitations

- SendKey operation may timeout in some environments (verified in tests)
- UI element discovery returns empty list when no UI is displayed
- Application management is limited to available apps in the mobile environment

## Related Resources

- [Session API Reference](../common-features/basics/session.md)
- [Computer API Reference](../computer-use/computer.md) - For Windows automation
- [UI API Reference](../computer-use/ui.md)




# Golang SDK Examples

This directory contains Golang examples demonstrating various features and capabilities of the AgentBay SDK.

## 📁 Directory Structure

The examples are organized by feature categories:

```
examples/
├── basic_usage/                   # Quick start example
├── common-features/               # Features available across all environments
│   ├── basics/                    # Essential features
│   │   ├── session_creation/      # Session lifecycle management
│   │   ├── session_params/        # Session parameter configuration
│   │   ├── command_example/       # Command execution
│   │   ├── filesystem_example/    # File operations
│   │   ├── watch_directory_example/ # Directory monitoring
│   │   ├── context_management/    # Context creation and management
│   │   ├── context_sync_example/  # Context synchronization
│   │   ├── context_sync_demo/     # Context sync demonstration
│   │   ├── data_persistence/      # Data persistence across sessions
│   │   ├── recycle_policy/        # Recycle policy configuration
│   │   ├── list_sessions/         # Session listing and filtering
│   │   └── get/                   # Session retrieval
│   └── advanced/                  # Advanced features
│       ├── agent_module/          # AI-powered automation
│       ├── vpc_session/           # Secure isolated network environments
│       └── archive-upload-mode-example/ # Archive upload mode
├── browser-use/                   # Browser automation (browser_latest)
│   └── browser/                   # Browser automation examples
├── computer-use/                  # Windows desktop automation (windows_latest)
│   ├── application_window/        # Application and window management
│   └── ui_example/                # UI automation
├── mobile-use/                    # Mobile UI automation (mobile_latest)
│   └── mobile_get_adb_url/        # ADB URL retrieval
└── codespace/                     # Code execution (code_latest)
    ├── code_example/              # Code execution example
    └── automation/                # Automation workflows
```

## 🚀 Quick Start

### Single-File Example

The fastest way to get started:

```bash
# Set your API key
export AGENTBAY_API_KEY=your_api_key_here

# Run the quick start example
cd basic_usage
go run main.go
```

This example demonstrates:
- Initializing the AgentBay client
- Creating sessions
- Basic operations (commands, file operations)
- Session cleanup

## 📚 Feature Categories

### [Common Features](common-features/)

Features available across all environment types (browser, computer, mobile, codespace).

**Basics:**
- **Session Management**: Create, configure, and manage cloud sessions
- **Command Execution**: Execute shell commands in cloud environments
- **File Operations**: Read, write, and manage files
- **Context Management**: Persistent data storage across sessions
- **Data Persistence**: Cross-session data sharing and synchronization

**Advanced:**
- **Agent Module**: AI-powered task automation with natural language
- **VPC Sessions**: Secure isolated network environments
- **Archive Upload**: Archive upload mode configuration

### [Browser Use](browser-use/)

Cloud-based browser automation with Playwright integration.

**Key Features:**
- Custom browser configuration
- Command line arguments
- Browser type selection
- Stealth mode and fingerprinting

### [Computer Use](computer-use/)

Windows desktop automation for application control and window management.

**Key Features:**
- Application management (start, stop, list)
- Window operations (maximize, minimize, resize, close)
- UI automation
- Desktop workflows

### [Mobile Use](mobile-use/)

Android mobile UI automation for app testing.

**Key Features:**
- ADB URL retrieval
- Mobile device connection
- Remote debugging

### [CodeSpace](codespace/)

Cloud-based development environment for code execution.

**Key Features:**
- Code execution
- Automation workflows
- Shell command execution

## 📋 Prerequisites

### Basic Requirements

- Go 1.19 or later
- Valid `AGENTBAY_API_KEY` environment variable

### Installation

```bash
# Clone the repository
git clone https://github.com/aliyun/wuying-agentbay-sdk.git
cd wuying-agentbay-sdk/golang

# Install dependencies
go mod download
```

## 🎯 Running Examples

```bash
# Set your API key
export AGENTBAY_API_KEY=your_api_key_here

# Run any example
cd docs/examples/basic_usage
go run main.go

# Or run from any example directory
cd docs/examples/common-features/basics/session_creation
go run main.go
```

## 💡 Common Patterns

### Basic Session Creation

```go
package main

import (
    "context"
    "fmt"
    "os"
    
    "github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
)

func main() {
    // Initialize client
    apiKey := os.Getenv("AGENTBAY_API_KEY")
    client := agentbay.NewClient(apiKey)
    
    // Create session
    ctx := context.Background()
    params := &agentbay.CreateSessionParams{
        ImageID: "linux_latest",
    }
    
    result, err := client.Create(ctx, params)
    if err != nil {
        panic(err)
    }
    
    session := result.Session
    fmt.Printf("Session created: %s\n", session.SessionID)
    
    // Use session...
    
    // Cleanup
    defer client.Delete(ctx, session.SessionID)
}
```

### File Operations

```go
// Write file
err := session.FileSystem.WriteFile(ctx, "/tmp/test.txt", []byte("content"))

// Read file
content, err := session.FileSystem.ReadFile(ctx, "/tmp/test.txt")
if err == nil {
    fmt.Println(string(content))
}
```

### Command Execution

```go
result, err := session.Command.Execute(ctx, "ls -la")
if err == nil {
    fmt.Println(result.Output)
}
```

## 🎓 Learning Path

### For Beginners

1. Start with [basic_usage](basic_usage/)
2. Explore [Common Features - Basics](common-features/basics/)
3. Try environment-specific examples based on your use case

### For Experienced Developers

1. Review [Common Features](common-features/) for SDK capabilities
2. Jump to your specific environment:
   - [Browser Use](browser-use/) for web automation
   - [Computer Use](computer-use/) for desktop automation
   - [Mobile Use](mobile-use/) for mobile automation
   - [CodeSpace](codespace/) for code execution
3. Explore [Advanced Features](common-features/advanced/) for integrations

## 📖 Best Practices

1. **Always Clean Up**: Delete sessions when done to free resources
2. **Error Handling**: Always check errors before using results
3. **Context Usage**: Use context for cancellation and timeouts
4. **Resource Limits**: Be aware of concurrent session limits
5. **Defer Cleanup**: Use `defer` for session cleanup

## 🔍 Example Index

### By Use Case

**Web Automation:**
- Browser configuration: `browser-use/browser/custom_browser_config.go`
- Browser command args: `browser-use/browser/browser_command_args.go`

**Desktop Automation:**
- Application management: `computer-use/application_window/main.go`
- UI automation: `computer-use/ui_example/main.go`

**Mobile Automation:**
- ADB integration: `mobile-use/mobile_get_adb_url/main.go`

**Code Execution:**
- Code execution: `codespace/code_example/main.go`
- Automation: `codespace/automation/main.go`

**Data Management:**
- File operations: `common-features/basics/filesystem_example/main.go`
- Context management: `common-features/basics/context_management/main.go`
- Data persistence: `common-features/basics/data_persistence/main.go`

**Advanced Features:**
- AI Agent: `common-features/advanced/agent_module/main.go`
- VPC sessions: `common-features/advanced/vpc_session/main.go`

## 🆘 Troubleshooting

### Resource Creation Delay

If you see "The system is creating resources" message:
- Wait 90 seconds and retry
- This is normal for resource initialization

### API Key Issues

Ensure your API key is properly set:
```bash
export AGENTBAY_API_KEY=your_api_key_here
# Verify
echo $AGENTBAY_API_KEY
```

### Module Issues

If you get module errors:
```bash
# Ensure dependencies are installed
go mod download

# Update dependencies
go mod tidy
```

## 📚 Related Documentation

- [Golang SDK Documentation](../../)
- [API Reference](../api/)
- [Quick Start Guide](../../../docs/quickstart/README.md)
- [Feature Guides](../../../docs/guides/README.md)

## 🤝 Getting Help

- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Documentation](../../../docs/README.md)

---

💡 **Tip**: Start with `basic_usage/` for a quick overview, then explore category-specific examples based on your needs.





## Archive Upload Mode Context Sync Example

This directory contains examples demonstrating the Archive upload mode functionality for context synchronization in the AgentBay Go SDK.

## Overview

The Archive upload mode is designed for efficient file transfer by compressing files before uploading them to the context storage. This is particularly useful when:

- Working with large files
- Dealing with many files
- Optimizing bandwidth usage
- Reducing upload time for compressible content

## Files

### `main.go`

A comprehensive example that demonstrates:

1. **Context Creation**: Creating a context for Archive upload mode
2. **Sync Policy Configuration**: Setting up sync policy with Archive uploadMode
3. **Session Management**: Creating and managing sessions with context sync
4. **File Operations**: Writing files to the context path
5. **Context Sync**: Synchronizing context before retrieving information
6. **Context Info**: Retrieving context status information
7. **File Listing**: Listing files in context sync directory
8. **Cleanup**: Proper session cleanup and error handling

## Key Features Demonstrated

### Archive Upload Mode Configuration

```go
// Configure sync policy with Archive upload mode
uploadPolicy := &agentbay.UploadPolicy{
    UploadMode: agentbay.UploadModeArchive, // Set to Archive mode
}
syncPolicy := &agentbay.SyncPolicy{
    UploadPolicy: uploadPolicy,
}

// Create context sync with Archive mode
contextSync := &agentbay.ContextSync{
    ContextID: contextResult.ContextID,
    Path:      "/tmp/archive-mode-test",
    Policy:    syncPolicy,
}
```

### Session Creation with Context Sync

```go
sessionParams := agentbay.NewCreateSessionParams().
    WithLabels(map[string]string{
        "example":    fmt.Sprintf("archive-mode-%s", uniqueID),
        "type":       "archive-upload-demo",
        "uploadMode": string(agentbay.UploadModeArchive),
    }).
    WithContextSync([]*agentbay.ContextSync{contextSync})

sessionResult, err := ab.Create(sessionParams)
```

### File Operations

```go
// Write file to context path
writeResult, err := session.FileSystem.WriteFile(filePath, fileContent, "overwrite")
```

### Context Sync and Information Retrieval

```go
// Call context sync before getting info
syncResult, err := session.Context.Sync()

// Get context status information after sync
infoResult, err := session.Context.Info()

// Display context status details
for index, status := range infoResult.ContextStatusData {
    fmt.Printf("Context ID: %s\n", status.ContextId)
    fmt.Printf("Path: %s\n", status.Path)
    fmt.Printf("Status: %s\n", status.Status)
    fmt.Printf("Task Type: %s\n", status.TaskType)
}
```

### File Listing in Context Directory

```go
// List files in context sync directory
listResult, err := ab.Context.ListFiles(contextID, syncDirPath, 1, 10)

// Display file entries
for index, entry := range listResult.Entries {
    fmt.Printf("FilePath: %s\n", entry.FilePath)
    fmt.Printf("FileType: %s\n", entry.FileType)
    fmt.Printf("FileName: %s\n", entry.FileName)
    fmt.Printf("Size: %d bytes\n", entry.Size)
}
```

## Running the Example

### Prerequisites

1. **Environment Setup**: Set your AgentBay API key
   ```bash
   export AGENTBAY_API_KEY="your-api-key-here"
   ```

2. **Dependencies**: Ensure you have the Go modules downloaded
   ```bash
   go mod tidy
   ```

### Execution

```bash
# Navigate to the example directory
cd golang/docs/examples/archive-upload-mode-example

# Run the example
go run main.go
```

### Expected Output

The example will output detailed logs showing:

```
🚀 AgentBay Archive Upload Mode Context Sync Example
============================================================

📦 === Archive Upload Mode Context Sync Example ===

📦 Step 1: Creating context for Archive upload mode...
✅ Context created successfully!
   Context ID: ctx_xxxxx
   Request ID: req_xxxxx

⚙️  Step 2: Configuring sync policy with Archive upload mode...
✅ Sync policy configured with uploadMode: Archive

🔧 Step 3: Creating context sync configuration...
✅ Context sync created:
   Context ID: ctx_xxxxx
   Path: /tmp/archive-mode-test
   Upload Mode: Archive

🏗️  Step 4: Creating session with Archive mode context sync...
✅ Session created successfully!
   Session ID: sess_xxxxx
   Request ID: req_xxxxx
   App Instance ID: app_xxxxx

📝 Step 5: Creating test files in Archive mode context...
📄 Creating file: /tmp/archive-mode-test/test-file-5kb.txt
📊 File content size: 5120 bytes
✅ File write successful!
   Request ID: req_xxxxx

🔄 Step 6: Testing context sync functionality...
✅ Context sync successful!
   Request ID: req_xxxxx

📊 Step 6.5: Testing context info functionality after sync...
✅ Context info retrieved successfully!
   Request ID: req_xxxxx
   Context status data count: X

📋 Context status details:
   [0] Context ID: ctx_xxxxx
       Path: /tmp/archive-mode-test
       Status: Success
       Task Type: upload

🔍 Step 7: Listing files in context sync directory...
✅ List files successful!
   Request ID: req_xxxxx
   Total files found: X

📋 Files in context sync directory:
   [0] FilePath: /tmp/archive-mode-test/test-file-5kb.txt
       FileType: file
       FileName: test-file-5kb.txt
       Size: 5120 bytes

🎉 Archive upload mode example completed successfully!
✅ All operations completed without errors.

🧹 Step 8: Cleaning up session...
✅ Session deleted successfully!
   Success: true
   Request ID: req_xxxxx
```

## Related Documentation

- [Context Sync Documentation](../../../../docs/guides/common-features/basics/data-persistence.md)
- [Session Management Guide](../../../../docs/guides/common-features/basics/session-management.md)
- [File Operations Guide](../../../../docs/guides/common-features/basics/file-operations.md)

## Troubleshooting

### Common Issues

1. **API Key Not Set**
   ```
   Warning: AGENTBAY_API_KEY environment variable not set
   ```
   **Solution**: Set the environment variable or update the API key in the code

2. **Context Creation Failed**
   ```
   context creation failed: [error message]
   ```
   **Solution**: Check your API key and network connectivity

3. **Session Creation Failed**
   ```
   session creation failed: [error message]
   ```
   **Solution**: Verify context sync configuration and try again

4. **File Operation Failed**
   ```
   file write failed: [error message]
   ```
   **Solution**: Check file path permissions and available disk space

## Support

For additional help:
- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Documentation Home](../../../README.md)



# Basic Usage Example

This example demonstrates the basic usage of the Wuying AgentBay SDK, including:

- Initializing the AgentBay client
- Creating a session
- Executing commands
- Reading files
- Listing sessions
- Deleting sessions

## Running the Example

```bash
cd basic_usage
go run main.go
```

Make sure you have set the `AGENTBAY_API_KEY` environment variable or replace the placeholder in the code with your actual API key.




# Golang Browser Examples

This directory contains Golang examples demonstrating how to use the AgentBay Browser API.

## Prerequisites

1. **Install Golang SDK**:
   ```bash
   go get github.com/aliyun/wuying-agentbay-sdk/golang
   ```

2. **Install Playwright for Go**:
   ```bash
   go get github.com/playwright-community/playwright-go
   ```

3. **Install Playwright browsers**:
   ```bash
   go run github.com/playwright-community/playwright-go/cmd/playwright@latest install chromium
   ```

4. **Set API Key**:
   ```bash
   export AGENTBAY_API_KEY=your_api_key_here
   ```

## Examples

### 1. visit_aliyun.go

A basic example showing how to:
- Create a session with a browser-enabled image
- Initialize the browser with default options
- Connect to the browser using Playwright over CDP
- Navigate to a website and interact with it
- Take a screenshot

**Run:**
```bash
go run visit_aliyun.go
```

**Expected Output:**
```
Creating session...
Session created: sess-xxxxx
Initializing browser...
Browser CDP endpoint: ws://...
Starting Playwright...
Connecting to browser over CDP...
Navigating to https://www.aliyun.com...
Page title: 阿里云-计算，为了无法计算的价值
Taking screenshot...
Screenshot saved to aliyun_screenshot.png
Browser automation completed successfully!
Deleting session...
```

### 2. custom_browser_config.go

An advanced example demonstrating:
- Custom user agent configuration
- Custom viewport and screen dimensions
- Browser type selection (Chrome vs Chromium)
- Verification of browser configuration

**Run:**
```bash
go run custom_browser_config.go
```

**Expected Output:**
```
Creating session...
Session created: sess-xxxxx
Initializing browser with custom configuration...
Connecting to browser over CDP...
Navigating to user agent detection site...

Verifying browser configuration:
Effective UA: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36...
Viewport: 1366 x 768
Screen: 1366 x 768

Browser configuration verified successfully!
Deleting session...
```

## Key Browser APIs

### Browser Initialization

```go
// Create browser option with defaults
option := browser.NewBrowserOption()

// Initialize browser
success, err := session.Browser.Initialize(option)
if err != nil || !success {
    log.Fatalf("Browser initialization failed: %v", err)
}
```

### Custom Configuration

```go
option := browser.NewBrowserOption()

// Set custom user agent
customUA := "Mozilla/5.0 ..."
option.UserAgent = &customUA

// Set viewport
option.Viewport = &browser.BrowserViewport{
    Width:  1366,
    Height: 768,
}

// Set screen dimensions
option.Screen = &browser.BrowserScreen{
    Width:  1366,
    Height: 768,
}

// Choose browser type (for computer use images only)
chromeType := "chrome"
option.BrowserType = &chromeType  // "chrome" or "chromium"
```

### Getting CDP Endpoint

```go
endpointURL, err := session.Browser.GetEndpointURL()
if err != nil {
    log.Fatalf("Failed to get endpoint URL: %v", err)
}
```

### Connecting Playwright

```go
pw, err := playwright.Run()
if err != nil {
    log.Fatalf("Failed to start Playwright: %v", err)
}
defer pw.Stop()

browserInstance, err := pw.Chromium.ConnectOverCDP(endpointURL)
if err != nil {
    log.Fatalf("Failed to connect over CDP: %v", err)
}
defer browserInstance.Close()

context := browserInstance.Contexts()[0]
page, err := context.NewPage()
```

## Common Patterns

### Error Handling

Always check both error and success return values:

```go
success, err := session.Browser.Initialize(option)
if err != nil {
    log.Fatalf("Error: %v", err)
}
if !success {
    log.Fatal("Operation failed without error")
}
```

### Resource Cleanup

Use `defer` for proper resource cleanup:

```go
session := result.Session
defer session.Delete()  // Always clean up session

pw, err := playwright.Run()
defer pw.Stop()  // Always stop Playwright

browserInstance, err := pw.Chromium.ConnectOverCDP(endpointURL)
defer browserInstance.Close()  // Always close browser
```

### Pointer Values

Many BrowserOption fields use pointers to allow optional values:

```go
// String pointer
ua := "custom user agent"
option.UserAgent = &ua

// Struct pointer
option.Viewport = &browser.BrowserViewport{
    Width: 1920,
    Height: 1080,
}

// BrowserType uses pointer for optional selection
chromeType := "chrome"
option.BrowserType = &chromeType
```

## Troubleshooting

### "AGENTBAY_API_KEY environment variable not set"

Set your API key:
```bash
export AGENTBAY_API_KEY=your_api_key_here
```

### "Failed to connect over CDP"

Ensure the browser is initialized before connecting:
```go
success, err := session.Browser.Initialize(option)
if err != nil || !success {
    log.Fatal("Browser must be initialized first")
}
```

### "No browser contexts available"

The browser may not have started properly. Check initialization logs and ensure the browser image is available.

## Additional Resources

- [Browser Use Guide](../../../../../docs/guides/browser-use/README.md)
- [Core Features](../../../../../docs/guides/browser-use/core-features.md)
- [Advanced Features](../../../../../docs/guides/browser-use/advance-features.md)
- [Playwright Go Documentation](https://playwright.dev/docs/intro)





# Code Execution Example

This example demonstrates how to use the new **Code** module in the AgentBay SDK after the refactoring.

## What's New

In this refactored version:

- `RunCode` method has been moved from the `Command` module to a dedicated `Code` module
- Access code execution functionality via `session.Code.RunCode()` instead of `session.Command.RunCode()`
- The `Command` module now focuses only on shell command execution

## Features Demonstrated

1. **Python Code Execution**: Execute Python code in the cloud environment
2. **JavaScript Code Execution**: Execute JavaScript/Node.js code 
3. **Shell Command Execution**: Traditional command execution still works via `Command` module

## Usage

```go
// Create a session
session := /* ... create session ... */

// Execute Python code using the new Code module
codeResult, err := session.Code.RunCode(pythonCode, "python", 30)
if err != nil {
    log.Printf("Failed to run code: %v", err)
} else {
    fmt.Printf("Output: %s\n", codeResult.Output)
}

// Execute shell commands using the Command module
cmdResult, err := session.Command.ExecuteCommand("echo 'Hello!'", 5000)
```

## Running the Example

```bash
cd docs/examples/golang/code_example
go run main.go
```

Make sure you have set the `AGENTBAY_API_KEY` environment variable before running the example. 



# Agent Module Example

This example demonstrates how to use the Agent module to execute AI-powered tasks using natural language descriptions.

## Overview

The Agent module allows you to execute complex tasks using human-readable instructions, monitor task status, and terminate running tasks. This capability extends the functionality of cloud sessions by adding AI-powered automation.

## Running the Example

1. Ensure you have the AgentBay SDK installed
2. Set the `AGENTBAY_API_KEY` environment variable with your valid API key
3. Run the example:

```bash
cd docs/examples/golang/agent_module
go run main.go
```

## What the Example Does

1. Initializes the AgentBay client with your API key
2. Creates a new session
3. Executes a simple task using the Agent module ("Calculate the square root of 144")
4. Displays the task results
5. Cleans up by deleting the session

## Key Concepts

- **Session Creation**: All Agent operations happen within a session context
- **Task Execution**: Tasks are executed using natural language descriptions
- **Result Handling**: Task results include success status, output, and error information
- **Resource Management**: Sessions should be properly deleted when no longer needed

## Next Steps

Try modifying the task description to perform different operations, such as:
- "Find the current weather in New York City"
- "Calculate the factorial of 10"
- "List the prime numbers between 1 and 100"



## Archive Upload Mode Context Sync Example

This directory contains examples demonstrating the Archive upload mode functionality for context synchronization in the AgentBay Go SDK.

## Overview

The Archive upload mode is designed for efficient file transfer by compressing files before uploading them to the context storage. This is particularly useful when:

- Working with large files
- Dealing with many files
- Optimizing bandwidth usage
- Reducing upload time for compressible content

## Files

### `main.go`

A comprehensive example that demonstrates:

1. **Context Creation**: Creating a context for Archive upload mode
2. **Sync Policy Configuration**: Setting up sync policy with Archive uploadMode
3. **Session Management**: Creating and managing sessions with context sync
4. **File Operations**: Writing files to the context path
5. **Context Info**: Retrieving context status information
6. **File Verification**: Verifying file information and properties
7. **Cleanup**: Proper session cleanup and error handling

## Key Features Demonstrated

### Archive Upload Mode Configuration

```go
// Configure sync policy with Archive upload mode
uploadPolicy := &agentbay.UploadPolicy{
    UploadMode: "Archive", // Set to Archive mode
}
syncPolicy := &agentbay.SyncPolicy{
    UploadPolicy: uploadPolicy,
}

// Create context sync with Archive mode
contextSync := &agentbay.ContextSync{
    ContextID: contextResult.ContextID,
    Path:      "/tmp/archive-mode-test",
    Policy:    syncPolicy,
}
```

### Session Creation with Context Sync

```go
sessionParams := agentbay.NewCreateSessionParams().
    WithLabels(map[string]string{
        "example":    fmt.Sprintf("archive-mode-%s", uniqueID),
        "type":       "archive-upload-demo",
        "uploadMode": "Archive",
    }).
    WithContextSync([]*agentbay.ContextSync{contextSync})

sessionResult, err := ab.Create(sessionParams)
```

### File Operations

```go
// Write file to context path
writeResult, err := session.FileSystem.WriteFile(filePath, fileContent, "overwrite")

// Get file information
fileInfoResult, err := session.FileSystem.GetFileInfo(filePath)
```

### Context Information Retrieval

```go
// Get context status information
infoResult, err := session.Context.Info()

// Display context status details
for index, status := range infoResult.ContextStatusData {
    fmt.Printf("Context ID: %s\n", status.ContextId)
    fmt.Printf("Path: %s\n", status.Path)
    fmt.Printf("Status: %s\n", status.Status)
    fmt.Printf("Task Type: %s\n", status.TaskType)
}
```

## Running the Example

### Prerequisites

1. **Environment Setup**: Set your AgentBay API key
   ```bash
   export AGENTBAY_API_KEY="your-api-key-here"
   ```

2. **Dependencies**: Ensure you have the Go modules downloaded
   ```bash
   go mod tidy
   ```

### Execution

```bash
# Navigate to the example directory
cd golang/docs/examples/archive-upload-mode-example

# Run the example
go run main.go
```

### Expected Output

The example will output detailed logs showing:

```
🚀 AgentBay Archive Upload Mode Context Sync Example
============================================================

📦 === Archive Upload Mode Context Sync Example ===

📦 Step 1: Creating context for Archive upload mode...
✅ Context created successfully!
   Context ID: ctx_xxxxx
   Request ID: req_xxxxx

⚙️  Step 2: Configuring sync policy with Archive upload mode...
✅ Sync policy configured with uploadMode: Archive

🔧 Step 3: Creating context sync configuration...
✅ Context sync created:
   Context ID: ctx_xxxxx
   Path: /tmp/archive-mode-test
   Upload Mode: Archive

🏗️  Step 4: Creating session with Archive mode context sync...
✅ Session created successfully!
   Session ID: sess_xxxxx
   Request ID: req_xxxxx
   App Instance ID: app_xxxxx

📝 Step 5: Creating test files in Archive mode context...
📄 Creating file: /tmp/archive-mode-test/test-file-5kb.txt
📊 File content size: 5120 bytes
✅ File write successful!
   Request ID: req_xxxxx

📊 Step 6: Testing context info functionality...
✅ Context info retrieved successfully!
   Request ID: req_xxxxx
   Context status data count: X

📋 Context status details:
   [0] Context ID: ctx_xxxxx
       Path: /tmp/archive-mode-test
       Status: Success
       Task Type: upload

🔍 Step 7: Verifying file information...
✅ File info retrieved successfully!
   Request ID: req_xxxxx
📄 File details:
   Size: 5120 bytes
   Is Directory: false
   Modified Time: 2025-10-22T09:52:00Z
   Mode: 644

🎉 Archive upload mode example completed successfully!
✅ All operations completed without errors.

🧹 Step 8: Cleaning up session...
✅ Session deleted successfully!
   Success: true
   Request ID: req_xxxxx
```

## Related Documentation

- [Context Sync Documentation](../../../../../../docs/guides/common-features/basics/data-persistence.md)
- [Session Management Guide](../../../../../../docs/guides/common-features/basics/session-management.md)
- [File Operations Guide](../../../../../../docs/guides/common-features/basics/file-operations.md)

## Troubleshooting

### Common Issues

1. **API Key Not Set**
   ```
   Warning: AGENTBAY_API_KEY environment variable not set
   ```
   **Solution**: Set the environment variable or update the API key in the code

2. **Context Creation Failed**
   ```
   context creation failed: [error message]
   ```
   **Solution**: Check your API key and network connectivity

3. **Session Creation Failed**
   ```
   session creation failed: [error message]
   ```
   **Solution**: Verify context sync configuration and try again

4. **File Operation Failed**
   ```
   file write failed: [error message]
   ```
   **Solution**: Check file path permissions and available disk space

## Support

For additional help:
- [GitHub Issues](https://github.com/aliyun/wuying-agentbay-sdk/issues)
- [Documentation Home](../../../README.md)



# VPC Session Example

This example demonstrates how to create and use VPC (Virtual Private Cloud) sessions with the AgentBay SDK.

## Overview

VPC sessions provide enhanced security and networking capabilities by running your cloud sessions within a private network environment. This example shows how to create a VPC session and use its available modules.

## Running the Example

1. Ensure you have the AgentBay SDK installed
2. Set the `AGENTBAY_API_KEY` environment variable with your valid API key
3. Run the example:

```bash
cd docs/examples/golang/vpc_session
go run main.go
```

## What the Example Does

1. Initializes the AgentBay client with your API key
2. Creates a new VPC session with specific parameters
3. Tests FileSystem operations by writing and reading a file
4. Tests Command operations by executing system commands
5. Cleans up by deleting the session

## Key Concepts

- **VPC Session Creation**: VPC sessions are created by setting the `IsVpc` parameter to `true`
- **Module Availability**: VPC sessions have limited module availability compared to standard sessions
- **Resource Management**: VPC sessions should be properly deleted when no longer needed
- **Security**: VPC sessions provide network isolation for sensitive operations

## Available Modules in VPC Sessions

1. **FileSystem**: File and directory operations
2. **Command**: Command execution
3. **System Tools**: Specialized system-level tools
4. **Browser Tools**: Browser automation capabilities

## Next Steps

Try modifying the example to:
- Use context synchronization with VPC sessions
- Test different command executions
- Implement error handling for unavailable modules



# Command Execution Example

This example demonstrates how to use the command execution features of the AgentBay SDK for Golang.

## Features Demonstrated

- Executing shell commands
- Setting custom timeouts for commands
- Running Python code
- Running JavaScript code
- Executing multi-line command sequences

## Running the Example

1. Make sure you have installed the AgentBay SDK:

```bash
go get github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay
```

2. Set your API key as an environment variable (recommended):

```bash
export AGENTBAY_API_KEY=your_api_key_here
```

3. Run the example:

```bash
go run main.go
```

## Code Explanation

The example demonstrates different ways to execute commands:

1. Basic shell command execution
2. Command execution with custom timeout
3. Running Python code
4. Running JavaScript code with custom timeout
5. Executing a multi-line shell command sequence

The code also demonstrates proper session cleanup using defer.

For more details on command execution, see the [Command API Reference](../../../../../../typescript/docs/api/common-features/basics/command.md) and [Command Execution Tutorial](../../../../../../docs/guides/common-features/basics/command-execution.md). 



# Context Management Example

This example demonstrates how to use the Context Management features of the AgentBay SDK for Golang.

## Features Demonstrated

- Listing all contexts
- Getting or creating a context
- Creating a session with a context
- Updating a context
- Clearing context data (asynchronous and synchronous)
- Deleting a context

## Running the Example

1. Make sure you have installed the AgentBay SDK:

```bash
go get github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay
```

2. Set your API key as an environment variable (recommended):

```bash
export AGENTBAY_API_KEY=your_api_key_here
```

3. Run the example:

```bash
go run main.go
```

## Code Explanation

The example demonstrates a full lifecycle of context management:

1. Initialize the AgentBay client with an API key
2. List all existing contexts to see what's available
3. Get an existing context by name, or create it if it doesn't exist
4. Create a session using the context
5. Update the context's properties
6. Clear the context's persistent data (demonstrates both async and sync methods)
7. Clean up by deleting the session and context

For more details on context management, see the [Context API Reference](../../../../../../typescript/docs/api/common-features/basics/context.md) and [Data Persistence Tutorial](../../../../../../docs/guides/common-features/basics/data-persistence.md).



# Context Sync Dual-Mode Example (Go)

This example demonstrates the dual-mode `context.sync()` functionality in the Go SDK, showing both asynchronous callback-based and synchronous wait-based usage patterns.

## Features Demonstrated

- **Context Creation**: Creates persistent contexts for data storage
- **Test Data Generation**: Creates sample files and directories for sync testing
- **Dual-Mode Context Sync**: Shows both callback and wait patterns
- **Session Management**: Proper session creation and cleanup
- **Error Handling**: Comprehensive error handling and cleanup
- **Timing Measurement**: Tracks sync operation duration
- **Concurrent Execution**: Demonstrates running multiple sync operations

## Usage Patterns

### 1. Async Mode with Callback

```go
// Use callback mode - function returns immediately
syncResult, err := session.Context.SyncWithCallback(
    "", "", "", // contextId, path, mode
    func(success bool) {
        if success {
            fmt.Println("✅ Context sync completed successfully")
        } else {
            fmt.Println("❌ Context sync completed with failures")
        }
        // Handle completion in callback
    },
    150, 1500, // maxRetries, retryInterval (milliseconds)
)
```

### 2. Sync Mode with Wait

```go
// Use wait mode - function waits for completion
syncResult, err := session.Context.SyncWithCallback("", "", "", nil, 150, 1500)
if err != nil {
    return fmt.Errorf("context sync failed: %w", err)
}

if syncResult.Success {
    fmt.Println("✅ Context sync completed successfully")
} else {
    fmt.Println("❌ Context sync completed with failures")
}
```

## Configuration

The example uses default configuration values:

- **Max Retries**: 150 attempts
- **Retry Interval**: 1500 milliseconds (1.5 seconds)
- **Context Path**: `/tmp/sync_data`
- **Test Files**: Small, medium, and JSON configuration files

## Running the Example

```bash
# From the golang directory
go run docs/examples/data_persistence/context_sync_demo.go

# Or build and run
go build -o context_sync_demo docs/examples/data_persistence/context_sync_demo.go
./context_sync_demo
```

## Expected Output

```
🔄 AgentBay Context Sync Dual-Mode Example (Go)

============================================================
🔄 Method 1: context_sync_with_callback (Async with callback)
============================================================
🔄 Starting context sync with callback demo...

📦 Creating context for persistent storage...
✅ Context created: sync-callback-demo

📦 Creating session with context sync...
✅ Session created: session-123

💾 Creating test data...
✅ Created file: /tmp/sync_data/test_files/small.txt
✅ Created file: /tmp/sync_data/test_files/medium.txt
✅ Created file: /tmp/sync_data/config.json
📊 Created 3/3 test files

📞 Calling context.sync() with callback...
📤 Sync initiation result: success=true, requestId=req-456
⏳ Waiting for callback to complete...
✅ Context sync completed successfully in 2.1s
🗑️  Deleting session from callback...
✅ Session deleted successfully from callback

⏳ Sleeping 3 seconds before next demo...

============================================================
🔄 Method 2: context_sync (Sync with wait)
============================================================
🔄 Starting context sync demo...

📦 Creating context for persistent storage...
✅ Context created: sync-await-demo

📦 Creating session with context sync...
✅ Session created: session-789

💾 Creating test data...
✅ Created file: /tmp/sync_data/test_files/small.txt
✅ Created file: /tmp/sync_data/test_files/medium.txt
✅ Created file: /tmp/sync_data/config.json
📊 Created 3/3 test files

⏳ Calling context.sync() with wait...
✅ Context sync completed successfully in 1.5s
📤 Sync result: success=true, requestId=req-101
🗑️  Deleting session...
✅ Session deleted successfully

⏳ Waiting for callback demo to complete...

✅ Context sync dual-mode example completed
```

## Key Differences from Python/TypeScript

1. **Goroutines**: Uses `go` keyword for async execution instead of `asyncio` or `Promise`
2. **Callbacks**: Uses Go function types instead of lambda functions
3. **Error Handling**: Uses Go's explicit error handling with `error` return values
4. **Time Measurement**: Uses `time.Since()` for duration calculation
5. **Concurrency**: Uses goroutines and channels for concurrent execution

## API Reference

### ContextManager.SyncWithCallback

```go
func (cm *ContextManager) SyncWithCallback(
    contextId, path, mode string,
    callback SyncCallback,
    maxRetries, retryInterval int
) (*ContextSyncResult, error)
```

**Parameters:**

- `contextId`: Optional context ID to sync
- `path`: Optional path to sync
- `mode`: Optional sync mode (upload/download)
- `callback`: Callback function for async mode (nil for sync mode)
- `maxRetries`: Maximum number of polling attempts (default: 150)
- `retryInterval`: Interval between polls in milliseconds (default: 1500)

**Returns:**

- `*ContextSyncResult`: Contains success status and request ID
- `error`: Any error that occurred during sync initiation

### SyncCallback Type

```go
type SyncCallback func(success bool)
```

**Parameters:**

- `success`: `true` if sync completed successfully, `false` if failed or timed out

## Error Handling

The example includes comprehensive error handling for:

- Context creation failures
- Session creation failures
- File system operations
- Sync operation failures
- Session deletion failures

All errors are logged with appropriate context and the application continues execution where possible.

## Performance Considerations

- **Async Mode**: Returns immediately, allowing for concurrent operations
- **Sync Mode**: Blocks until completion, suitable for sequential workflows
- **Polling**: Configurable retry intervals and maximum attempts
- **Memory**: Efficient goroutine usage for background operations
- **Timeouts**: Built-in timeout protection to prevent infinite polling




# Context Synchronization Example

This example demonstrates how to use the Context Synchronization features of the AgentBay SDK for Golang.

## Features Demonstrated

- Creating and retrieving contexts
- Creating basic context sync configurations
- Creating advanced context sync configurations with policies
- Working with upload, download, and delete policies
- Using whitelist and blacklist configurations
- Creating sessions with multiple context synchronizations
- Managing context synchronization from a session
- Using the builder pattern for sync configurations

## Running the Example

1. Make sure you have installed the AgentBay SDK:

```bash
go get github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay
```

2. Set your API key as an environment variable (recommended):

```bash
export AGENTBAY_API_KEY=your_api_key_here
```

3. Run the example:

```bash
go run main.go
```

## Code Explanation

The example demonstrates a full lifecycle of context synchronization:

1. Create a new persistent context
2. Create basic and advanced context sync configurations
3. Configure upload, download, and delete policies
4. Set up whitelist and blacklist rules
5. Add multiple context sync configurations to a session
6. Create a session with context synchronizations
7. Interact with the context manager from a session
8. Use the builder pattern for creating context sync configurations
9. Clean up resources (session and context)

For more details on context synchronization, see the [Context API Reference](../../../../../../typescript/docs/api/common-features/basics/context.md) and [Data Persistence Tutorial](../../../../../../docs/guides/common-features/basics/data-persistence.md). 



# AgentBay SDK - Data Persistence Examples

This directory contains examples demonstrating data persistence functionality using the AgentBay SDK for Golang:

## Examples

### 1. `main.go` - Basic Data Persistence

Demonstrates fundamental data persistence features:

- Context creation for persistent storage
- File persistence across multiple sessions
- Context synchronization and file sharing
- Cross-session data verification

### 2. `recycle_policy_example.go` - Data Lifecycle Management

Demonstrates RecyclePolicy for controlling context data lifecycle:

- Using default RecyclePolicy (keeps data forever)
- Setting custom lifecycle durations (1 day, 3 days, etc.)
- Applying RecyclePolicy to specific paths
- Available lifecycle options

## Features Demonstrated

1. **Context Management**: Creating and managing contexts for persistent storage
2. **Multi-Session Persistence**: Writing data in one session and reading it in another
3. **File Operations**: Creating directories, writing JSON configs, logs, and data files
4. **Context Synchronization**: Automatic sync of data between sessions and cloud storage
5. **Error Handling**: Comprehensive error handling throughout the process
6. **Resource Cleanup**: Proper cleanup of sessions and contexts

## What This Example Does

1. **Step 1**: Creates a persistent context for data storage
2. **Step 2**: Creates the first session with context synchronization configured
3. **Step 3**: Writes various types of data (JSON config, logs, text files) in the first session
4. **Step 4**: Deletes the first session (with context sync to preserve data)
5. **Step 5**: Creates a second session with the same context sync configuration
6. **Step 6**: Verifies that all data from the first session is accessible in the second session
7. **Step 7**: Adds new data in the second session
8. **Step 8**: Cleans up all resources

## Expected Output

The example will show:
- Successful context creation
- File creation and writing in the first session
- Session deletion with context synchronization
- New session creation and data verification
- Confirmation that persistent data survives across sessions

## Prerequisites

- Valid AgentBay API key set in environment variable `AGENTBAY_API_KEY`
- Network connectivity to AgentBay services
- Golang environment set up with required dependencies

## Running the Example

```bash
# Set your API key
export AGENTBAY_API_KEY="your-api-key-here"

# Run the example
go run main.go
```

## Key Concepts

- **Context**: A persistent storage space that survives across sessions
- **Context Sync**: Configuration that determines how data is synchronized between sessions and cloud storage
- **Session**: A temporary compute environment that can mount contexts for data access
- **Sync Policy**: Rules governing when and how data is uploaded/downloaded during synchronization

This example is based on the Python data persistence example and demonstrates the same functionality using idiomatic Go patterns and the Golang AgentBay SDK.



# FileSystem Example

This example demonstrates how to use the AgentBay SDK's FileSystem module to perform various file operations in the cloud environment.

## Features Demonstrated

- Creating directories
- Writing files
- Reading files
- Getting file information
- Listing directory contents
- Editing files
- Searching for files
- Moving/renaming files

## Prerequisites

- Go 1.16 or later
- AgentBay API key (set as `AGENTBAY_API_KEY` environment variable)

## Running the Example

1. Set your API key:
   ```bash
   export AGENTBAY_API_KEY="your-api-key-here"
   ```

2. Run the example:
   ```bash
   go run main.go
   ```

## Expected Output

The example will create a session, perform various file system operations, and clean up afterwards. 
You should see output showing the results of each operation, including:

- Directory creation
- File creation and verification
- File content reading and display
- File information retrieval
- Directory listing
- File editing and content verification
- File search results
- File move/rename operation

## Notes

- All resources are cleaned up when the example completes
- The session is automatically deleted at the end of the example 



# Get API Example

This example demonstrates how to use the `Get` API to retrieve a session by its ID.

## Description

The `Get` API allows you to retrieve a session object by providing its session ID. This is useful when you have a session ID from a previous operation and want to access or manage that session.

## Prerequisites

- Go 1.21 or higher
- Valid API key set in `AGENTBAY_API_KEY` environment variable

## Usage

```bash
# Set your API key
export AGENTBAY_API_KEY="your-api-key-here"

# Run the example
go run main.go
```

## Code Example

```go
package main

import (
    "fmt"
    "log"
    "os"

    "github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"
)

func main() {
    // Initialize AgentBay client
    apiKey := os.Getenv("AGENTBAY_API_KEY")
    client, err := agentbay.NewAgentBay(apiKey, nil)
    if err != nil {
        log.Fatalf("Failed to initialize AgentBay client: %v", err)
    }

    // Retrieve a session by ID
    sessionID := "your-session-id"
    result, err := client.Get(sessionID)
    if err != nil {
        log.Fatalf("Failed to get session: %v", err)
    }

    if !result.Success || result.Session == nil {
        log.Fatalf("Failed to get session: %s", result.ErrorMessage)
    }

    fmt.Printf("Retrieved session: %s\n", result.Session.SessionID)
    fmt.Printf("Request ID: %s\n", result.RequestID)

    // Use the session for further operations
    // ...
}
```

## API Reference

### Get

```go
func (a *AgentBay) Get(sessionID string) (*SessionResult, error)
```

Retrieves a session by its ID.

**Parameters:**
- `sessionID` (string): The ID of the session to retrieve

**Returns:**
- `*SessionResult`: Result object containing:
  - `Success` (bool): Whether the operation succeeded
  - `Session` (*Session): The Session instance if successful
  - `RequestID` (string): The API request ID
  - `ErrorMessage` (string): Error message if failed
- `error`: An error if a critical operation fails

## Expected Output

```
Creating a session...
Created session with ID: session-xxxxxxxxxxxxx

Retrieving session using Get API...
Successfully retrieved session:
  Session ID: session-xxxxxxxxxxxxx
  Request ID: DAD825FE-2CD8-19C8-BB30-CC3BA26B9398

Session is ready for use

Cleaning up...
Session session-xxxxxxxxxxxxx deleted successfully
```

## Notes

- The session ID must be valid and from an existing session
- The Get API internally calls the GetSession API endpoint
- The returned session object can be used for all session operations (commands, files, etc.)
- Always clean up sessions when done to avoid resource waste





# List Sessions Example (Golang)

This example demonstrates how to use the `List()` API to query and filter sessions in AgentBay.

## Prerequisites

1. **Set API Key**:
   ```bash
   export AGENTBAY_API_KEY='your-api-key-here'
   ```

2. **Install SDK** (if not already done):
   ```bash
   go get github.com/aliyun/wuying-agentbay-sdk/golang
   ```

## Running the Example

```bash
cd /path/to/wuying-agentbay-sdk/golang/docs/examples/list_sessions
go run main.go
```

## Key Features

- List all sessions
- Filter by single or multiple labels
- Pagination support
- Iterate through all pages

## API Usage

```go
import "github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay"

client, _ := agentbay.NewAgentBay(apiKey, nil)

// List all sessions
result, err := client.List(nil, nil, nil)

// Filter by labels
result, err = client.List(map[string]string{"project": "my-project"}, nil, nil)

// With pagination
page := 1
limit := int32(10)
result, err = client.List(
    map[string]string{"project": "my-project"},
    &page,
    &limit,
)
```

## Related Documentation

- [Session Management Guide](../../../../../../docs/guides/common-features/basics/session-management.md)
- [AgentBay API Reference](../../../../../../typescript/docs/api/common-features/basics/agentbay.md)





# Session Creation and Management Example

This example demonstrates comprehensive session creation and management using the Wuying AgentBay SDK. It covers various session types and configurations:

## Features Demonstrated

### 1. Basic Session Management
- Initializing the AgentBay client
- Creating a session with default parameters
- Listing all available sessions
- Creating multiple sessions
- Deleting sessions
- Verifying session deletion

### 2. Session with Labels
- Creating sessions with custom labels for organization
- Using labels for project management and environment tracking
- Retrieving and displaying session labels

### 3. Advanced Mobile Configuration Options

The example demonstrates comprehensive mobile session configuration using `MobileExtraConfig`. The following parameters are supported:

#### Core Configuration Parameters

- **`LockResolution`** (bool): Controls screen resolution behavior
  - `true`: Locks display resolution to prevent changes during session
  - `false`: Allows flexible resolution adjustments for different device types

- **`HideNavigationBar`** (bool): Controls system navigation bar visibility
  - `true`: Hides navigation bar for immersive full-screen experience
  - `false`: Shows navigation bar (default system behavior)

- **`UninstallBlacklist`** ([]string): List of package names protected from uninstallation
  - Prevents accidental or malicious removal of critical applications
  - Essential for system stability and security compliance
  - Example: `["com.android.systemui", "com.android.settings", "com.google.android.gms"]`

- **`AppManagerRule`** (*AppManagerRule): Application access control rules
  - **`RuleType`** (string): Either "White" (whitelist) or "Black" (blacklist)
  - **`AppPackageNameList`** ([]string): List of package names to allow or block

#### Configuration Examples

The example includes two configuration scenarios:

1. **Whitelist Mode**: Secure configuration with locked resolution, hidden navigation bar, and strict app control
2. **Blacklist Mode**: Flexible configuration with visible navigation bar and selective app blocking

#### JSON Structure

```json
{
  "mobile": {
    "lock_resolution": true,
    "hide_navigation_bar": true,
    "uninstall_blacklist": ["com.android.systemui", "com.android.settings"],
    "app_manager_rule": {
      "rule_type": "White",
      "app_package_name_list": ["com.allowed.app1", "com.allowed.app2"]
    }
  }
}

## Running the Example

```bash
cd session_creation
go run main.go
```

Make sure you have set the `AGENTBAY_API_KEY` environment variable or replace the placeholder in the code with your actual API key.




# Session Parameters Example

This example demonstrates how to use the session parameters features of the AgentBay SDK for Golang.

## Features Demonstrated

- Creating session parameters with custom labels
- Creating a session with custom labels
- Listing sessions by label filtering
- Implementing pagination with NextToken
- Cleaning up sessions

## Running the Example

1. Make sure you have installed the AgentBay SDK:

```bash
go get github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay
```

2. Set your API key as an environment variable (recommended):

```bash
export AGENTBAY_API_KEY=your_api_key_here
```

3. Run the example:

```bash
go run main.go
```

## Code Explanation

The example demonstrates session parameter usage:

1. Create session parameters with custom labels
2. Create a session using these parameters
3. List sessions filtered by a specific label
4. Demonstrate pagination by fetching the next page of results if available
5. Clean up by deleting the session

Session parameters allow you to customize how sessions are created and make it easier to find and manage them later. Custom labels are particularly useful for:

- Organizing sessions by project
- Tracking session owners
- Filtering sessions by purpose or state
- Implementing session management in multi-user environments

For more details on session parameters, see the [Session API Reference](../../../../../../typescript/docs/api/common-features/basics/session.md) and [Session Management Tutorial](../../../../../../docs/guides/common-features/basics/session-management.md).




# Watch Directory Example (Go)

This example demonstrates how to use the `watch_directory` functionality in the AgentBay Go SDK to monitor file system changes in real-time.

## Features Demonstrated

- Creating an AgentBay session with `code_latest` ImageId
- Setting up directory monitoring with callback functions
- Detecting file creation, modification, and deletion events
- Using the `GetFileChange` method for one-time change detection
- Proper resource cleanup and session management

## Prerequisites

1. Go 1.18 or later
2. AgentBay API key set as environment variable `AGENTBAY_API_KEY`

## Running the Example

```bash
# Set your API key
export AGENTBAY_API_KEY="your-api-key-here"

# Run the example
go run main.go
```

## What the Example Does

1. **Initializes AgentBay**: Creates a client with your API key
2. **Creates Session**: Sets up a session with `code_latest` ImageId
3. **Sets Up Monitoring**: Starts watching a temporary directory for changes
4. **Demonstrates File Operations**:
   - Creates a new file
   - Modifies the file
   - Creates another file
   - Creates a subdirectory
   - Deletes a file
5. **Shows GetFileChange**: Demonstrates one-time change detection
6. **Cleanup**: Properly stops monitoring and deletes the session

## Expected Output

The example will show real-time detection of file changes with output like:

```
=== AgentBay Watch Directory Example ===
✅ AgentBay client initialized
✅ Session created with ID: sess_xxxxxxxxxx
📁 Created test directory: /tmp/agentbay-watch-example-xxxxxx
👀 Starting to watch directory: /tmp/agentbay-watch-example-xxxxxx
📊 Polling interval: 500ms
⏳ Waiting for monitoring to start...

🎬 Demonstrating file operations...
📝 Creating a new file...

🔍 Detected 1 file changes:
  - FileChangeEvent(eventType='create', path='/tmp/agentbay-watch-example-xxxxxx/example.txt', pathType='file')

✏️  Modifying the file...

🔍 Detected 1 file changes:
  - FileChangeEvent(eventType='modify', path='/tmp/agentbay-watch-example-xxxxxx/example.txt', pathType='file')

📄 Creating another file...
📂 Creating a subdirectory...
🗑️  Deleting a file...

🔍 Demonstrating GetFileChange method...
📊 GetFileChange result:
  - Request ID: req_xxxxxxxxxx
  - Events count: X
  - File change details:
    • Modified files: [...]
    • Created files: [...]
    • Deleted files: [...]

⏹️  Stopping directory monitoring...
✅ Watch directory example completed successfully!
```

## Code Structure

### Key Components

1. **Session Management**:
   ```go
   sessionParams := &agentbay.CreateSessionParams{
       ImageId: "code_latest",
   }
   sessionResult, err := agentBay.Create(sessionParams)
   ```

2. **Directory Monitoring**:
   ```go
   callback := func(events []*filesystem.FileChangeEvent) {
       // Handle detected changes
   }
   
   stopChan := make(chan struct{})
   go func() {
       err := fileSystem.WatchDirectory(testDir, callback, 1000, stopChan)
   }()
   ```

3. **One-time Change Detection**:
   ```go
   result, err := fileSystem.GetFileChange(testDir)
   if err == nil && result.HasChanges() {
       // Process detected changes
   }
   ```

4. **Proper Cleanup**:
   ```go
   defer func() {
       _, err := agentBay.Delete(session)
   }()
   
   close(stopChan) // Stop monitoring
   ```

## Error Handling

The example includes comprehensive error handling for:
- AgentBay client initialization
- Session creation and deletion
- File operations
- Directory monitoring setup

## Performance Considerations

- **Polling Interval**: Set to 1000ms (1 second) for demonstration
- **Resource Management**: Proper cleanup prevents memory leaks
- **Callback Efficiency**: Keep callback functions lightweight

## Customization

You can modify the example to:
- Change the polling interval (minimum 100ms)
- Filter specific file types in the callback
- Monitor multiple directories simultaneously
- Add custom logging or processing logic

## Troubleshooting

### Common Issues

1. **API Key Not Set**: Ensure `AGENTBAY_API_KEY` environment variable is set
2. **Permission Errors**: Make sure the application has write access to `/tmp`
3. **Network Issues**: Check internet connectivity for AgentBay API access

### Debug Tips

- Enable verbose logging by adding debug prints
- Check the session ID in AgentBay dashboard
- Verify file operations are actually creating/modifying files
- Monitor system resources if running for extended periods 



# Application and Window Management Example

This example demonstrates how to use the Application and Window Management features of the AgentBay SDK for Golang.

## Features Demonstrated

- Getting installed applications on a remote session
- Listing visible applications
- Listing root windows
- Getting the active window
- Window manipulation operations (activate, maximize, minimize, restore, resize)
- Focus mode management

## Running the Example

1. Make sure you have installed the AgentBay SDK:

```bash
go get github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay
```

2. Set your API key as an environment variable (recommended):

```bash
export AGENTBAY_API_KEY=your_api_key_here
```

3. Run the example:

```bash
go run main.go
```

## Code Explanation

The example demonstrates a full lifecycle of application and window management:

1. Create a new session with a Linux image
2. Get installed applications
3. List visible applications
4. List root windows
5. Get the active window
6. Perform window operations (activate, maximize, minimize, restore, resize)
7. Enable and disable focus mode
8. Clean up by deleting the session

This example is useful for automation scenarios where you need to manipulate application windows programmatically, such as:

- Creating automated testing workflows
- Building assistive technologies
- Developing screen sharing and remote control applications
- Automating UI interactions

For more details on window management, see the [Window API Reference](../../../../../typescript/docs/api/computer-use/window.md) and [Application API Reference](../../../../../typescript/docs/api/computer-use/application.md).




# UI Interaction Example

This example demonstrates how to use the UI interaction features of the AgentBay SDK for Golang.

## Features Demonstrated

- Taking screenshots
- Getting UI elements
- Sending key events
- Performing mouse operations
- Simulating touch operations
- Handling UI element selection

## Running the Example

1. Make sure you have installed the AgentBay SDK:

```bash
go get github.com/aliyun/wuying-agentbay-sdk/golang/pkg/agentbay
```

2. Set your API key as an environment variable (recommended):

```bash
export AGENTBAY_API_KEY=your_api_key_here
```

3. Run the example:

```bash
go run main.go
```

## Code Explanation

The example demonstrates UI interactions in a remote session:

1. Create a new session with appropriate image
2. Take screenshots of the remote environment
3. Get all UI elements from the screen
4. Find clickable UI elements
5. Send key events to the environment
6. Perform mouse click operations
7. Simulate touch and swipe gestures
8. Clean up by deleting the session

UI interaction capabilities are particularly useful for:

- Automated testing of applications
- Building RPA (Robotic Process Automation) solutions
- Creating assistive technologies
- Implementing remote control applications
- Developing UI testing frameworks

For more details on UI interaction, see the [UI API Reference](../../../../../typescript/docs/api/computer-use/ui.md). 



# Mobile GetAdbUrl Example

This example demonstrates how to use the `GetAdbUrl` method to retrieve an ADB (Android Debug Bridge) connection URL for a mobile session.

## Prerequisites

- Go 1.18 or higher
- AgentBay API key (set as environment variable `AGENTBAY_API_KEY`)
- ADB public key (for production use)

## What This Example Does

1. Creates a mobile session using `mobile_latest` image
2. Calls `session.Mobile.GetAdbUrl()` with an ADB public key
3. Retrieves the ADB connection URL
4. Cleans up the session

## Important Notes

- **Mobile Environment Required**: The `GetAdbUrl` method only works with mobile sessions (`mobile_latest` image). Using other image types will result in an error.
- **ADB Public Key**: You need to provide your ADB public key. The example uses a desensitized placeholder key.
- **Connection URL Format**: The returned URL follows the format: `adb connect <IP>:<Port>`

## Running the Example

```bash
# Set your API key
export AGENTBAY_API_KEY=your_api_key_here

# Run the example
go run main.go
```

## Expected Output

```
=== Mobile GetAdbUrl Example ===

Creating mobile session...
✅ Session created successfully
   Session ID: session-xxxxxxxxx
   Image ID: mobile_latest

Getting ADB connection URL...
✅ ADB URL retrieved successfully
   URL: adb connect xx.xx.xx.xx:xxxxx
   Request ID: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx

You can now connect to the mobile device using:
   adb connect xx.xx.xx.xx:xxxxx

Cleaning up session...
✅ Session deleted successfully (RequestID: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx)

=== Example completed successfully ===
```

## Using the ADB Connection

Once you have the ADB connection URL, you can use it to connect to the mobile device:

```bash
# Connect to the mobile device
adb connect xx.xx.xx.xx:xxxxx

# Verify the connection
adb devices

# Now you can use standard ADB commands
adb shell
adb install app.apk
adb logcat
```

## Error Handling

The example includes error handling for common scenarios:

- Missing API key
- Session creation failure
- Non-mobile environment (wrong image type)
- ADB URL retrieval failure

## Related Documentation

- [Mobile API Documentation](../../../../../typescript/docs/api/mobile-use/mobile.md)
- [Session Creation Guide](../../common-features/basics/session_creation/README.md)
- [Basic Usage Example](../../basic_usage/README.md)






# Cookbook Examples


# AgentBay SDK Cookbook

The AgentBay SDK Cookbook is a collection of practical examples and use cases demonstrating how to leverage the AgentBay SDK for various automation scenarios. Each cookbook showcases a specific application of the SDK, providing both basic implementations and integrations with popular frameworks like LangChain.

## Sandbox Environments (envs)

The `envs` directory contains examples organized by sandbox environments. A sandbox environment in AgentBay refers to an isolated cloud computing environment where specific types of operations can be performed safely and efficiently. Each environment provides specialized capabilities for different use cases.

Currently, two distinct sandbox environments are implemented:

1. **browser** - A web browser sandbox environment that provides capabilities for web automation, including form filling, web scraping, and UI interactions.
2. **codespace** - A code execution sandbox environment that provides capabilities for running and testing code in isolated environments.

## Table of Contents

1. [Form-Filling Agent](./envs/browser/form-filling-agent/) - Demonstrates browser automation capabilities by automatically filling HTML forms
2. [Auto Testing Agent](./envs/codespace/auto-testing-agent/) - Shows how to automate Python testing workflows in cloud environments

## Overview

The AgentBay SDK provides a comprehensive suite of tools for efficient interaction with AgentBay cloud environments. These cookbooks demonstrate real-world applications of the SDK across different domains:

### Form-Filling Agent
This cookbook demonstrates how to create a form-filling agent using the Agent-Bay SDK. The agent can:
- Upload an HTML form to Agent-Bay environment
- Open the form in a browser using Agent-Bay's browser capabilities
- Use natural language instructions to fill form fields
- Submit the form automatically

### Auto Testing Agent
This cookbook demonstrates how to create a testing agent using LangChain and Agent-Bay SDK. The agent can:
- Scan Python projects to identify modules that need testing
- Generate test cases using LLMs based on project structure
- Execute tests in isolated AgentBay cloud sessions
- Save test results to local log files

## Framework Integration

Each cookbook is structured to support multiple agent frameworks. Currently, most examples include LangChain integration, with plans to expand to other frameworks. The projects follow a modular structure that separates core functionality from framework-specific integrations:

```
cookbook-name/
├── README.md              # Documentation
├── .env                   # Environment variables
├── common/                # Public core functionality
│   └── src/               # Framework-agnostic code
└── framework-name/        # Framework integration (e.g., langchain)
    ├── data/              # Data directory for outputs
    ├── src/               # Framework-specific code
    └── requirements.txt   # Dependencies (for Python)
```

## Getting Started

To use any of these cookbooks:

1. Ensure you have the AgentBay SDK installed for your preferred language
2. Set up your environment variables, either through:
   - Exporting environment variables directly:
     ```bash
     export AGENTBAY_API_KEY=your_api_key_here
     ```
   - Or using the `.env` file in each cookbook directory (recommended)
3. Some cookbooks may require additional API keys, such as DashScope API key for LLM functionality
4. Navigate to the specific cookbook you're interested in
5. Follow the setup instructions in that cookbook's README.md
6. Run the example scripts to see the SDK in action

## Prerequisites

Before using the cookbooks, you need to:

1. Register an Alibaba Cloud account: [https://aliyun.com](https://aliyun.com)
2. Get APIKEY credentials: [AgentBay Console](https://agentbay.console.aliyun.com/service-management)
3. Install the required dependencies for each cookbook (usually Python packages)

## Contributing

If you'd like to contribute new cookbooks or improve existing ones, please follow the established structure and submit a pull request. Each cookbook should demonstrate a clear, practical use case for the AgentBay SDK.



# Form-Filling Agent

This project demonstrates how to create a form-filling agent using the Agent-Bay SDK. The agent can upload an HTML form to Agent-Bay, open it in a browser, and automatically fill it with data based on natural language instructions.

## Features

- Uploads an HTML form to Agent-Bay environment
- Opens the form in a browser using Agent-Bay's browser capabilities
- Uses natural language instructions to fill form fields
- Submits the form automatically

## Framework Integration Guides

This project is structured to support multiple agent frameworks. Please refer to the specific framework integration guide for detailed setup and usage instructions:

- [LangChain Integration Guide](./langchain/README.md) - Complete setup and usage instructions for LangChain framework

## Project Structure

This project follows a modular structure that separates core functionality from framework-specific integrations:

```
├── README.md            # Documentation
├── .env                 # Environment variables
├── common/              # Public core functionality
│   ├── src/             # Framework-agnostic code
│   │   ├── form.html    # Sample HTML form
│   │   └── form_filler.py # Core form filling functionality
│   └── README.md        # Documentation
├── langchain/           # LangChain integration
│   ├── data/            # Data directory for outputs (screenshots, etc.)
│   ├── src/             # LangChain-specific code
│   │   ├── form_filling_agent.py       # LangChain-specific implementation
│   │   └── form_filling_agent_example.py # Example script for LangChain orchestration
│   └── requirements.txt # Python dependencies
```

### Common Module

The [common](./common/) directory contains all the core functionality that can be used across different agent frameworks. This includes:

- Session management with Agent-Bay
- File upload operations
- Browser initialization and control
- Form filling operations
- Resource cleanup

### Framework Integration Modules

Framework-specific directories (like [langchain](./langchain/)) contain the integration code that uses the core functionality from the common module and wraps it in framework-specific components.

## Customization

You can modify the [form.html](./common/src/form.html) file to use your own form, and update the instructions in the example script to match the fields in your form.

## Agent-Bay SDK Features Used

- Session management
- File system operations (uploading files)
- Browser initialization and control
- BrowserAgent for natural language web automation



# LangChain Integration

This directory contains the LangChain-specific integration for the form-filling agent.

## Sample Output

When the agent successfully fills a form, you will see output similar to the following:

```
> Entering new AgentExecutor chain...

Invoking: `analyze_form` with `/path/to/form.html`

Form at /path/to/form.html has been analyzed. Recommended instructions: ["Enter 'John' in the input field with id firstName", "Enter 'Doe' in the input field with id lastName", ...]

Invoking: `fill_form_fields` with `Enter 'John' in the input field with id firstName;Enter 'Smith' in the input field with id lastName;Enter 'john.smith@example.com' in the input field with id email`

Prepared to fill form with 3 instructions: ["Enter 'John' in the input field with id firstName", "Enter 'Smith' in the input field with id lastName", "Enter 'john.smith@example.com' in the input field with id email"]

Invoking: `execute_form_filling` with `/path/to/form.html`

Session created: session-xxxxxxxxxxxxxxxxx
Form file uploaded successfully
Browser instance successfully initialized
Form page loaded successfully

Instruction executed successfully: Enter 'John' in the input field with id firstName
Instruction executed successfully: Enter 'Smith' in the input field with id lastName
Instruction executed successfully: Enter 'john.smith@example.com' in the input field with id email

Form filling completed successfully! The form has been successfully filled with the provided data:

- **First Name:** John  
- **Last Name:** Smith  
- **Email:** john.smith@example.com  

The form at `/path/to/form.html` was analyzed, populated with your custom data, and submitted successfully.
```

## Setup

### 1. Create Virtual Environment

First, create a virtual environment to isolate project dependencies:

```bash
# Create virtual environment
python -m venv form-filling-agent-env

# Activate virtual environment
# On Windows:
form-filling-agent-env\Scripts\activate
# On macOS/Linux:
source form-filling-agent-env/bin/activate
```

### 2. Install Dependencies

Install the required packages:

```bash
# Update pip
pip install --upgrade pip

# Install core dependencies
pip install wuying-agentbay-sdk playwright python-dotenv

# Install LangChain dependencies
pip install langchain langchain-openai

# Install Playwright browsers
playwright install
```

Alternatively, you can install dependencies using the requirements file:

```bash
pip install -r requirements.txt
```

### 3. Configure Environment Variables

Create a `.env` file in the folder of form-filling-agent/ with your API keys:

```env
# AgentBay API Key (required)
AGENTBAY_API_KEY=your_actual_api_key_here

# DashScope (Alibaba Cloud) API Key for Qwen LLM (required for LangChain orchestration)
DASHSCOPE_API_KEY=your_qwen_api_key_here

# Optional: specify which Qwen model to use (default: qwen-plus)
DASHSCOPE_MODEL=qwen-plus
```

You can get your Agent-Bay API key from the Agent-Bay platform dashboard:
1. Visit [Agent-Bay Console](https://agentbay.console.aliyun.com/service-management)
2. Sign up or log in to your Alibaba Cloud account
3. Navigate to the Service Management section
4. Create a new API KEY or select an existing one
5. Copy the API Key and paste it as the value of `AGENTBAY_API_KEY` in your `.env` file

For the DashScope API key, you need to register on the Alibaba Cloud DashScope platform:
1. Visit [DashScope Platform](https://bailian.console.aliyun.com/#/home)
2. Sign up or log in to your account
3. Navigate to the API Key management section
4. Copy the API Key and paste it as the value of `DASHSCOPE_API_KEY` in your `.env` file

### 4. Available Qwen Models

The following Qwen models are available for use:
- `qwen-turbo`: Fast and efficient model for simple tasks
- `qwen-plus`: Balanced model for most use cases (default)
- `qwen-max`: Most capable model for complex tasks

You can specify which model to use by setting the `DASHSCOPE_MODEL` environment variable in your `.env` file.

## Structure

- [src/](./src/): Contains the LangChain-specific implementation
- [README.md](./README.md): This documentation file

## Integration Details

The LangChain integration uses the core functionality from the [common](../common/) directory and wraps it in LangChain-specific components.

This demonstrates how to:
1. Use LangChain agents with Agent-Bay SDK
2. Structure the code to separate core functionality from framework-specific integration
3. Maintain clean separation of concerns between core logic and framework integration
4. Orchestrate form filling tasks using LangChain's agent framework

## LangChain Orchestration

The form filling agent can be orchestrated using LangChain's agent framework. This provides a more flexible way to interact with the form filling functionality:

1. **Tool-based approach**: The agent exposes tools for analyzing forms, setting filling instructions, and executing the filling process
2. **Natural language interface**: Users can interact with the agent using natural language commands
3. **Sequential workflow**: The agent can automatically determine the correct sequence of operations

### Available Tools

1. `analyze_form`: Analyze a form and suggest filling instructions
2. `fill_form_fields`: Prepare to fill form fields with provided instructions
3. `execute_form_filling`: Execute the form filling process

### Running the Example Script

To run the LangChain orchestration example:

```bash
cd YOUR_PREFIX_PATH/cookbook/envs/browser/form-filling-agent/langchain/
python src/form_filling_agent_example.py
```

This example script demonstrates:
1. Creating a LangChain form filling agent
2. Analyzing a form and suggesting filling instructions
3. Filling the form with custom data
4. Executing the form filling process

### Direct Usage

You can also use the form filling agent directly by instantiating the [LangChainFormFillingAgent](./src/form_filling_agent.py) class and calling its methods.

### Usage Example

```python
from form_filling_agent import create_langchain_form_filling_agent

# Create the agent
agent = create_langchain_form_filling_agent()

# Use the agent with specific instructions
result = agent.invoke({
    "input": "First analyze the form at /path/to/form.html, then fill it with custom data: John as first name, Smith as last name, john.smith@example.com as email, and finally execute the filling process"
})
```



# Auto Testing Agent

This project demonstrates how to create a testing agent using LangChain and Agent-Bay SDK. The agent can scan Python projects, generate test cases using LLMs, and execute them in isolated cloud environments.

## Features

- Scan Python projects to identify modules that need testing
- Generate test cases using LLMs based on project structure
- Execute tests in isolated AgentBay cloud sessions
- Save test results to local log files
- Support for multiple agent frameworks (currently LangChain, with plans for others)

## Framework Integration Guides

This project is structured to support multiple agent frameworks. Please refer to the specific framework integration guide for detailed setup and usage instructions:

- [LangChain Integration Guide](./langchain/README.md) - Complete setup and usage instructions for LangChain framework

## Project Structure

This project follows a modular structure that separates core functionality from framework-specific integrations:

```
├── README.md              # Documentation
├── .env                   # Environment variables
├── common/                # Public core functionality
│   ├── sample_project/    # Sample project for testing
│   └── src/               # Framework-agnostic code
│       └── base_auto_testing_agent.py # Base testing agent class
├── langchain/             # LangChain integration
│   ├── data/              # Data directory for outputs (test results, etc.)
│   ├── src/               # LangChain-specific code
│   │   ├── auto_testing_agent.py          # LangChain-specific implementation
│   │   └── auto_testing_agent_example.py  # Example script for LangChain orchestration
│   └── requirements.txt   # Python dependencies
```

### Common Module

The [common](./common/) directory contains all the core functionality that can be used across different agent frameworks. This includes:

- Base testing agent class with shared functionality
- Project scanning and analysis capabilities
- Test case generation logic
- Session management with Agent-Bay
- Test execution and result saving functionality

### Framework Integration Modules

Framework-specific directories (like [langchain](./langchain/)) contain the integration code that uses the core functionality from the common module and wraps it in framework-specific components.

## Customization

You can modify the code in the [common/sample_project/](./common/sample_project/) directory to test with your own Python projects, and update the instructions in the example script to match your specific testing requirements.

## Agent-Bay SDK Features Used

- Session management
- File system operations (synchronizing project files)
- Command execution (running tests)
- Context management (isolated testing environments)



# LangChain Integration

This directory contains the LangChain-specific integration for the testing agent.

## Sample Output

When the agent successfully tests a Python project, you will see output similar to the following:

```
> Entering new AgentExecutor chain...

Invoking: `scan_project` with `/path/to/sample_project`

Project root: /path/to/sample_project

Directories:

Python files:
  calculator.py
    Classes:
      - Calculator (methods: add, subtract, multiply, divide)
    Functions: add, subtract, multiply, divide, is_even

Invoking: `generate_tests` with `Project root: /path/to/sample_project...`

Generated 1 test case files:
test_calculator.py

Invoking: `execute_tests` with `test_calculator.py`

Session created with ID: session-xxxxxxxxxxxxxxxxx
Uploaded calculator.py to AgentBay environment at calculator.py
Executing test case test_calculator.py

......................
----------------------------------------------------------------------
Ran 22 tests in 0.001s

OK

Executed 1 tests. 1 passed, 0 failed.

Test file: test_calculator.py
Status: PASS

The testing process for the Python project at `/path/to/sample_project` has been successfully completed. Here's a summary:

1. **Project Structure Scanned**: The project contains a single Python file, `calculator.py`, which includes:
   - A `Calculator` class with methods: `add`, `subtract`, `multiply`, and `divide`.
   - Standalone functions: `add`, `subtract`, `multiply`, `divide`, and `is_even`.

2. **Test Cases Generated**: One test file, `test_calculator.py`, was generated to cover the functionality of the `calculator.py` module.

3. **Tests Executed**: The test suite in `test_calculator.py` was executed.
   - **Result**: All 22 tests passed.
   - **Status**: ✅ PASS

No failures were detected. The code appears to be functioning as expected based on the test coverage.
```

## Setup

### 1. Create Virtual Environment

First, create a virtual environment to isolate project dependencies:

```bash
# Create virtual environment
python -m venv auto-testing-agent-env

# Activate virtual environment
# On Windows:
auto-testing-agent-env\Scripts\activate
# On macOS/Linux:
source auto-testing-agent-env/bin/activate
```

### 2. Install Dependencies

Install the required packages:

```bash
# Upgrade pip
pip install --upgrade pip

# Install core dependencies
pip install wuying-agentbay-sdk python-dotenv

# Install LangChain dependencies
pip install langchain langchain-openai

# Install other dependencies
pip install pytest
```

Alternatively, you can install dependencies using the requirements file:

```bash
pip install -r requirements.txt
```

### 3. Configure Environment Variables

Create a `.env` file in the n the folder of auto-testing-agent/ with your API keys:

```env
# AgentBay API Key (required)
AGENTBAY_API_KEY=your_actual_api_key_here

# DashScope (Alibaba Cloud) API Key for Qwen LLM (required for LangChain orchestration)
DASHSCOPE_API_KEY=your_qwen_api_key_here

# Optional: specify which Qwen model to use (default: qwen-plus)
DASHSCOPE_MODEL=qwen-plus
```

You can get your Agent-Bay API key from the Agent-Bay platform dashboard:
1. Visit [Agent-Bay Console](https://agentbay.console.aliyun.com/service-management)
2. Sign up or log in to your Alibaba Cloud account
3. Navigate to the Service Management section
4. Create a new API KEY or select an existing one
5. Copy the API Key and paste it as the value of `AGENTBAY_API_KEY` in your `.env` file

For the DashScope API key, you need to register on the Alibaba Cloud DashScope platform:
1. Visit [DashScope Platform](https://bailian.console.aliyun.com/#/home)
2. Sign up or log in to your account
3. Navigate to the API Key management section
4. Create a new API Key and copy it for use in your `.env` file

### 4. Available Qwen Models

The following Qwen models are available for use:
- `qwen-turbo`: Fast and efficient model for simple tasks
- `qwen-plus`: Balanced model for most use cases (default)
- `qwen-max`: Most capable model for complex tasks

You can specify which model to use by setting the `DASHSCOPE_MODEL` environment variable in your `.env` file.

## Structure

- [src/](./src/): Contains the LangChain-specific implementation
- `data/`: Data directory for outputs (test results, etc.) - created automatically when running tests
- [README.md](./README.md): This documentation file

## Integration Details

The LangChain integration uses the core functionality from the [common](../common/) directory and wraps it in LangChain-specific components.

This demonstrates how to:
1. Use LangChain agents with Agent-Bay SDK
2. Structure the code to separate core functionality from framework-specific integration
3. Maintain clean separation of concerns between core logic and framework integration
4. Orchestrate testing tasks using LangChain's agent framework

## LangChain Orchestration

The testing agent can be orchestrated using LangChain's agent framework. This provides a more flexible way to interact with the testing functionality:

1. **Tool-based approach**: The agent exposes tools for scanning projects, generating tests, and executing them
2. **Natural language interface**: Users can interact with the agent using natural language commands
3. **Sequential workflow**: The agent can automatically determine the correct sequence of operations

### Available Tools

1. `scan_project`: Scan a project directory to identify Python files that need testing
2. `generate_tests`: Generate test cases for the loaded project using LLM
3. `execute_tests`: Execute generated test cases in AgentBay session
4. `save_results`: Save test results to a local log file

### Running the Example Script

To run the LangChain orchestration example:

```bash
cd YOUR_PREFIX_PATH/cookbook/envs/codespace/auto-testing-agent/langchain/
python src/auto_testing_agent_example.py
```

This example script demonstrates:
1. Creating a LangChain testing agent
2. Scanning a project structure
3. Generating tests using LLM
4. Executing the tests in AgentBay session
5. Saving the results to a log file

### Direct Usage

You can also use the testing agent directly by instantiating the [LangChainTestingAgent](./src/auto_testing_agent.py) class and calling its methods.

### Usage Example

```python
from auto_testing_agent import create_langchain_agent

# Create the agent
agent = create_langchain_agent()

# Use the agent
result = agent.invoke({
    "input": "Test the Python project at path/to/your/project"
})
```

## Troubleshooting

If you encounter issues:

1. Ensure your API key is correct and properly set in the `.env` file
2. Check that you have network connectivity to Agent-Bay services
3. Verify that all required packages are installed:
   ```bash
   pip list | grep -E "(wuying-agentbay-sdk|langchain)"
   ```
4. Check that you've activated your virtual environment before running the scripts
5. Make sure the project path specified in PROJECT_PATH exists and contains Python files

