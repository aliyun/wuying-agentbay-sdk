From 9e2b1d098fd9db1ebe0f83358c9b9392a097e0dc Mon Sep 17 00:00:00 2001
From: ltt02016330 <ltt02016330@alibaba-inc.com>
Date: Wed, 2 Jul 2025 16:00:18 +0800
Subject: [PATCH] =?utf-8?q?feat=EF=BC=9Aadd=20params=20with=20activity=20f?=
 =?utf-8?q?or=20application=20startApp?=
MIME-Version: 1.0
Content-Type: text/plain; charset=utf-8
Content-Transfer-Encoding: 8bit

to #67323310
---
 .../examples/application-mobile/README.md     |  52 +++++
 .../application-mobile/application-mobile.ts  | 184 +++++++++++++++
 typescript/src/application/application.ts     |   8 +-
 ...tion.test.ts => application-linux.test.ts} |  86 +++----
 .../integration/application-mobile.test.ts    | 217 ++++++++++++++++++
 typescript/tests/unit/application.test.ts     |  78 +++++++
 6 files changed, 581 insertions(+), 44 deletions(-)
 create mode 100644 typescript/examples/application-mobile/README.md
 create mode 100644 typescript/examples/application-mobile/application-mobile.ts
 rename typescript/tests/integration/{application.test.ts => application-linux.test.ts} (79%)
 create mode 100644 typescript/tests/integration/application-mobile.test.ts

diff --git a/typescript/examples/application-mobile/README.md b/typescript/examples/application-mobile/README.md
new file mode 100644
index 0000000..f9a3f48
--- /dev/null
+++ b/typescript/examples/application-mobile/README.md
@@ -0,0 +1,52 @@
+# Mobile Application Management Example
+
+This example demonstrates how to use the AgentBay SDK to interact with mobile applications on Android devices.
+
+## Features Demonstrated
+
+- Mobile Application Management:
+  - Getting a list of installed mobile applications
+  - Starting mobile applications with simple commands (monkey commands)
+  - Starting mobile applications with specific activities
+  - Stopping mobile applications by command (am force-stop)
+  - Listing visible (running) mobile applications
+
+- Mobile-Specific Operations:
+  - Android package management commands
+  - Activity-based application launching
+  - Complete mobile application workflow demonstration
+
+## Running the Example
+
+Make sure you have set your AgentBay API key as an environment variable:
+
+```bash
+export AGENTBAY_API_KEY="your-api-key-here"
+```
+
+Then run the example:
+
+```bash
+npx ts-node application-mobile.ts
+```
+
+## Mobile Commands Used
+
+The example demonstrates typical Android/mobile commands:
+
+- **Start App**: `monkey -p com.autonavi.minimap -c android.intent.category.LAUNCHER 1`
+- **Start App with Activity**: Using activity parameter like `com.xingin.outside.activity.VivoOutsideFeedActivity`
+- **Stop App**: `am force-stop com.sankuai.meituan`
+
+## Workflow Demonstrated
+
+The example includes a complete mobile application workflow:
+
+1. **Get Installed Apps**: Retrieve list of installed mobile applications
+2. **Start Simple App**: Launch app using basic monkey command
+3. **Start App with Activity**: Launch app with specific activity parameter
+4. **Stop App**: Stop application using Android force-stop command
+
+## Note
+
+This example is specifically designed for mobile environments and requires a mobile session (`mobile_latest` image). The demonstrated functionality is Android-specific and includes error handling to deal with cases where certain mobile operations are not supported or when running in non-mobile environments.
diff --git a/typescript/examples/application-mobile/application-mobile.ts b/typescript/examples/application-mobile/application-mobile.ts
new file mode 100644
index 0000000..650ef95
--- /dev/null
+++ b/typescript/examples/application-mobile/application-mobile.ts
@@ -0,0 +1,184 @@
+import { AgentBay } from '../../src';
+import { log, logError } from '../../src/utils/logger';
+import { getTestApiKey } from '../../tests/utils/test-helpers';
+
+// Mobile App represents a mobile application in the system
+interface MobileApp {
+  name: string;
+  start_cmd: string;
+  stop_cmd?: string;
+  work_directory?: string;
+}
+
+// Mobile Process represents a running mobile process in the system
+interface MobileProcess {
+  pid: number;
+  pname: string;
+  cmdline?: string;
+  path?: string;
+}
+
+async function main() {
+  // Get API key from environment variable or use default value for testing
+  const apiKey = getTestApiKey();
+
+  // Initialize the AgentBay client
+  const agentBay = new AgentBay({ apiKey });
+
+  // Create a new mobile session
+  log('\nCreating a new mobile session...');
+  const createResponse = await agentBay.create({imageId:'mobile_latest'});
+  const session = createResponse.data;
+  log(`\nMobile session created with ID: ${session.sessionId}`);
+  log(`Create Session RequestId: ${createResponse.requestId}`);
+
+  try {
+    // Mobile Application Management Examples
+    log('\n=== Mobile Application Management Examples ===');
+
+    // Get installed mobile applications
+    log('\nGetting installed mobile applications...');
+    try {
+      const appsResponse = await session.Application.getInstalledApps(true, false, true);
+      log(`Found ${appsResponse.data.length} installed mobile applications`);
+      log(`Get Installed Apps RequestId: ${appsResponse.requestId}`);
+
+      // Print the first 5 mobile apps or fewer if less than 5 are available
+      const count = Math.min(appsResponse.data.length, 5);
+      for (let i = 0; i < count; i++) {
+        const app = appsResponse.data[i];
+        log(`Mobile App ${i + 1}: ${app.name}`);
+        if (app.start_cmd) {
+          log(`  Start Command: ${app.start_cmd}`);
+        }
+        if (app.stop_cmd) {
+          log(`  Stop Command: ${app.stop_cmd}`);
+        }
+      }
+    } catch (error) {
+      log(`Error getting installed mobile apps: ${error}`);
+    }
+
+    // Start mobile application with simple command (Python example style)
+    log('\nStarting mobile application with simple command...');
+    try {
+      // This matches the Python example: session.application.start_app("monkey -p com.autonavi.minimap -c android.intent.category.LAUNCHER 1")
+      const startCmd = "monkey -p com.autonavi.minimap -c android.intent.category.LAUNCHER 1";
+      log(`Starting mobile app with command: ${startCmd}`);
+
+      const startResponse = await session.Application.startApp(startCmd);
+      log(`Start Mobile App RequestId: ${startResponse.requestId}`);
+      log(`Started ${startResponse.data.length} mobile processes`);
+
+      // Print started processes
+      if (startResponse.data.length > 0) {
+        startResponse.data.forEach((proc, index) => {
+          log(`Mobile Process ${index + 1}: ${proc.pname} (PID: ${proc.pid})`);
+          if (proc.cmdline) {
+            log(`  Command Line: ${proc.cmdline}`);
+          }
+        });
+      }
+    } catch (error) {
+      log(`Error starting mobile app: ${error}`);
+    }
+
+    // Start mobile application with activity (Python example style)
+    log('\nStarting mobile application with activity...');
+    try {
+      // This matches the Python example with activity parameter
+      const appPackage = "com.xingin.xhs";
+      const appActivity = "com.xingin.outside.activity.VivoOutsideFeedActivity";
+      const activityStartCmd = `monkey -p ${appPackage} -c android.intent.category.LAUNCHER 1`;
+
+      log(`Starting mobile app with activity: ${appActivity}`);
+      log(`Start command: ${activityStartCmd}`);
+
+      const activityStartResponse = await session.Application.startApp(
+        activityStartCmd,
+        "", // empty work_directory like Python example
+        appActivity
+      );
+      log(`Start Mobile App with Activity RequestId: ${activityStartResponse.requestId}`);
+      log(`Started ${activityStartResponse.data.length} mobile processes with activity`);
+
+      // Print started processes with activity
+      if (activityStartResponse.data.length > 0) {
+        activityStartResponse.data.forEach((proc, index) => {
+          log(`Mobile Process with Activity ${index + 1}: ${proc.pname} (PID: ${proc.pid})`);
+        });
+      }
+    } catch (error) {
+      log(`Error starting mobile app with activity: ${error}`);
+    }
+
+    // Stop mobile application by command (Python example style)
+    log('\nStopping mobile application by command...');
+    try {
+      // This matches the Python example: session.application.stop_app_by_cmd("am force-stop com.sankuai.meituan")
+      const stopCmd = "am force-stop com.sankuai.meituan";
+      log(`Stopping mobile app with command: ${stopCmd}`);
+
+      const stopResponse = await session.Application.stopAppByCmd(stopCmd);
+      log('Mobile application stopped by command successfully');
+      log(`Stop Mobile App by Cmd RequestId: ${stopResponse.requestId}`);
+    } catch (error) {
+      log(`Error stopping mobile app by command: ${error}`);
+    }
+
+    // Demonstrate complete mobile workflow
+    log('\n=== Complete Mobile Workflow Example ===');
+    try {
+      // Step 1: Get installed apps
+      log('Step 1: Getting mobile installed applications...');
+      const workflowAppsResponse = await session.Application.getInstalledApps(true, false, true);
+      log(`Found ${workflowAppsResponse.data.length} mobile apps in workflow`);
+
+      // Step 2: Start mobile app (simple command)
+      log('Step 2: Starting mobile app with simple command...');
+      const workflowStartCmd = "monkey -p com.autonavi.minimap -c android.intent.category.LAUNCHER 1";
+      const workflowStartResponse = await session.Application.startApp(workflowStartCmd);
+      log(`Started mobile app in workflow: ${workflowStartResponse.data.length} processes`);
+
+      // Step 3: Start mobile app with activity
+      log('Step 3: Starting mobile app with activity...');
+      const workflowAppPackage = "com.xingin.xhs";
+      const workflowAppActivity = "com.xingin.outside.activity.VivoOutsideFeedActivity";
+      const workflowActivityStartCmd = `monkey -p ${workflowAppPackage} -c android.intent.category.LAUNCHER 1`;
+
+      const workflowActivityStartResponse = await session.Application.startApp(
+        workflowActivityStartCmd,
+        "",
+        workflowAppActivity
+      );
+      log(`Started mobile app with activity in workflow: ${workflowActivityStartResponse.data.length} processes`);
+
+      // Step 4: Stop mobile app
+      log('Step 4: Stopping mobile app...');
+      const workflowStopCmd = "am force-stop com.sankuai.meituan";
+      const workflowStopResponse = await session.Application.stopAppByCmd(workflowStopCmd);
+      log('Mobile app stopped successfully in workflow');
+
+      log('Mobile workflow completed successfully!');
+    } catch (error) {
+      log(`Error in mobile workflow: ${error}`);
+    }
+
+
+  } finally {
+    // Clean up by deleting the mobile session when we're done
+    log('\nDeleting the mobile session...');
+    try {
+      const deleteResponse = await agentBay.delete(session);
+      log('Mobile session deleted successfully');
+      log(`Delete Session RequestId: ${deleteResponse.requestId}`);
+    } catch (error) {
+      log(`Error deleting mobile session: ${error}`);
+    }
+  }
+}
+
+main().catch(error => {
+  logError('Error in mobile application example execution:', error);
+  process.exit(1);
+});
diff --git a/typescript/src/application/application.ts b/typescript/src/application/application.ts
index 0385c16..7c7223d 100644
--- a/typescript/src/application/application.ts
+++ b/typescript/src/application/application.ts
@@ -206,12 +206,14 @@ export class Application {
    * Starts an application with the given command and optional working directory.
    * @param startCmd The command to start the application.
    * @param workDirectory The working directory for the application. Defaults to an empty string.
+   * @param activity Activity name to launch (e.g. ".SettingsActivity" or "com.package/.Activity"). Defaults to an empty string.
    * @returns API response with started processes and requestId
    * @throws Error if the operation fails.
    */
   async startApp(
     startCmd: string,
-    workDirectory = ""
+    workDirectory = "",
+    activity = ""
   ): Promise<ApiResponseWithData<Process[]>> {
     const args: any = {
       start_cmd: startCmd,
@@ -221,6 +223,10 @@ export class Application {
       args.work_directory = workDirectory;
     }
 
+    if (activity) {
+      args.activity = activity;
+    }
+
     const result = await this.callMcpTool(
       "start_app",
       args,
diff --git a/typescript/tests/integration/application.test.ts b/typescript/tests/integration/application-linux.test.ts
similarity index 79%
rename from typescript/tests/integration/application.test.ts
rename to typescript/tests/integration/application-linux.test.ts
index a2dc1d8..6addaea 100644
--- a/typescript/tests/integration/application.test.ts
+++ b/typescript/tests/integration/application-linux.test.ts
@@ -3,7 +3,7 @@ import { AgentBay, Session } from '../../src';
 import { getTestApiKey } from '../utils/test-helpers';
 import { log } from '../../src/utils/logger';
 
-describe('Application', () => {
+describe('Application - Linux System Tests', () => {
   let session: Session;
   let agentBay: AgentBay;
 
@@ -12,29 +12,29 @@ describe('Application', () => {
     agentBay = new AgentBay({apiKey});
 
     // Create a session with linux_latest image
-    log('Creating a new session for application testing...');
+    log('Creating a new Linux session for application testing...');
     const createResponse = await agentBay.create({ imageId: 'linux_latest' });
     session = createResponse.data;
-    log(`Session created with ID: ${session.sessionId}`);
+    log(`Linux session created with ID: ${session.sessionId}`);
     log(`Create Session RequestId: ${createResponse.requestId || 'undefined'}`);
   });
 
   afterEach(async () => {
-    log('Cleaning up: Deleting the session...');
+    log('Cleaning up: Deleting the Linux session...');
     try {
       const deleteResponse = await agentBay.delete(session);
-      log('Session successfully deleted');
+      log('Linux session successfully deleted');
       log(`Delete Session RequestId: ${deleteResponse.requestId || 'undefined'}`);
     } catch (error) {
-      log(`Warning: Error deleting session: ${error}`);
+      log(`Warning: Error deleting Linux session: ${error}`);
     }
   });
 
-  describe('getInstalledApps()', () => {
-    it.only('should return installed applications with valid properties', async () => {
-      log('Testing getInstalledApps...');
+  describe('getInstalledApps() - Linux', () => {
+    it.only('should return Linux installed applications with valid properties', async () => {
+      log('Testing getInstalledApps for Linux...');
       const appsResponse = await session.Application.getInstalledApps(true, false, true);
-      log(`Found ${appsResponse.data.length} installed applications`);
+      log(`Found ${appsResponse.data.length} Linux installed applications`);
       log(`Get Installed Apps RequestId: ${appsResponse.requestId || 'undefined'}`);
 
       // Verify that the response contains requestId
@@ -47,7 +47,7 @@ describe('Application', () => {
 
       if (appsResponse.data.length > 0) {
         appsResponse.data.forEach((app, index) => {
-          log(`Verifying app ${index + 1}: ${app.name}`);
+          log(`Verifying Linux app ${index + 1}: ${app.name}`);
           expect(app.name).toBeTruthy();
           expect(app.start_cmd).toBeTruthy();
         });
@@ -55,8 +55,8 @@ describe('Application', () => {
     });
   });
 
-  describe('startApp()', () => {
-    it.only('should start an application and return processes', async () => {
+  describe('startApp() - Linux Applications', () => {
+    it.only('should start Linux application and return processes', async () => {
       // Get installed apps from the remote system
       const appsResponse = await session.Application.getInstalledApps(true, false, true);
 
@@ -79,7 +79,7 @@ describe('Application', () => {
 
       try {
         const processesResponse = await session.Application.startApp(startCmd, '');
-        log(`Started ${processesResponse.data.length} processes`);
+        log(`Started ${processesResponse.data.length} Linux processes`);
         log(`Start App RequestId: ${processesResponse.requestId || 'undefined'}`);
 
         // Verify that the response contains requestId
@@ -92,22 +92,22 @@ describe('Application', () => {
 
         if (processesResponse.data.length > 0) {
           processesResponse.data.forEach((proc, index) => {
-            log(`Verifying process ${index + 1}: ${proc.pname} (PID: ${proc.pid})`);
+            log(`Verifying Linux process ${index + 1}: ${proc.pname} (PID: ${proc.pid})`);
             expect(proc.pname).toBeTruthy();
             expect(proc.pid).toBeGreaterThan(0);
             expect(proc).toHaveProperty('cmdline');
           });
         }
       } catch (error) {
-        log(`Note: Failed to start application: ${error}`);
+        log(`Note: Failed to start Linux application: ${error}`);
         // Skip test if we can't start the application
         expect(true).toBe(true);
       }
     });
   });
 
-  describe('stopAppByPName()', () => {
-    it.only('should stop an application by process name', async () => {
+  describe('stopAppByPName() - Linux', () => {
+    it.only('should stop Linux application by process name', async () => {
       try {
         // Get installed apps from the remote system
         const appsResponse = await session.Application.getInstalledApps(true, false, true);
@@ -136,10 +136,10 @@ describe('Application', () => {
         expect(processesResponse.data.length).toBeGreaterThan(0);
 
         const pname = processesResponse.data[0].pname;
-        log(`Stopping application with process name: ${pname}`);
+        log(`Stopping Linux application with process name: ${pname}`);
 
         const stopResponse = await session.Application.stopAppByPName(pname);
-        log('Application stopped by process name successfully');
+        log('Linux application stopped by process name successfully');
         log(`Stop App by PName RequestId: ${stopResponse.requestId || 'undefined'}`);
 
         // Verify that the response contains requestId
@@ -147,15 +147,15 @@ describe('Application', () => {
         expect(typeof stopResponse.requestId).toBe('string');
 
       } catch (error: any) {
-        log(`Note: Failed to stop application by process name: ${error}`);
+        log(`Note: Failed to stop Linux application by process name: ${error}`);
         // Skip test if we can't stop the application
         expect(true).toBe(true);
       }
     });
   });
 
-  describe('stopAppByPID()', () => {
-    it.only('should stop an application by process ID', async () => {
+  describe('stopAppByPID() - Linux', () => {
+    it.only('should stop Linux application by process ID', async () => {
       try {
         // Get installed apps from the remote system
         const appsResponse = await session.Application.getInstalledApps(true, false, true);
@@ -184,15 +184,15 @@ describe('Application', () => {
         expect(processesResponse.data.length).toBeGreaterThan(0);
 
         // Wait 5 seconds to give the application time to open
-        log('Waiting 5 seconds to give applications time to open...');
+        log('Waiting 5 seconds to give Linux applications time to open...');
         await new Promise(resolve => setTimeout(resolve, 5000));
 
         const pid = processesResponse.data[0].pid;
         const pname = processesResponse.data[0].pname;
-        log(`Stopping application with PID: ${pid} and name: ${pname}`);
+        log(`Stopping Linux application with PID: ${pid} and name: ${pname}`);
 
         const stopResponse = await session.Application.stopAppByPID(pid);
-        log('Application stopped by PID successfully');
+        log('Linux application stopped by PID successfully');
         log(`Stop App by PID RequestId: ${stopResponse.requestId || 'undefined'}`);
 
         // Verify that the response contains requestId
@@ -200,28 +200,28 @@ describe('Application', () => {
         expect(typeof stopResponse.requestId).toBe('string');
 
         // Wait 5 seconds to ensure the application has time to close
-        log('Waiting 5 seconds to ensure the application has closed...');
+        log('Waiting 5 seconds to ensure the Linux application has closed...');
         await new Promise(resolve => setTimeout(resolve, 5000));
 
         // Verify the app is no longer visible by using listVisibleApps
         const visibleAppsResponse = await session.Application.listVisibleApps();
 
-        log(`Found ${visibleAppsResponse.data.length} visible applications after stopping`);
+        log(`Found ${visibleAppsResponse.data.length} visible Linux applications after stopping`);
 
         // Check that the app with the stopped PID is no longer in the list
         const stoppedAppStillVisible = visibleAppsResponse.data.some(app => app.pid === pid);
-        log(`Is the stopped app still visible? ${stoppedAppStillVisible}`);
+        log(`Is the stopped Linux app still visible? ${stoppedAppStillVisible}`);
         expect(stoppedAppStillVisible).toBe(false);
       } catch (error: any) {
-        log(`Note: Failed to stop application by PID: ${error}`);
+        log(`Note: Failed to stop Linux application by PID: ${error}`);
         // Skip test if we can't stop the application
         expect(true).toBe(true);
       }
     });
   });
 
-  describe('listVisibleApps()', () => {
-    it.only('should list visible applications with valid properties', async () => {
+  describe('listVisibleApps() - Linux', () => {
+    it.only('should list visible Linux applications with valid properties', async () => {
       try {
         // First, start an application (Terminal) to ensure there's at least one visible app
         // Get installed apps from the remote system
@@ -248,12 +248,12 @@ describe('Application', () => {
         await session.Application.startApp(startCmd, '');
 
         // Wait for the terminal to open
-        log('Waiting 5 seconds to give the terminal time to open...');
+        log('Waiting 5 seconds to give the Linux terminal time to open...');
         await new Promise(resolve => setTimeout(resolve, 5000));
 
         // Now list the visible applications
         const visibleAppsResponse = await session.Application.listVisibleApps();
-        log(`Found ${visibleAppsResponse.data.length} visible applications`);
+        log(`Found ${visibleAppsResponse.data.length} visible Linux applications`);
         log(`List Visible Apps RequestId: ${visibleAppsResponse.requestId || 'undefined'}`);
 
         // Verify that the response contains requestId
@@ -266,21 +266,21 @@ describe('Application', () => {
 
         if (visibleAppsResponse.data.length > 0) {
           visibleAppsResponse.data.forEach((app, index) => {
-            log(`Verifying app ${index + 1}: ${app.pname} (PID: ${app.pid})`);
+            log(`Verifying Linux app ${index + 1}: ${app.pname} (PID: ${app.pid})`);
             expect(app.pname).toBeTruthy();
             expect(app.pid).toBeGreaterThan(0);
           });
         }
       } catch (error) {
-        log(`Note: Failed in listVisibleApps test: ${error}`);
+        log(`Note: Failed in listVisibleApps Linux test: ${error}`);
         // Skip test if we encounter an error
         expect(true).toBe(true);
       }
     });
   });
 
-  describe('stopAppByCmd()', () => {
-    it.only('should stop an application by command', async () => {
+  describe('stopAppByCmd() - Linux', () => {
+    it.only('should stop Linux application by command', async () => {
       try {
         // Get installed apps from the remote system
         const appsResponse = await session.Application.getInstalledApps(true, false, true);
@@ -307,16 +307,16 @@ describe('Application', () => {
         expect(processesResponse.data.length).toBeGreaterThan(0);
 
         // Wait for the terminal to open
-        log('Waiting 5 seconds to give the terminal time to open...');
+        log('Waiting 5 seconds to give the Linux terminal time to open...');
         await new Promise(resolve => setTimeout(resolve, 5000));
 
         // Use a stop command based on the process name
         const stopCmd = `pkill ${processesResponse.data[0].pname}`;
-        log(`Using stop command: ${stopCmd}`);
+        log(`Using Linux stop command: ${stopCmd}`);
 
         // Stop the terminal with the command
         const stopResponse = await session.Application.stopAppByCmd(stopCmd);
-        log('Application stopped by command successfully');
+        log('Linux application stopped by command successfully');
         log(`Stop App by Cmd RequestId: ${stopResponse.requestId || 'undefined'}`);
 
         // Verify that the response contains requestId
@@ -324,7 +324,7 @@ describe('Application', () => {
         expect(typeof stopResponse.requestId).toBe('string');
 
         // Wait for the terminal to close
-        log('Waiting 5 seconds to give the terminal time to close...');
+        log('Waiting 5 seconds to give the Linux terminal time to close...');
         await new Promise(resolve => setTimeout(resolve, 5000));
 
         // Verify the application is no longer visible
@@ -332,7 +332,7 @@ describe('Application', () => {
         const stoppedAppStillVisible = visibleAppsResponse.data.some(app => app.pid === processesResponse.data[0].pid);
         expect(stoppedAppStillVisible).toBe(false);
       } catch (error) {
-        log(`Note: Failed in stopAppByCmd test: ${error}`);
+        log(`Note: Failed in stopAppByCmd Linux test: ${error}`);
         // Skip test if we encounter an error
         expect(true).toBe(true);
       }
diff --git a/typescript/tests/integration/application-mobile.test.ts b/typescript/tests/integration/application-mobile.test.ts
new file mode 100644
index 0000000..0923096
--- /dev/null
+++ b/typescript/tests/integration/application-mobile.test.ts
@@ -0,0 +1,217 @@
+import { InstalledApp, Process } from '../../src/application/application';
+import { AgentBay, Session } from '../../src';
+import { getTestApiKey } from '../utils/test-helpers';
+import { log } from '../../src/utils/logger';
+
+describe('Application - Mobile System Tests', () => {
+  let session: Session;
+  let agentBay: AgentBay;
+
+  beforeEach(async () => {
+    const apiKey = getTestApiKey();
+    agentBay = new AgentBay({apiKey});
+
+    // Create a session with mobile_latest image
+    log('Creating a new mobile session for application testing...');
+    const createResponse = await agentBay.create({ imageId: 'mobile_latest' });
+    session = createResponse.data;
+    log(`Mobile session created with ID: ${session.sessionId}`);
+    log(`Create Session RequestId: ${createResponse.requestId || 'undefined'}`);
+  });
+
+  afterEach(async () => {
+    log('Cleaning up: Deleting the mobile session...');
+    try {
+      const deleteResponse = await agentBay.delete(session);
+      log('Mobile session successfully deleted');
+      log(`Delete Session RequestId: ${deleteResponse.requestId || 'undefined'}`);
+    } catch (error) {
+      log(`Warning: Error deleting mobile session: ${error}`);
+    }
+  });
+
+  describe('getInstalledApps() - Mobile', () => {
+    it.only('should return mobile installed applications with valid properties', async () => {
+      log('Testing getInstalledApps for mobile...');
+      const appsResponse = await session.Application.getInstalledApps(true, false, true);
+      log(`Found ${appsResponse.data.length} mobile installed applications`);
+      log(`Get Installed Apps RequestId: ${appsResponse.requestId || 'undefined'}`);
+
+      // Verify that the response contains requestId
+      expect(appsResponse.requestId).toBeDefined();
+      expect(typeof appsResponse.requestId).toBe('string');
+
+      // Verify results
+      expect(appsResponse.data).toBeDefined();
+      expect(Array.isArray(appsResponse.data)).toBe(true);
+
+      if (appsResponse.data.length > 0) {
+        appsResponse.data.forEach((app, index) => {
+          log(`Verifying mobile app ${index + 1}: ${app.name}`);
+          expect(app.name).toBeTruthy();
+          expect(app.start_cmd).toBeTruthy();
+        });
+      }
+    });
+  });
+
+  describe('startApp() - Mobile Applications (Python Example Style)', () => {
+    it.only('should start mobile app with simple command like Python example', async () => {
+      try {
+        // Test case matching Python example usage:
+        // session.application.start_app("monkey -p com.autonavi.minimap -c android.intent.category.LAUNCHER 1")
+        const startCmd = "monkey -p com.autonavi.minimap -c android.intent.category.LAUNCHER 1";
+        log(`Starting mobile app with command: ${startCmd}`);
+
+        const processesResponse = await session.Application.startApp(startCmd);
+        log(`Start Mobile App RequestId: ${processesResponse.requestId || 'undefined'}`);
+
+        // Verify that the response contains requestId
+        expect(processesResponse.requestId).toBeDefined();
+        expect(typeof processesResponse.requestId).toBe('string');
+
+        // Verify results structure
+        expect(processesResponse.data).toBeDefined();
+        expect(Array.isArray(processesResponse.data)).toBe(true);
+
+        log(`Mobile app start result: ${processesResponse.data.length} processes`);
+        if (processesResponse.data.length > 0) {
+          processesResponse.data.forEach((proc, index) => {
+            log(`Mobile process ${index + 1}: ${proc.pname} (PID: ${proc.pid})`);
+            expect(proc.pname).toBeTruthy();
+            expect(proc.pid).toBeGreaterThan(0);
+          });
+        }
+      } catch (error) {
+        log(`Note: Mobile app start test (expected in mobile environment): ${error}`);
+        // This test is expected to work mainly in mobile environments
+        expect(true).toBe(true);
+      }
+    });
+
+    it.only('should start mobile app with activity like Python example', async () => {
+      try {
+        // Test case matching Python example usage with activity:
+        // session.application.start_app(start_cmd=start_cmd, activity=app_activity)
+        const appPackage = "com.xingin.xhs";
+        const appActivity = "com.xingin.outside.activity.VivoOutsideFeedActivity";
+        const startCmd = `monkey -p ${appPackage} -c android.intent.category.LAUNCHER 1`;
+
+        log(`Starting mobile app with activity: ${appActivity}`);
+        log(`Start command: ${startCmd}`);
+
+        const processesResponse = await session.Application.startApp(
+          startCmd,
+          "", // empty work_directory like Python example
+          appActivity
+        );
+        log(`Start Mobile App with Activity RequestId: ${processesResponse.requestId || 'undefined'}`);
+
+        // Verify that the response contains requestId
+        expect(processesResponse.requestId).toBeDefined();
+        expect(typeof processesResponse.requestId).toBe('string');
+
+        // Verify results structure
+        expect(processesResponse.data).toBeDefined();
+        expect(Array.isArray(processesResponse.data)).toBe(true);
+
+        log(`Mobile app with activity start result: ${processesResponse.data.length} processes`);
+        if (processesResponse.data.length > 0) {
+          processesResponse.data.forEach((proc, index) => {
+            log(`Mobile process with activity ${index + 1}: ${proc.pname} (PID: ${proc.pid})`);
+            expect(proc.pname).toBeTruthy();
+            expect(proc.pid).toBeGreaterThan(0);
+          });
+        }
+      } catch (error) {
+        log(`Note: Mobile app with activity test (expected in mobile environment): ${error}`);
+        // This test is expected to work mainly in mobile environments
+        expect(true).toBe(true);
+      }
+    });
+  });
+
+  describe('stopAppByCmd() - Mobile Style (Python Example)', () => {
+    it.only('should stop mobile app by command like Python example', async () => {
+      try {
+        // Test case matching Python example usage:
+        // session.application.stop_app_by_cmd("am force-stop com.sankuai.meituan")
+        const stopCmd = "am force-stop com.sankuai.meituan";
+        log(`Stopping mobile app with command: ${stopCmd}`);
+
+        const stopResponse = await session.Application.stopAppByCmd(stopCmd);
+        log('Mobile application stopped by command successfully');
+        log(`Stop Mobile App by Cmd RequestId: ${stopResponse.requestId || 'undefined'}`);
+
+        // Verify that the response contains requestId
+        expect(stopResponse.requestId).toBeDefined();
+        expect(typeof stopResponse.requestId).toBe('string');
+
+        // stopAppByCmd returns void data
+        expect(stopResponse.data).toBeUndefined();
+      } catch (error) {
+        log(`Note: Mobile app stop by command test (expected in mobile environment): ${error}`);
+        // This test is expected to work mainly in mobile environments
+        expect(true).toBe(true);
+      }
+    });
+  });
+
+  describe('Mobile App Management Integration', () => {
+    it.only('should handle complete mobile workflow like Python example', async () => {
+      try {
+        // Test complete workflow matching Python example:
+        // 1. Get installed apps
+        log('Step 1: Getting mobile installed applications...');
+        const appsResponse = await session.Application.getInstalledApps(true, false, true);
+
+        expect(appsResponse.requestId).toBeDefined();
+        expect(appsResponse.data).toBeDefined();
+        expect(Array.isArray(appsResponse.data)).toBe(true);
+        log(`Found ${appsResponse.data.length} mobile apps`);
+
+        // 2. Start mobile app (simple command)
+        log('Step 2: Starting mobile app with simple command...');
+        const startCmd = "monkey -p com.autonavi.minimap -c android.intent.category.LAUNCHER 1";
+        const startResponse = await session.Application.startApp(startCmd);
+
+        expect(startResponse.requestId).toBeDefined();
+        expect(startResponse.data).toBeDefined();
+        expect(Array.isArray(startResponse.data)).toBe(true);
+        log(`Started mobile app: ${startResponse.data.length} processes`);
+
+        // 3. Start mobile app with activity
+        log('Step 3: Starting mobile app with activity...');
+        const appPackage = "com.xingin.xhs";
+        const appActivity = "com.xingin.outside.activity.VivoOutsideFeedActivity";
+        const activityStartCmd = `monkey -p ${appPackage} -c android.intent.category.LAUNCHER 1`;
+
+        const activityStartResponse = await session.Application.startApp(
+          activityStartCmd,
+          "",
+          appActivity
+        );
+
+        expect(activityStartResponse.requestId).toBeDefined();
+        expect(activityStartResponse.data).toBeDefined();
+        expect(Array.isArray(activityStartResponse.data)).toBe(true);
+        log(`Started mobile app with activity: ${activityStartResponse.data.length} processes`);
+
+        // 4. Stop mobile app
+        log('Step 4: Stopping mobile app...');
+        const stopCmd = "am force-stop com.sankuai.meituan";
+        const stopResponse = await session.Application.stopAppByCmd(stopCmd);
+
+        expect(stopResponse.requestId).toBeDefined();
+        expect(stopResponse.data).toBeUndefined(); // void response
+        log('Mobile app stopped successfully');
+
+        log('Mobile workflow completed successfully!');
+      } catch (error) {
+        log(`Note: Mobile workflow test (expected in mobile environment): ${error}`);
+        // This test is expected to work mainly in mobile environments
+        expect(true).toBe(true);
+      }
+    });
+  });
+});
diff --git a/typescript/tests/unit/application.test.ts b/typescript/tests/unit/application.test.ts
index 3d2cf3a..6a0f0ae 100644
--- a/typescript/tests/unit/application.test.ts
+++ b/typescript/tests/unit/application.test.ts
@@ -138,6 +138,84 @@ describe('ApplicationApi', () => {
         });
     });
 
+    describe('test_start_app_with_activity_success', () => {
+        it('should start app with activity successfully', async () => {
+            const callMcpToolStub = sandbox.stub(mockApplication as any, 'callMcpTool')
+                .resolves({
+                    data: {},
+                    textContent: JSON.stringify(mockProcessData),
+                    isError: false,
+                    statusCode: 200,
+                    requestId: 'test-request-id'
+                });
+
+            const result = await mockApplication.startApp(
+                "monkey -p com.autonavi.minimap -c android.intent.category.LAUNCHER 1",
+                "",
+                ".SettingsActivity"
+            );
+
+            expect(result.data).toHaveLength(1);
+            expect(result.data[0].pname).toBe("com.autonavi.minimap");
+            expect(result.data[0].pid).toBe(12345);
+            expect(result.data[0].cmdline).toBe(
+                "monkey -p com.autonavi.minimap -c android.intent.category.LAUNCHER 1"
+            );
+            expect(result.requestId).toBe('test-request-id');
+
+            // Verify that activity was passed correctly
+            expect(callMcpToolStub.calledOnce).toBe(true);
+            const callArgs = callMcpToolStub.getCall(0).args;
+            expect(callArgs[0]).toBe('start_app');
+            expect(callArgs[1]).toEqual({
+                start_cmd: "monkey -p com.autonavi.minimap -c android.intent.category.LAUNCHER 1",
+                activity: ".SettingsActivity"
+            });
+        });
+    });
+
+    describe('test_start_app_with_activity_and_work_directory', () => {
+        it('should start app with activity and work directory successfully', async () => {
+            const mockXhsProcessData: Process[] = [
+                {
+                    pname: "com.xingin.xhs",
+                    pid: 23456,
+                    cmdline: "monkey -p com.xingin.xhs -c android.intent.category.LAUNCHER 1"
+                }
+            ];
+
+            const callMcpToolStub = sandbox.stub(mockApplication as any, 'callMcpTool')
+                .resolves({
+                    data: {},
+                    textContent: JSON.stringify(mockXhsProcessData),
+                    isError: false,
+                    statusCode: 200,
+                    requestId: 'test-request-456'
+                });
+
+            const result = await mockApplication.startApp(
+                "monkey -p com.xingin.xhs -c android.intent.category.LAUNCHER 1",
+                "/storage/emulated/0",
+                "com.xingin.xhs/.MainActivity"
+            );
+
+            expect(result.data).toHaveLength(1);
+            expect(result.data[0].pname).toBe("com.xingin.xhs");
+            expect(result.data[0].pid).toBe(23456);
+            expect(result.requestId).toBe('test-request-456');
+
+            // Verify all parameters were passed correctly
+            expect(callMcpToolStub.calledOnce).toBe(true);
+            const callArgs = callMcpToolStub.getCall(0).args;
+            expect(callArgs[0]).toBe('start_app');
+            expect(callArgs[1]).toEqual({
+                start_cmd: "monkey -p com.xingin.xhs -c android.intent.category.LAUNCHER 1",
+                work_directory: "/storage/emulated/0",
+                activity: "com.xingin.xhs/.MainActivity"
+            });
+        });
+    });
+
     describe('test_stop_app_by_cmd_success', () => {
         it('should stop app by command successfully', async () => {
             const callMcpToolStub = sandbox.stub(mockApplication as any, 'callMcpTool')
-- 
2.39.0.windows.2

